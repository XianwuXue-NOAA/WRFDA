\startmanpage
\mantitle{MPI{\tt \char`\_}Type{\tt \char`\_}struct}{tex}{5/8/2006}
\manname{MPI{\tt \char`\_}Type{\tt \char`\_}struct}
--- Creates a struct datatype 
\subhead{Synopsis}
\startvb\begin{verbatim}
int MPI_Type_struct(int count,
                   int blocklens[],
                   MPI_Aint indices[],
                   MPI_Datatype old_types[],
                   MPI_Datatype *newtype)

\end{verbatim}
\endvb

\subhead{Input Parameters}
\startarg{count }{number of blocks (integer) -- also number of 
entries in arrays array{\tt \char`\_}of{\tt \char`\_}types ,
array{\tt \char`\_}of{\tt \char`\_}displacements  and array{\tt \char`\_}of{\tt \char`\_}blocklengths  
}
\startarg{blocklens }{number of elements in each block (array)
}
\startarg{indices }{byte displacement of each block (array)
}
\startarg{old{\tt \char`\_}types }{type of elements in each block (array 
of handles to datatype objects) 
}
\par
\subhead{Output Parameter}
\startarg{newtype }{new datatype (handle) 
}
\par
\subhead{Deprecated Function}
The MPI-2 standard deprecated a number of routines because MPI-2 provides
better versions.  This routine is one of those that was deprecated.  The
routine may continue to be used, but new code should use the replacement
routine.
The replacement for this routine is {\tt MPI{\tt \char`\_}Type{\tt \char`\_}create{\tt \char`\_}struct
}
\par
\subhead{Notes}
If an upperbound is set explicitly by using the MPI datatype {\tt MPI{\tt \char`\_}UB}, the
corresponding index must be positive.
\par
The MPI standard originally made vague statements about padding and alignment;
this was intended to allow the simple definition of structures that could
be sent with a count greater than one.  For example,
\begin{verbatim}
    struct { int a; char b; } foo;
\end{verbatim}

may have {\tt sizeof(foo) $>$ sizeof(int) + sizeof(char)}; for example,
{\tt sizeof(foo) $=$$=$ 2*sizeof(int)}.  The initial version of the MPI standard
defined the extent of a datatype as including an {\em epsilon} that would have
allowed an implementation to make the extent an MPI datatype
for this structure equal to {\tt 2*sizeof(int)}.
However, since different systems might define different paddings, there was
much discussion by the MPI Forum about what was the correct value of
epsilon, and one suggestion was to define epsilon as zero.
This would have been the best thing to do in MPI 1.0, particularly since
the {\tt MPI{\tt \char`\_}UB} type allows the user to easily set the end of the structure.
Unfortunately, this change did not make it into the final document.
Currently, this routine does not add any padding, since the amount of
padding needed is determined by the compiler that the user is using to
build their code, not the compiler used to construct the MPI library.
A later version of MPICH may provide for some natural choices of padding
(e.g., multiple of the size of the largest basic member), but users are
advised to never depend on this, even with vendor MPI implementations.
Instead, if you define a structure datatype and wish to send or receive
multiple items, you should explicitly include an {\tt MPI{\tt \char`\_}UB} entry as the
last member of the structure.  For example, the following code can be used
for the structure foo
\begin{verbatim}
    blen[0] = 1; indices[0] = 0; oldtypes[0] = MPI_INT;
    blen[1] = 1; indices[1] = &foo.b - &foo; oldtypes[1] = MPI_CHAR;
    blen[2] = 1; indices[2] = sizeof(foo); oldtypes[2] = MPI_UB;
    MPI_Type_struct( 3, blen, indices, oldtypes, &newtype );
\end{verbatim}

\par
\subhead{Thread and Interrupt Safety}
\par
This routine is thread-safe.  This means that this routine may be
safely used by multiple threads without the need for any user-provided
thread locks.  However, the routine is not interrupt safe.  Typically,
this is due to the use of memory allocation routines such as {\tt malloc
}or other non-MPICH runtime routines that are themselves not interrupt-safe.
\par
\subhead{Notes for Fortran}
All MPI routines in Fortran (except for {\tt MPI{\tt \char`\_}WTIME} and {\tt MPI{\tt \char`\_}WTICK}) have
an additional argument {\tt ierr} at the end of the argument list.  {\tt ierr
}is an integer and has the same meaning as the return value of the routine
in C.  In Fortran, MPI routines are subroutines, and are invoked with the
{\tt call} statement.
\par
All MPI objects (e.g., {\tt MPI{\tt \char`\_}Datatype}, {\tt MPI{\tt \char`\_}Comm}) are of type {\tt INTEGER
}in Fortran.
\par
\subhead{Errors}
\par
All MPI routines (except {\tt MPI{\tt \char`\_}Wtime} and {\tt MPI{\tt \char`\_}Wtick}) return an error value;
C routines as the value of the function and Fortran routines in the last
argument.  Before the value is returned, the current MPI error handler is
called.  By default, this error handler aborts the MPI job.  The error handler
may be changed with {\tt MPI{\tt \char`\_}Comm{\tt \char`\_}set{\tt \char`\_}errhandler} (for communicators),
{\tt MPI{\tt \char`\_}File{\tt \char`\_}set{\tt \char`\_}errhandler} (for files), and {\tt MPI{\tt \char`\_}Win{\tt \char`\_}set{\tt \char`\_}errhandler} (for
RMA windows).  The MPI-1 routine {\tt MPI{\tt \char`\_}Errhandler{\tt \char`\_}set} may be used but
its use is deprecated.  The predefined error handler
{\tt MPI{\tt \char`\_}ERRORS{\tt \char`\_}RETURN} may be used to cause error values to be returned.
Note that MPI does {\em not} guarentee that an MPI program can continue past
an error; however, MPI implementations will attempt to continue whenever
possible.
\par
\startarg{MPI{\tt \char`\_}SUCCESS }{No error; MPI routine completed successfully.
}
\startarg{MPI{\tt \char`\_}ERR{\tt \char`\_}TYPE }{Invalid datatype argument.  May be an uncommitted 
MPI{\tt \char`\_}Datatype (see {\tt MPI{\tt \char`\_}Type{\tt \char`\_}commit}).
}
\startarg{MPI{\tt \char`\_}ERR{\tt \char`\_}COUNT }{Invalid count argument.  Count arguments must be 
non-negative; a count of zero is often valid.
}
\startarg{MPI{\tt \char`\_}ERR{\tt \char`\_}INTERN }{This error is returned when some part of the MPICH 
implementation is unable to acquire memory.  
}
\location{type{\tt \char`\_}struct.c}
\endmanpage
