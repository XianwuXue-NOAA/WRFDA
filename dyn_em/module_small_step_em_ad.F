!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     a_module_small_step_em
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_configure
use module_model_constants
use module_small_step_em

USE module_trace, only : trace_entry, trace_exit

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains

subroutine a_advance_mu_t( ww, a_ww, ww_1, a_ww_1, u, a_u, u_1, a_u_1, v, a_v, v_1, a_v_1, a_mu, a_mut, a_muave, a_muts, muu, &
&a_muu, muv, a_muv, a_mudf, a_t, t_1, a_t_1, a_t_ave, a_ft, mu_tend, a_mu_tend, rdx, rdy, dts, epssm, dnw, fnm, fnp, rdnw, msfu, &
&msfv, msft, config_flags, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ft(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_mu_tend(ims:ime,jms:jme)
real, intent(inout) :: a_muave(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_t(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_ave(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_1(ims:ime,kms:kme,jms:jme)
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: dnw(kms:kme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(in) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ww_1(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
real a_dmdt(its:ite)
real a_dvdxi(its:ite,kts:kte)
real a_wdtn(its:ite,kts:kte)
real dmdt(its:ite)
real dvdxi(its:ite,kts:kte)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
integer k_start

   call trace_entry("a_advance_mu_t")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_dmdt(:) = 0.
a_dvdxi(:,:) = 0.
a_wdtn(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = kte-1
! recompute : k_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. its .eq. ids) then
  i_start = i_start+1
endif
! recompute : i_start
if ((config_flags%specified .or. config_flags%nested) .and. ite .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. jts .eq. jds) then
  j_start = j_start+1
endif
! recompute : j_start
if ((config_flags%specified .or. config_flags%nested) .and. jte .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
do j = j_start, j_end
  do i = i_start, i_end
    dmdt(i) = 0.
  end do
  do k = k_start, k_end
    do i = i_start, i_end
      dvdxi(i,k) = msft(i,j)*msft(i,j)*(rdy*(v(i,k,j+1)+muv(i,j+1)*v_1(i,k,j+1)/msfv(i,j+1)-(v(i,k,j)+muv(i,j)*v_1(i,k,j)/msfv(i,j)&
&))+rdx*(u(i+1,k,j)+muu(i+1,j)*u_1(i+1,k,j)/msfu(i+1,j)-(u(i,k,j)+muu(i,j)*u_1(i,k,j)/msfu(i,j))))
      dmdt(i) = dmdt(i)+dnw(k)*dvdxi(i,k)
    end do
  end do
  do k = 2, k_end
    do i = i_start, i_end
      ww(i,k,j) = ww(i,k-1,j)-dnw(k-1)*(dmdt(i)+dvdxi(i,k-1)+mu_tend(i,j))/msft(i,j)
    end do
  end do
  do k = 1, k_end
    do i = i_start, i_end
      ww(i,k,j) = ww(i,k,j)-ww_1(i,k,j)
    end do
  end do
end do
! recompute : ww
do j = j_start, j_end
  do k = 1, k_end
    do i = i_start, i_end
      a_t_1(i,k,j-1) = a_t_1(i,k,j-1)+0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdy*v(i,k,j)
      a_t_1(i,k,j+1) = a_t_1(i,k,j+1)-0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdy*v(i,k,j+1)
      a_t_1(i-1,k,j) = a_t_1(i-1,k,j)+0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdx*u(i,k,j)
      a_t_1(i+1,k,j) = a_t_1(i+1,k,j)-0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdx*u(i+1,k,j)
      a_t_1(i,k,j) = a_t_1(i,k,j)-a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*(0.5*rdy*(v(i,k,j+1)-v(i,k,j))+0.5*rdx*(u(i+1,k,j)-u(i,k,j)))
      a_u(i+1,k,j) = a_u(i+1,k,j)-0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdx*(t_1(i+1,k,j)+t_1(i,k,j))
      a_u(i,k,j) = a_u(i,k,j)+0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdx*(t_1(i,k,j)+t_1(i-1,k,j))
      a_v(i,k,j+1) = a_v(i,k,j+1)-0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdy*(t_1(i,k,j+1)+t_1(i,k,j))
      a_v(i,k,j) = a_v(i,k,j)+0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)*rdy*(t_1(i,k,j)+t_1(i,k,j-1))
      a_wdtn(i,k+1) = a_wdtn(i,k+1)-a_t(i,k,j)*dts*msft(i,j)*rdnw(k)
      a_wdtn(i,k) = a_wdtn(i,k)+a_t(i,k,j)*dts*msft(i,j)*rdnw(k)
    end do
  end do
  do k = 2, k_end
    do i = i_start, i_end
      a_t_1(i,k-1,j) = a_t_1(i,k-1,j)+a_wdtn(i,k)*ww(i,k,j)*fnp(k)
      a_t_1(i,k,j) = a_t_1(i,k,j)+a_wdtn(i,k)*ww(i,k,j)*fnm(k)
      a_ww(i,k,j) = a_ww(i,k,j)+a_wdtn(i,k)*(fnm(k)*t_1(i,k,j)+fnp(k)*t_1(i,k-1,j))
      a_wdtn(i,k) = 0.
    end do
  end do
  do i = i_start, i_end
    a_wdtn(i,kde) = 0.
    a_wdtn(i,1) = 0.
  end do
end do

do j = j_start, j_end
  do k = 1, k_end
    do i = i_start, i_end
      a_ft(i,k,j) = a_ft(i,k,j)+a_t(i,k,j)*msft(i,j)*dts
      a_t(i,k,j) = a_t(i,k,j)+a_t_ave(i,k,j)
      a_t_ave(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do k = 1, k_end
    do i = i_start, i_end
      a_ww_1(i,k,j) = a_ww_1(i,k,j)-a_ww(i,k,j)
    end do
  end do
  do k = k_end, 2, -1
    do i = i_start, i_end
      a_dmdt(i) = a_dmdt(i)-a_ww(i,k,j)*(dnw(k-1)/msft(i,j))
      a_dvdxi(i,k-1) = a_dvdxi(i,k-1)-a_ww(i,k,j)*(dnw(k-1)/msft(i,j))
      a_mu_tend(i,j) = a_mu_tend(i,j)-a_ww(i,k,j)*(dnw(k-1)/msft(i,j))
      a_ww(i,k-1,j) = a_ww(i,k-1,j)+a_ww(i,k,j)
      a_ww(i,k,j) = 0.
    end do
  end do
  do i = i_start, i_end
    a_mu(i,j) = a_mu(i,j)+0.5*a_muave(i,j)*(1+epssm)
    a_muave(i,j) = 0.5*a_muave(i,j)*(1.-epssm)
    a_mu(i,j) = a_mu(i,j)+a_muts(i,j)
    a_mut(i,j) = a_mut(i,j)+a_muts(i,j)
    a_muts(i,j) = 0.
    a_dmdt(i) = a_dmdt(i)+a_mudf(i,j)
    a_mu_tend(i,j) = a_mu_tend(i,j)+a_mudf(i,j)
    a_mudf(i,j) = 0.
    a_dmdt(i) = a_dmdt(i)+a_mu(i,j)*dts
    a_mu_tend(i,j) = a_mu_tend(i,j)+a_mu(i,j)*dts
    a_mu(i,j) = a_mu(i,j)+a_muave(i,j)
    a_muave(i,j) = 0.
  end do
  do k = k_end, k_start, -1
    do i = i_start, i_end
      a_dvdxi(i,k) = a_dvdxi(i,k)+a_dmdt(i)*dnw(k)
      a_muu(i+1,j) = a_muu(i+1,j)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx*(u_1(i+1,k,j)/msfu(i+1,j))
      a_muu(i,j) = a_muu(i,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx*(u_1(i,k,j)/msfu(i,j))
      a_muv(i,j+1) = a_muv(i,j+1)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy*(v_1(i,k,j+1)/msfv(i,j+1))
      a_muv(i,j) = a_muv(i,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy*(v_1(i,k,j)/msfv(i,j))
      a_u(i+1,k,j) = a_u(i+1,k,j)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx
      a_u(i,k,j) = a_u(i,k,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx
      a_u_1(i+1,k,j) = a_u_1(i+1,k,j)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx*(muu(i+1,j)/msfu(i+1,j))
      a_u_1(i,k,j) = a_u_1(i,k,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdx*(muu(i,j)/msfu(i,j))
      a_v(i,k,j+1) = a_v(i,k,j+1)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy
      a_v(i,k,j) = a_v(i,k,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy
      a_v_1(i,k,j+1) = a_v_1(i,k,j+1)+a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy*(muv(i,j+1)/msfv(i,j+1))
      a_v_1(i,k,j) = a_v_1(i,k,j)-a_dvdxi(i,k)*msft(i,j)*msft(i,j)*rdy*(muv(i,j)/msfv(i,j))
      a_dvdxi(i,k) = 0.
    end do
  end do
  do i = i_start, i_end
    a_dmdt(i) = 0.
  end do
end do

   call trace_exit("a_advance_mu_t")

end subroutine a_advance_mu_t


subroutine a_advance_uv( a_u, a_ru_tend, a_v, a_rv_tend, p, a_p, pb, ph, a_ph, php, a_php, alt, a_alt, al, a_al, mu, a_mu, muu, &
&a_muu, cqu, a_cqu, muv, a_muv, cqv, a_cqv, a_mudf, rdx, rdy, dts, cf1, cf2, cf3, fnm, fnp, emdiv, rdnw, config_flags, spec_zone, &
&non_hydrostatic, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_al(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqu(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_php(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(in) :: al(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cf1
real, intent(in) :: cf2
real, intent(in) :: cf3
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: cqu(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cqv(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: emdiv
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
logical, intent(in) :: non_hydrostatic
real, intent(in) :: p(ims:ime,kms:kme,jms:jme)
real, intent(in) :: pb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: php(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
integer, intent(in) :: spec_zone

!==============================================
! declare local variables
!==============================================
real a_dpn(its:ite,kts:kte)
real a_dpxy(its:ite,kts:kte)
real a_mudf_xy(its:ite)
real dpn(its:ite,kts:kte)
real dpxy(its:ite,kts:kte)
real dx
real dy
integer i
integer i_end
integer i_end_up
integer i_endu
integer i_start
integer i_start_up
integer j
integer j_end
integer j_end_vp
integer j_endv
integer j_start
integer j_start_vp
integer k
integer k_end
integer k_start

   call trace_entry("a_advance_uv")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_dpn(:,:) = 0.
a_dpxy(:,:) = 0.
a_mudf_xy(:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (config_flags%nested .or. config_flags%specified) then
  i_start = max(its,ids+spec_zone)
  i_end = min(ite,ide-spec_zone-1)
  j_start = max(jts,jds+spec_zone)
  j_end = min(jte,jde-spec_zone-1)
  k_start = kts
  k_end = min(kte,kde-1)
  i_endu = min(ite,ide-spec_zone)
  j_endv = min(jte,jde-spec_zone)
else
  i_start = its
  i_end = ite
  j_start = jts
  j_end = jte
  k_start = kts
  k_end = kte-1
  i_endu = i_end
  j_endv = j_end
  if (j_end .eq. jde) then
    j_end = j_end-1
  endif
  if (i_end .eq. ide) then
    i_end = i_end-1
  endif
endif
! recompute : i_end,i_endu,i_start,j_end,j_endv,j_start,k_end,k_start
i_start_up = i_start
! recompute : i_start_up
i_end_up = i_endu
! recompute : i_end_up
j_start_vp = j_start
! recompute : j_start_vp
j_end_vp = j_endv
! recompute : j_end_vp
if ((config_flags%open_xs .or. config_flags%symmetric_xs) .and. its .eq. ids) then
  i_start_up = i_start_up+1
endif
! recompute : i_start_up
if ((config_flags%open_xe .or. config_flags%symmetric_xe) .and. ite .eq. ide) then
  i_end_up = i_end_up-1
endif
! recompute : i_end_up
if ((config_flags%open_ys .or. config_flags%symmetric_ys) .and. jts .eq. jds) then
  j_start_vp = j_start_vp+1
endif
! recompute : j_start_vp
if ((config_flags%open_ye .or. config_flags%symmetric_ye) .and. jte .eq. jde) then
  j_end_vp = j_end_vp-1
endif
! recompute : j_end_vp
dx = 1./rdx
! recompute : dx
dy = 1./rdy
! recompute : dy
a_v_outer_j_loop: do j = j_endv, j_start, -1
  if (j .ge. j_start_vp .and. j .le. j_end_vp) then
    do k = k_start, k_end
      do i = i_start, i_end
        dpxy(i,k) = 0.5*rdy*muv(i,j)*(ph(i,k+1,j)-ph(i,k+1,j-1)+ph(i,k,j)-ph(i,k,j-1)+(alt(i,k,j)+alt(i,k,j-1))*(p(i,k,j)-p(i,k,j-&
&1))+(al(i,k,j)+al(i,k,j-1))*(pb(i,k,j)-pb(i,k,j-1)))
      end do
    end do
! recompute : dpxy
    if (non_hydrostatic) then
      do i = i_start, i_end
        dpn(i,1) = 0.5*(cf1*(p(i,1,j)+p(i,1,j-1))+cf2*(p(i,2,j)+p(i,2,j-1))+cf3*(p(i,3,j)+p(i,3,j-1)))
        dpn(i,kde) = 0.
      end do
      do k = k_start+1, k_end
        do i = i_start, i_end
          dpn(i,k) = 0.5*(fnm(k)*(p(i,k,j)+p(i,k,j-1))+fnp(k)*(p(i,k-1,j)+p(i,k-1,j-1)))
        end do
      end do
      do k = k_start, k_end
        do i = i_start, i_end
          dpxy(i,k) = dpxy(i,k)+rdy*(php(i,k,j)-php(i,k,j-1))*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i,j-1)+mu(i,j)))
        end do
      end do
    endif
! recompute : dpxy
    do k = k_start, k_end
      do i = i_start, i_end
        a_cqv(i,k,j) = a_cqv(i,k,j)-a_v(i,k,j)*dts*dpxy(i,k)
        a_dpxy(i,k) = a_dpxy(i,k)-a_v(i,k,j)*dts*cqv(i,k,j)
        a_mudf_xy(i) = a_mudf_xy(i)+a_v(i,k,j)
      end do
    end do
    if (non_hydrostatic) then
! recompute : dpn
      do k = k_start, k_end
        do i = i_start, i_end
          a_dpn(i,k+1) = a_dpn(i,k+1)+a_dpxy(i,k)*rdy*(php(i,k,j)-php(i,k,j-1))*rdnw(k)
          a_dpn(i,k) = a_dpn(i,k)-a_dpxy(i,k)*rdy*(php(i,k,j)-php(i,k,j-1))*rdnw(k)
          a_mu(i,j-1) = a_mu(i,j-1)-0.5*a_dpxy(i,k)*rdy*(php(i,k,j)-php(i,k,j-1))
          a_mu(i,j) = a_mu(i,j)-0.5*a_dpxy(i,k)*rdy*(php(i,k,j)-php(i,k,j-1))
          a_php(i,k,j-1) = a_php(i,k,j-1)-a_dpxy(i,k)*rdy*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i,j-1)+mu(i,j)))
          a_php(i,k,j) = a_php(i,k,j)+a_dpxy(i,k)*rdy*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i,j-1)+mu(i,j)))
        end do
      end do
      do k = k_start+1, k_end
        do i = i_start, i_end
          a_p(i,k-1,j-1) = a_p(i,k-1,j-1)+0.5*a_dpn(i,k)*fnp(k)
          a_p(i,k-1,j) = a_p(i,k-1,j)+0.5*a_dpn(i,k)*fnp(k)
          a_p(i,k,j-1) = a_p(i,k,j-1)+0.5*a_dpn(i,k)*fnm(k)
          a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpn(i,k)*fnm(k)
          a_dpn(i,k) = 0.
        end do
      end do
      do i = i_start, i_end
        a_dpn(i,kde) = 0.
        a_p(i,3,j-1) = a_p(i,3,j-1)+0.5*a_dpn(i,1)*cf3
        a_p(i,3,j) = a_p(i,3,j)+0.5*a_dpn(i,1)*cf3
        a_p(i,2,j-1) = a_p(i,2,j-1)+0.5*a_dpn(i,1)*cf2
        a_p(i,2,j) = a_p(i,2,j)+0.5*a_dpn(i,1)*cf2
        a_p(i,1,j-1) = a_p(i,1,j-1)+0.5*a_dpn(i,1)*cf1
        a_p(i,1,j) = a_p(i,1,j)+0.5*a_dpn(i,1)*cf1

        a_dpn(i,1) = 0.
      end do
    endif
    do k = k_start, k_end
      do i = i_start, i_end
        a_al(i,k,j-1) = a_al(i,k,j-1)+0.5*a_dpxy(i,k)*rdy*muv(i,j)*(pb(i,k,j)-pb(i,k,j-1))
        a_al(i,k,j) = a_al(i,k,j)+0.5*a_dpxy(i,k)*rdy*muv(i,j)*(pb(i,k,j)-pb(i,k,j-1))
        a_alt(i,k,j-1) = a_alt(i,k,j-1)+0.5*a_dpxy(i,k)*rdy*muv(i,j)*(p(i,k,j)-p(i,k,j-1))
        a_alt(i,k,j) = a_alt(i,k,j)+0.5*a_dpxy(i,k)*rdy*muv(i,j)*(p(i,k,j)-p(i,k,j-1))
        a_muv(i,j) = a_muv(i,j)+0.5*a_dpxy(i,k)*rdy*(ph(i,k+1,j)-ph(i,k+1,j-1)+ph(i,k,j)-ph(i,k,j-1)+(alt(i,k,j)+alt(i,k,j-1))*&
&(p(i,k,j)-p(i,k,j-1))+(al(i,k,j)+al(i,k,j-1))*(pb(i,k,j)-pb(i,k,j-1)))
        a_p(i,k,j-1) = a_p(i,k,j-1)-0.5*a_dpxy(i,k)*rdy*muv(i,j)*(alt(i,k,j)+alt(i,k,j-1))
        a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpxy(i,k)*rdy*muv(i,j)*(alt(i,k,j)+alt(i,k,j-1))
        a_ph(i,k+1,j-1) = a_ph(i,k+1,j-1)-0.5*a_dpxy(i,k)*rdy*muv(i,j)
        a_ph(i,k+1,j) = a_ph(i,k+1,j)+0.5*a_dpxy(i,k)*rdy*muv(i,j)
        a_ph(i,k,j-1) = a_ph(i,k,j-1)-0.5*a_dpxy(i,k)*rdy*muv(i,j)
        a_ph(i,k,j) = a_ph(i,k,j)+0.5*a_dpxy(i,k)*rdy*muv(i,j)
        a_dpxy(i,k) = 0.
      end do
    end do
  endif
  do i = i_start, i_end
    a_mudf(i,j-1) = a_mudf(i,j-1)+a_mudf_xy(i)*emdiv*dy
    a_mudf(i,j) = a_mudf(i,j)-a_mudf_xy(i)*emdiv*dy
    a_mudf_xy(i) = 0.
  end do
  do k = k_start, k_end
    do i = i_start, i_end
      a_rv_tend(i,k,j) = a_rv_tend(i,k,j)+a_v(i,k,j)*dts
    end do
  end do
end do a_v_outer_j_loop
do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start_up, i_end_up
      dpxy(i,k) = 0.5*rdx*muu(i,j)*(ph(i,k+1,j)-ph(i-1,k+1,j)+ph(i,k,j)-ph(i-1,k,j)+(alt(i,k,j)+alt(i-1,k,j))*(p(i,k,j)-p(i-1,k,j))&
&+(al(i,k,j)+al(i-1,k,j))*(pb(i,k,j)-pb(i-1,k,j)))
    end do
  end do
! recompute : dpxy
  if (non_hydrostatic) then
    do i = i_start_up, i_end_up
      dpn(i,1) = 0.5*(cf1*(p(i,1,j)+p(i-1,1,j))+cf2*(p(i,2,j)+p(i-1,2,j))+cf3*(p(i,3,j)+p(i-1,3,j)))
      dpn(i,kde) = 0.
    end do
    do k = k_start+1, k_end
      do i = i_start_up, i_end_up
        dpn(i,k) = 0.5*(fnm(k)*(p(i,k,j)+p(i-1,k,j))+fnp(k)*(p(i,k-1,j)+p(i-1,k-1,j)))
      end do
    end do
    do k = k_start, k_end
      do i = i_start_up, i_end_up
        dpxy(i,k) = dpxy(i,k)+rdx*(php(i,k,j)-php(i-1,k,j))*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i-1,j)+mu(i,j)))
      end do
    end do
  endif
! recompute : dpxy
  do k = k_start, k_end
    do i = i_start_up, i_end_up
      a_cqu(i,k,j) = a_cqu(i,k,j)-a_u(i,k,j)*dts*dpxy(i,k)
      a_dpxy(i,k) = a_dpxy(i,k)-a_u(i,k,j)*dts*cqu(i,k,j)
      a_mudf_xy(i) = a_mudf_xy(i)+a_u(i,k,j)
    end do
  end do
  if (non_hydrostatic) then
! recompute : dpn
    do k = k_start, k_end
      do i = i_start_up, i_end_up
        a_dpn(i,k+1) = a_dpn(i,k+1)+a_dpxy(i,k)*rdx*(php(i,k,j)-php(i-1,k,j))*rdnw(k)
        a_dpn(i,k) = a_dpn(i,k)-a_dpxy(i,k)*rdx*(php(i,k,j)-php(i-1,k,j))*rdnw(k)
        a_mu(i-1,j) = a_mu(i-1,j)-0.5*a_dpxy(i,k)*rdx*(php(i,k,j)-php(i-1,k,j))
        a_mu(i,j) = a_mu(i,j)-0.5*a_dpxy(i,k)*rdx*(php(i,k,j)-php(i-1,k,j))
        a_php(i-1,k,j) = a_php(i-1,k,j)-a_dpxy(i,k)*rdx*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i-1,j)+mu(i,j)))
        a_php(i,k,j) = a_php(i,k,j)+a_dpxy(i,k)*rdx*(rdnw(k)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i-1,j)+mu(i,j)))
      end do
    end do
    do k = k_start+1, k_end
      do i = i_start_up, i_end_up
        a_p(i-1,k-1,j) = a_p(i-1,k-1,j)+0.5*a_dpn(i,k)*fnp(k)
        a_p(i,k-1,j) = a_p(i,k-1,j)+0.5*a_dpn(i,k)*fnp(k)
        a_p(i-1,k,j) = a_p(i-1,k,j)+0.5*a_dpn(i,k)*fnm(k)
        a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpn(i,k)*fnm(k)
        a_dpn(i,k) = 0.
      end do
    end do
    do i = i_start_up, i_end_up
      a_dpn(i,kde) = 0.
      a_p(i-1,3,j) = a_p(i-1,3,j)+0.5*a_dpn(i,1)*cf3
      a_p(i,3,j) = a_p(i,3,j)+0.5*a_dpn(i,1)*cf3
      a_p(i-1,2,j) = a_p(i-1,2,j)+0.5*a_dpn(i,1)*cf2
      a_p(i,2,j) = a_p(i,2,j)+0.5*a_dpn(i,1)*cf2
      a_p(i-1,1,j) = a_p(i-1,1,j)+0.5*a_dpn(i,1)*cf1
      a_p(i,1,j) = a_p(i,1,j)+0.5*a_dpn(i,1)*cf1
      a_dpn(i,1) = 0.
    end do
  endif
  do k = k_start, k_end
    do i = i_start_up, i_end_up
      a_al(i-1,k,j) = a_al(i-1,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)*(pb(i,k,j)-pb(i-1,k,j))
      a_al(i,k,j) = a_al(i,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)*(pb(i,k,j)-pb(i-1,k,j))
      a_alt(i-1,k,j) = a_alt(i-1,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)*(p(i,k,j)-p(i-1,k,j))
      a_alt(i,k,j) = a_alt(i,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)*(p(i,k,j)-p(i-1,k,j))
      a_muu(i,j) = a_muu(i,j)+0.5*a_dpxy(i,k)*rdx*(ph(i,k+1,j)-ph(i-1,k+1,j)+ph(i,k,j)-ph(i-1,k,j)+(alt(i,k,j)+alt(i-1,k,j))*(p(i,&
&k,j)-p(i-1,k,j))+(al(i,k,j)+al(i-1,k,j))*(pb(i,k,j)-pb(i-1,k,j)))
      a_p(i-1,k,j) = a_p(i-1,k,j)-0.5*a_dpxy(i,k)*rdx*muu(i,j)*(alt(i,k,j)+alt(i-1,k,j))
      a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)*(alt(i,k,j)+alt(i-1,k,j))
      a_ph(i-1,k+1,j) = a_ph(i-1,k+1,j)-0.5*a_dpxy(i,k)*rdx*muu(i,j)
      a_ph(i,k+1,j) = a_ph(i,k+1,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)
      a_ph(i-1,k,j) = a_ph(i-1,k,j)-0.5*a_dpxy(i,k)*rdx*muu(i,j)
      a_ph(i,k,j) = a_ph(i,k,j)+0.5*a_dpxy(i,k)*rdx*muu(i,j)
      a_dpxy(i,k) = 0.
    end do
  end do
  do i = i_start_up, i_end_up
    a_mudf(i-1,j) = a_mudf(i-1,j)+a_mudf_xy(i)*emdiv*dx
    a_mudf(i,j) = a_mudf(i,j)-a_mudf_xy(i)*emdiv*dx
    a_mudf_xy(i) = 0.
  end do
  do k = k_start, k_end
    do i = i_start, i_endu
      a_ru_tend(i,k,j) = a_ru_tend(i,k,j)+a_u(i,k,j)*dts
    end do
  end do
end do

   call trace_exit("a_advance_uv")

end subroutine a_advance_uv


subroutine a_advance_w( w, a_w, rw_tend, a_rw_tend, ww, a_ww, u, a_u, v, a_v, mu1, a_mu1, mut, a_mut, muave, a_muave, muts, a_muts,&
& t_2ave, a_t_2ave, t_2, a_t_2, t_1, a_t_1, ph, a_ph, ph_1, a_ph_1, phb, ph_tend, a_ph_tend, ht, c2a, a_c2a, cqw, a_cqw, alt, &
&a_alt, alb, a, a_a, alpha, a_alpha, gamma, a_gamma, rdx, rdy, dts, t0, epssm, fnm, fnp, rdnw, rdn, cf1, cf2, cf3, msft, &
&config_flags, ids, ide, jds, jde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(in) :: a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alpha(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqw(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_gamma(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu1(ims:ime,jms:jme)
real, intent(inout) :: a_muave(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2ave(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alpha(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cf1
real, intent(in) :: cf2
real, intent(in) :: cf3
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: cqw(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
real, intent(in) :: gamma(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ht(ims:ime,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: mu1(ims:ime,jms:jme)
real, intent(in) :: muave(ims:ime,jms:jme)
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
real, intent(inout) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: phb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
real, intent(in) :: rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t0
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: t_2ave(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ww(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
real a_mut_inv(its:ite)
real a_rhs(its:ite,kts:kte)
real a_wdwn(its:ite,kts:kte)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
real msft_inv(its:ite)
real mut_inv(its:ite)
real rhs(its:ite,kts:kte)
real t_2aveh(ims:ime,kms:kme,jms:jme)
real wdwn(its:ite,kts:kte)
real wh(ims:ime,kms:kme,jms:jme)
!mzz
real keep1_w(ims:ime,kms:kme,jms:jme)
real keep2_w(ims:ime,kms:kme,jms:jme)
real keep3_w(ims:ime,kms:kme,jms:jme)
!mzz

   call trace_entry("a_advance_w")

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
wh(:,:,:) = w(:,:,:)
t_2aveh(:,:,:) = t_2ave(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_mut_inv(:) = 0.
a_rhs(:,:) = 0.
a_wdwn(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_end = kte-1
! recompute : k_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. its .eq. ids) then
  i_start = i_start+1
endif
! recompute : i_start
if ((config_flags%specified .or. config_flags%nested) .and. ite .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. jts .eq. jds) then
  j_start = j_start+1
endif
! recompute : j_start
if ((config_flags%specified .or. config_flags%nested) .and. jte .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
do j = j_start, j_end
  DO i=i_start, i_end
    rhs(i,1) = 0.
  ENDDO
  do i = i_start, i_end
    mut_inv(i) = 1./mut(i,j)
    msft_inv(i) = 1./msft(i,j)
  end do
! recompute : msft_inv,mut_inv
  do k = 1, k_end
    do i = i_start, i_end
      t_2ave(i,k,j) = 0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2ave(i,k,j))
      t_2ave(i,k,j) = (t_2ave(i,k,j)-mu1(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)))
    end do
  end do
! recompute : t_2ave
  do k = 2, k_end+1
    do i = i_start, i_end
      wdwn(i,k) = 0.5*(ww(i,k,j)+ww(i,k-1,j))*rdnw(k-1)*(ph_1(i,k,j)-ph_1(i,k-1,j)+phb(i,k,j)-phb(i,k-1,j))
      rhs(i,k) = dts*(ph_tend(i,k,j)+0.5*g*(1.-epssm)*w(i,k,j))
    end do
  end do
! recompute : rhs,wdwn
  do k = 2, k_end
    do i = i_start, i_end
      rhs(i,k) = rhs(i,k)-dts*(fnm(k)*wdwn(i,k+1)+fnp(k)*wdwn(i,k))
    end do
  end do
! recompute : rhs
  do k = 2, k_end+1
    do i = i_start, i_end
      rhs(i,k) = ph(i,k,j)+msft(i,j)*rhs(i,k)*mut_inv(i)
    end do
  end do
! recompute : rhs
  do i = i_start, i_end
    w(i,1,j) = 0.5*rdy*((ht(i,j+1)-ht(i,j))*(cf1*v(i,1,j+1)+cf2*v(i,2,j+1)+cf3*v(i,3,j+1))+(ht(i,j)-ht(i,j-1))*(cf1*v(i,1,j)+cf2*&
&v(i,2,j)+cf3*v(i,3,j)))+0.5*rdx*((ht(i+1,j)-ht(i,j))*(cf1*u(i+1,1,j)+cf2*u(i+1,2,j)+cf3*u(i+1,3,j))+(ht(i,j)-ht(i-1,j))*(cf1*&
&u(i,1,j)+cf2*u(i,2,j)+cf3*u(i,3,j)))
  end do
! recompute : w
  do k = 2, k_end
    do i = i_start, i_end
      w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*cqw(i,k,j)*0.5*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*((1.+epssm)*&
&(rhs(i,k+1)-rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))-c2a(i,k-1,j)*rdnw(k-1)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-&
&epssm)*(ph(i,k,j)-ph(i,k-1,j))))+dts*g*msft_inv(i)*(rdn(k)*(c2a(i,k,j)*alt(i,k,j)*t_2ave(i,k,j)-c2a(i,k-1,j)*alt(i,k-1,j)*&
&t_2ave(i,k-1,j))+(rdn(k)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*mut_inv(i)-1.)*muave(i,j))
    end do
  end do
! recompute : w
  k = k_end+1
! recompute : k
  do i = i_start, i_end
    w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*((-(0.5*dts*g*mut_inv(i)*rdnw(k-1)**2*2.*c2a(i,k-1,j)*((1.+epssm)*(rhs(i,k)-&
&rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)-ph(i,k-1,j)))))-dts*g*(2.*rdnw(k-1)*c2a(i,k-1,j)*alt(i,k-1,j)*t_2ave(i,k-1,j)+(1.+2.*rdnw(k-&
&1)*c2a(i,k-1,j)*alb(i,k-1,j)*mut_inv(i))*muave(i,j)))
  end do
! recompute : w
  do k = 2, k_end+1
    do i = i_start, i_end
!mzz
    keep1_w(i,k-1,j) =w(i,k-1,j)
    keep2_w(i,k,j) =w(i,k,j)
!mzz
      w(i,k,j) = (w(i,k,j)-a(i,k,j)*w(i,k-1,j))*alpha(i,k,j)
    end do
  end do
! recompute : w
  do k = k_end, 2, -1
    do i = i_start, i_end
!mzz
    keep3_w(i,k+1,j) =w(i,k+1,j)  
!mzz
      w(i,k,j) = w(i,k,j)-gamma(i,k,j)*w(i,k+1,j)
    end do
  end do
! recompute : w
  do k = 2, k_end+1
    do i = i_start, i_end
      a_muts(i,j) = a_muts(i,j)-a_ph(i,k,j)*(0.5*msft(i,j)*dts*g*(1.+epssm)*w(i,k,j)/(muts(i,j)*muts(i,j)))
      a_rhs(i,k) = a_rhs(i,k)+a_ph(i,k,j)
      a_w(i,k,j) = a_w(i,k,j)+a_ph(i,k,j)*(0.5*msft(i,j)*dts*g*(1.+epssm)/muts(i,j))
      a_ph(i,k,j) = 0.
    end do
  end do
#ifdef ADJOINT_NO_OPTIMIZE
! recdepend vars : cf1,cf2,cf3,ht,i_end,i_start,j,rdx,rdy,u,v
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1361
! recompute vars : w

  do i = i_start, i_end
    w(i,1,j) = 0.5*rdy*((ht(i,j+1)-ht(i,j))*(cf1*v(i,1,j+1)+cf2*v(i,2,j+1)+cf3*v(i,3,j+1))+(ht(i,j)-ht(i,j-1))*(cf1*v(i,1,j)+cf2*&
&v(i,2,j)+cf3*v(i,3,j)))+0.5*rdx*((ht(i+1,j)-ht(i,j))*(cf1*u(i+1,1,j)+cf2*u(i+1,2,j)+cf3*u(i+1,3,j))+(ht(i,j)-ht(i-1,j))*(cf1*&
&u(i,1,j)+cf2*u(i,2,j)+cf3*u(i,3,j)))
  end do
! recompute vars : w
!  recdepend vars : alb,alt,c2a,cqw,dts,epssm,g,i_end,i_start,j,k_end,ms
! ft_inv,muave,mut_inv,ph,rdn,rdnw,rhs,rw_tend,t_2ave,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1382
! recompute vars : w
  do k = 2, k_end
    do i = i_start, i_end
      w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*cqw(i,k,j)*0.5*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*((1.+epssm)*&
&(rhs(i,k+1)-rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))-c2a(i,k-1,j)*rdnw(k-1)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-&
&epssm)*(ph(i,k,j)-ph(i,k-1,j))))+dts*g*msft_inv(i)*(rdn(k)*(c2a(i,k,j)*alt(i,k,j)*t_2ave(i,k,j)-c2a(i,k-1,j)*alt(i,k-1,j)*&
&t_2ave(i,k-1,j))+(rdn(k)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*mut_inv(i)-1.)*muave(i,j))
    end do
  end do
! recompute vars : w
! recdepend vars : k_end,w
! recompute pos : ASSIGN_STMT module_small_step_em.f90:1404
! recompute vars : k
  k = k_end+1
! recompute vars : k
!  recdepend vars : alb,alt,c2a,dts,epssm,g,i_end,i_start,j,k,msft_inv,m
! uave,mut_inv,ph,rdnw,rhs,rw_tend,t_2ave,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1406
! recompute vars : w
  do i = i_start, i_end
    w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*((-(0.5*dts*g*mut_inv(i)*rdnw(k-1)**2*2.*c2a(i,k-1,j)*((1.+epssm)*(rhs(i,k)-&
&rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)-ph(i,k-1,j)))))-dts*g*(2.*rdnw(k-1)*c2a(i,k-1,j)*alt(i,k-1,j)*t_2ave(i,k-1,j)+(1.+2.*rdnw(k-&
&1)*c2a(i,k-1,j)*alb(i,k-1,j)*mut_inv(i))*muave(i,j)))
  end do
! recompute vars : w
! recdepend vars : a,alpha,i_end,i_start,j,k_end,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1418
! recompute vars : w
  do k = 2, k_end+1
    do i = i_start, i_end
      w(i,k,j) = (w(i,k,j)-a(i,k,j)*w(i,k-1,j))*alpha(i,k,j)
    end do
  end do
! recompute vars : w
  do k = k_end, 3, -1
    do i = i_start, i_end
      w(i,k,j) = w(i,k,j)-gamma(i,k,j)*w(i,k+1,j)
    end do
  end do
#endif
  do k = 2, k_end
    do i = i_start, i_end
!mzz
    w(i,k+1,j) =keep3_w(i,k+1,j)  
!mzz
      a_gamma(i,k,j) = a_gamma(i,k,j)-a_w(i,k,j)*w(i,k+1,j)
      a_w(i,k+1,j) = a_w(i,k+1,j)-a_w(i,k,j)*gamma(i,k,j)
    end do
  end do
#ifdef ADJOINT_NO_OPTIMIZE
! recdepend vars : cf1,cf2,cf3,ht,i_end,i_start,j,rdx,rdy,u,v
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1361
! recompute vars : w
  do i = i_start, i_end
    w(i,1,j) = 0.5*rdy*((ht(i,j+1)-ht(i,j))*(cf1*v(i,1,j+1)+cf2*v(i,2,j+1)+cf3*v(i,3,j+1))+(ht(i,j)-ht(i,j-1))*(cf1*v(i,1,j)+cf2*&
&v(i,2,j)+cf3*v(i,3,j)))+0.5*rdx*((ht(i+1,j)-ht(i,j))*(cf1*u(i+1,1,j)+cf2*u(i+1,2,j)+cf3*u(i+1,3,j))+(ht(i,j)-ht(i-1,j))*(cf1*&
&u(i,1,j)+cf2*u(i,2,j)+cf3*u(i,3,j)))
  end do
! recompute vars : w
!  recdepend vars : alb,alt,c2a,cqw,dts,epssm,g,i_end,i_start,j,k_end,ms
! ft_inv,muave,mut_inv,ph,rdn,rdnw,rhs,rw_tend,t_2ave,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1382
! recompute vars : w
  do k = 2, k_end
    do i = i_start, i_end
      w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*cqw(i,k,j)*0.5*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*((1.+epssm)*&
&(rhs(i,k+1)-rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))-c2a(i,k-1,j)*rdnw(k-1)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-&
&epssm)*(ph(i,k,j)-ph(i,k-1,j))))+dts*g*msft_inv(i)*(rdn(k)*(c2a(i,k,j)*alt(i,k,j)*t_2ave(i,k,j)-c2a(i,k-1,j)*alt(i,k-1,j)*&
&t_2ave(i,k-1,j))+(rdn(k)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*mut_inv(i)-1.)*muave(i,j))
    end do
  end do
! recompute vars : w
! recdepend vars : k_end,w
! recompute pos : ASSIGN_STMT module_small_step_em.f90:1404
! recompute vars : k
  k = k_end+1
! recompute vars : k
!  recdepend vars : alb,alt,c2a,dts,epssm,g,i_end,i_start,j,k,msft_inv,m
! uave,mut_inv,ph,rdnw,rhs,rw_tend,t_2ave,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1406
! recompute vars : w
  do i = i_start, i_end
    w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*((-(0.5*dts*g*mut_inv(i)*rdnw(k-1)**2*2.*c2a(i,k-1,j)*((1.+epssm)*(rhs(i,k)-&
&rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)-ph(i,k-1,j)))))-dts*g*(2.*rdnw(k-1)*c2a(i,k-1,j)*alt(i,k-1,j)*t_2ave(i,k-1,j)+(1.+2.*rdnw(k-&
&1)*c2a(i,k-1,j)*alb(i,k-1,j)*mut_inv(i))*muave(i,j)))
  end do
! recompute vars : w
  do k = 2, k_end
    do i = i_start, i_end
      w(i,k,j) = (w(i,k,j)-a(i,k,j)*w(i,k-1,j))*alpha(i,k,j)
    end do
  end do
#endif
  do k = k_end+1, 2, -1
    do i = i_start, i_end
!mzz
     w(i,k-1,j)=keep1_w(i,k-1,j) 
     w(i,k,j)=keep2_w(i,k,j) 
!mzz
      a_a(i,k,j) = a_a(i,k,j)-a_w(i,k,j)*w(i,k-1,j)*alpha(i,k,j)
      a_alpha(i,k,j) = a_alpha(i,k,j)+a_w(i,k,j)*(w(i,k,j)-a(i,k,j)*w(i,k-1,j))
      a_w(i,k-1,j) = a_w(i,k-1,j)-a_w(i,k,j)*a(i,k,j)*alpha(i,k,j)
      a_w(i,k,j) = a_w(i,k,j)*alpha(i,k,j)
    end do
  end do

! recdepend vars : k_end
! recompute pos : ASSIGN_STMT module_small_step_em.f90:1404
! recompute vars : k
  k = k_end+1
! recompute vars : k
  do i = i_start, i_end
    a_alt(i,k-1,j) = a_alt(i,k-1,j)-2*a_w(i,k,j)*msft_inv(i)*dts*g*rdnw(k-1)*c2a(i,k-1,j)*t_2ave(i,k-1,j)
    a_c2a(i,k-1,j) = a_c2a(i,k-1,j)-a_w(i,k,j)*msft_inv(i)*dts*g*(mut_inv(i)*rdnw(k-1)**2*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-&
&epssm)*(ph(i,k,j)-ph(i,k-1,j)))+2*rdnw(k-1)*alt(i,k-1,j)*t_2ave(i,k-1,j)+2*rdnw(k-1)*alb(i,k-1,j)*mut_inv(i)*muave(i,j))
    a_muave(i,j) = a_muave(i,j)-a_w(i,k,j)*msft_inv(i)*dts*g*(1+2.*rdnw(k-1)*c2a(i,k-1,j)*alb(i,k-1,j)*mut_inv(i))
    a_mut_inv(i) = a_mut_inv(i)-a_w(i,k,j)*msft_inv(i)*(dts*g*rdnw(k-1)**2*c2a(i,k-1,j)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-&
&epssm)*(ph(i,k,j)-ph(i,k-1,j)))+2*dts*g*rdnw(k-1)*c2a(i,k-1,j)*alb(i,k-1,j)*muave(i,j))
    a_ph(i,k-1,j) = a_ph(i,k-1,j)+a_w(i,k,j)*msft_inv(i)*dts*g*mut_inv(i)*rdnw(k-1)**2*c2a(i,k-1,j)*(1.-epssm)
    a_ph(i,k,j) = a_ph(i,k,j)-a_w(i,k,j)*msft_inv(i)*dts*g*mut_inv(i)*rdnw(k-1)**2*c2a(i,k-1,j)*(1.-epssm)
    a_rhs(i,k-1) = a_rhs(i,k-1)+a_w(i,k,j)*msft_inv(i)*dts*g*mut_inv(i)*rdnw(k-1)**2*c2a(i,k-1,j)*(1.+epssm)
    a_rhs(i,k) = a_rhs(i,k)-a_w(i,k,j)*msft_inv(i)*dts*g*mut_inv(i)*rdnw(k-1)**2*c2a(i,k-1,j)*(1+epssm)
    a_rw_tend(i,k,j) = a_rw_tend(i,k,j)+a_w(i,k,j)*dts
    a_t_2ave(i,k-1,j) = a_t_2ave(i,k-1,j)-2*a_w(i,k,j)*msft_inv(i)*dts*g*rdnw(k-1)*c2a(i,k-1,j)*alt(i,k-1,j)
  end do
  do k = 2, k_end
    do i = i_start, i_end
      a_alt(i,k-1,j) = a_alt(i,k-1,j)-a_w(i,k,j)*dts*g*msft_inv(i)*rdn(k)*c2a(i,k-1,j)*t_2ave(i,k-1,j)
      a_alt(i,k,j) = a_alt(i,k,j)+a_w(i,k,j)*dts*g*msft_inv(i)*rdn(k)*c2a(i,k,j)*t_2ave(i,k,j)
      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)+a_w(i,k,j)*((-(0.5*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*rdnw(k-1)*((1.+epssm)*&
&(rhs(i,k)-rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)-ph(i,k-1,j)))))+dts*g*msft_inv(i)*((-(rdn(k)*alt(i,k-1,j)*t_2ave(i,k-1,j)))-&
&rdn(k)*alb(i,k-1,j)*mut_inv(i)*muave(i,j)))
      a_c2a(i,k,j) = a_c2a(i,k,j)+a_w(i,k,j)*(0.5*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*rdnw(k)*((1.+epssm)*(rhs(i,k+1)-&
&rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))+dts*g*msft_inv(i)*rdn(k)*(alt(i,k,j)*t_2ave(i,k,j)+alb(i,k,j)*mut_inv(i)*muave(i,j)))
      a_cqw(i,k,j) = a_cqw(i,k,j)+0.5*a_w(i,k,j)*msft_inv(i)*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*((1.+epssm)*(rhs(i,k+1)-&
&rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))-c2a(i,k-1,j)*rdnw(k-1)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)&
&-ph(i,k-1,j))))
      a_muave(i,j) = a_muave(i,j)+a_w(i,k,j)*dts*g*msft_inv(i)*((-1)+rdn(k)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*&
&mut_inv(i))
      a_mut_inv(i) = a_mut_inv(i)+a_w(i,k,j)*(0.5*msft_inv(i)*cqw(i,k,j)*dts*g*rdn(k)*(c2a(i,k,j)*rdnw(k)*((1.+epssm)*(rhs(i,k+1)-&
&rhs(i,k))+(1.-epssm)*(ph(i,k+1,j)-ph(i,k,j)))-c2a(i,k-1,j)*rdnw(k-1)*((1.+epssm)*(rhs(i,k)-rhs(i,k-1))+(1.-epssm)*(ph(i,k,j)&
&-ph(i,k-1,j))))+dts*g*msft_inv(i)*rdn(k)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*muave(i,j))
      a_ph(i,k-1,j) = a_ph(i,k-1,j)+0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*c2a(i,k-1,j)*rdnw(k-1)*(1.-epssm)
      a_ph(i,k+1,j) = a_ph(i,k+1,j)+0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*c2a(i,k,j)*rdnw(k)*(1.-epssm)
      a_ph(i,k,j) = a_ph(i,k,j)-0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*(1.-epssm)+c2a(i,&
&k-1,j)*rdnw(k-1)*(1.-epssm))
      a_rhs(i,k-1) = a_rhs(i,k-1)+0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*c2a(i,k-1,j)*rdnw(k-1)*(1.+epssm)
      a_rhs(i,k+1) = a_rhs(i,k+1)+0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*c2a(i,k,j)*rdnw(k)*(1+epssm)
      a_rhs(i,k) = a_rhs(i,k)-0.5*a_w(i,k,j)*msft_inv(i)*cqw(i,k,j)*dts*g*mut_inv(i)*rdn(k)*(c2a(i,k,j)*rdnw(k)*(1.+epssm)+c2a(i,k-&
&1,j)*rdnw(k-1)*(1+epssm))
      a_rw_tend(i,k,j) = a_rw_tend(i,k,j)+a_w(i,k,j)*dts
      a_t_2ave(i,k-1,j) = a_t_2ave(i,k-1,j)-a_w(i,k,j)*dts*g*msft_inv(i)*rdn(k)*c2a(i,k-1,j)*alt(i,k-1,j)
      a_t_2ave(i,k,j) = a_t_2ave(i,k,j)+a_w(i,k,j)*dts*g*msft_inv(i)*rdn(k)*c2a(i,k,j)*alt(i,k,j)
    end do
  end do
  do i = i_start, i_end
    a_u(i+1,3,j) = a_u(i+1,3,j)+0.5*a_w(i,1,j)*rdx*(ht(i+1,j)-ht(i,j))*cf3
    a_u(i,3,j) = a_u(i,3,j)+0.5*a_w(i,1,j)*rdx*(ht(i,j)-ht(i-1,j))*cf3
    a_u(i+1,2,j) = a_u(i+1,2,j)+0.5*a_w(i,1,j)*rdx*(ht(i+1,j)-ht(i,j))*cf2
    a_u(i,2,j) = a_u(i,2,j)+0.5*a_w(i,1,j)*rdx*(ht(i,j)-ht(i-1,j))*cf2
    a_u(i+1,1,j) = a_u(i+1,1,j)+0.5*a_w(i,1,j)*rdx*(ht(i+1,j)-ht(i,j))*cf1
    a_u(i,1,j) = a_u(i,1,j)+0.5*a_w(i,1,j)*rdx*(ht(i,j)-ht(i-1,j))*cf1
    a_v(i,3,j+1) = a_v(i,3,j+1)+0.5*a_w(i,1,j)*rdy*(ht(i,j+1)-ht(i,j))*cf3
    a_v(i,3,j) = a_v(i,3,j)+0.5*a_w(i,1,j)*rdy*(ht(i,j)-ht(i,j-1))*cf3
    a_v(i,2,j+1) = a_v(i,2,j+1)+0.5*a_w(i,1,j)*rdy*(ht(i,j+1)-ht(i,j))*cf2
    a_v(i,2,j) = a_v(i,2,j)+0.5*a_w(i,1,j)*rdy*(ht(i,j)-ht(i,j-1))*cf2
    a_v(i,1,j+1) = a_v(i,1,j+1)+0.5*a_w(i,1,j)*rdy*(ht(i,j+1)-ht(i,j))*cf1
    a_v(i,1,j) = a_v(i,1,j)+0.5*a_w(i,1,j)*rdy*(ht(i,j)-ht(i,j-1))*cf1
    a_w(i,1,j) = 0.
  end do
  w(:,:,:) = wh(:,:,:)
! recdepend vars : dts,epssm,g,i_end,i_start,j,k_end,ph_tend,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1335
! recompute vars : rhs
  do k = 2, k_end+1
    do i = i_start, i_end
      rhs(i,k) = dts*(ph_tend(i,k,j)+0.5*g*(1.-epssm)*w(i,k,j))
    end do
  end do
! recompute vars : rhs
! recdepend vars : dts,fnm,fnp,i_end,i_start,k_end,rhs,wdwn
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1343
! recompute vars : rhs
  do k = 2, k_end
    do i = i_start, i_end
      rhs(i,k) = rhs(i,k)-dts*(fnm(k)*wdwn(i,k+1)+fnp(k)*wdwn(i,k))
    end do
  end do
! recompute vars : rhs
  do k = 2, k_end+1
    do i = i_start, i_end
      a_mut_inv(i) = a_mut_inv(i)+a_rhs(i,k)*msft(i,j)*rhs(i,k)
      a_ph(i,k,j) = a_ph(i,k,j)+a_rhs(i,k)
      a_rhs(i,k) = a_rhs(i,k)*msft(i,j)*mut_inv(i)
    end do
  end do
  do k = 2, k_end
    do i = i_start, i_end
      a_wdwn(i,k+1) = a_wdwn(i,k+1)-a_rhs(i,k)*dts*fnm(k)
      a_wdwn(i,k) = a_wdwn(i,k)-a_rhs(i,k)*dts*fnp(k)
    end do
  end do
  do k = 2, k_end+1
    do i = i_start, i_end
      a_ph_tend(i,k,j) = a_ph_tend(i,k,j)+a_rhs(i,k)*dts
      a_w(i,k,j) = a_w(i,k,j)+0.5*a_rhs(i,k)*dts*g*(1.-epssm)
      a_rhs(i,k) = 0.
      a_ph_1(i,k-1,j) = a_ph_1(i,k-1,j)-0.5*a_wdwn(i,k)*(ww(i,k,j)+ww(i,k-1,j))*rdnw(k-1)
      a_ph_1(i,k,j) = a_ph_1(i,k,j)+0.5*a_wdwn(i,k)*(ww(i,k,j)+ww(i,k-1,j))*rdnw(k-1)
      a_ww(i,k-1,j) = a_ww(i,k-1,j)+0.5*a_wdwn(i,k)*rdnw(k-1)*(ph_1(i,k,j)-ph_1(i,k-1,j)+phb(i,k,j)-phb(i,k-1,j))
      a_ww(i,k,j) = a_ww(i,k,j)+0.5*a_wdwn(i,k)*rdnw(k-1)*(ph_1(i,k,j)-ph_1(i,k-1,j)+phb(i,k,j)-phb(i,k-1,j))
      a_wdwn(i,k) = 0.
    end do
  end do
  t_2ave(:,:,:) = t_2aveh(:,:,:)
  do k = 1, k_end
    do i = i_start, i_end
      t_2ave(i,k,j) = 0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2ave(i,k,j))
! recompute : t_2ave
      a_mu1(i,j) = a_mu1(i,j)-a_t_2ave(i,k,j)*(t_1(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j))))
      a_muts(i,j) = a_muts(i,j)-a_t_2ave(i,k,j)*((t_2ave(i,k,j)-mu1(i,j)*t_1(i,k,j))*(t0+t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j))*&
&muts(i,j)*(t0+t_1(i,k,j))))
      a_t_1(i,k,j) = a_t_1(i,k,j)-a_t_2ave(i,k,j)*(mu1(i,j)/(muts(i,j)*(t0+t_1(i,k,j)))+(t_2ave(i,k,j)-mu1(i,j)*t_1(i,k,j))*muts(i,&
&j)/(muts(i,j)*(t0+t_1(i,k,j))*muts(i,j)*(t0+t_1(i,k,j))))
      a_t_2ave(i,k,j) = a_t_2ave(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j)))
      a_t_2(i,k,j) = a_t_2(i,k,j)+0.5*a_t_2ave(i,k,j)*(1+epssm)
      a_t_2ave(i,k,j) = 0.5*a_t_2ave(i,k,j)*(1.-epssm)
    end do
  end do
  do i = i_start, i_end
    a_mut(i,j) = a_mut(i,j)-a_mut_inv(i)/(mut(i,j)*mut(i,j))
    a_mut_inv(i) = 0.
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

   call trace_exit("a_advance_w")

end subroutine a_advance_w


subroutine a_calc_coef_w( a, a_a, alpha, a_alpha, gamma, a_gamma, mut, a_mut, cqw, a_cqw, rdn, rdnw, c2a, a_c2a, dts, g, epssm, &
&ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alpha(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqw(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_gamma(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: alpha(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cqw(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: g
real, intent(inout) :: gamma(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)

!==============================================
! declare local variables
!==============================================
real a_b
real a_c
real a_cof(ims:ime)
real b
real c
real cof(ims:ime)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k1

   call trace_entry("a_calc_coef_w")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_b = 0.
a_c = 0.
a_cof(:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
do j = j_start, j_end
  a_b = 0.
  a_c = 0.
  do i = i_start, i_end
    cof(i) = (0.5*dts*g*(1.+epssm)/mut(i,j))**2
    a(i,2,j) = 0.
    a(i,kde,j) = -(2.*cof(i)*rdnw(kde-1)**2*c2a(i,kde-1,j))
    gamma(i,1,j) = 0.
  end do
! recompute : cof,gamma
  do k = 3, kde-1
    do i = i_start, i_end
      a(i,k,j) = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j))
    end do
  end do
! recompute : a
  do k = 2, kde-1
    do i = i_start, i_end
      b = 1.+cqw(i,k,j)*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      c = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j))
      alpha(i,k,j) = 1./(b-a(i,k,j)*gamma(i,k-1,j))
      gamma(i,k,j) = c*alpha(i,k,j)
    end do
  end do
! recompute : gamma
  do i = i_start, i_end
    a_b = 0.
    a_c = 0.
    b = 1.+2.*cof(i)*rdnw(kde-1)**2*c2a(i,kde-1,j)
! recompute : b
    c = 0.
! recompute : c
    alpha(i,kde,j) = 1./(b-a(i,kde,j)*gamma(i,kde-1,j))
! recompute : alpha
    a_alpha(i,kde,j) = a_alpha(i,kde,j)+a_gamma(i,kde,j)*c
    a_c = a_c+a_gamma(i,kde,j)*alpha(i,kde,j)
    a_gamma(i,kde,j) = 0.
    a_a(i,kde,j) = a_a(i,kde,j)+a_alpha(i,kde,j)*(1.*gamma(i,kde-1,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,kde-1,&
&j))))
    a_b = a_b-a_alpha(i,kde,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,kde-1,j)))
    a_gamma(i,kde-1,j) = a_gamma(i,kde-1,j)+a_alpha(i,kde,j)*(1.*a(i,kde,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,&
&kde-1,j))))
    a_alpha(i,kde,j) = 0.
    a_c = 0.
    a_c2a(i,kde-1,j) = a_c2a(i,kde-1,j)+2*a_b*cof(i)*rdnw(kde-1)**2
    a_cof(i) = a_cof(i)+2*a_b*rdnw(kde-1)**2*c2a(i,kde-1,j)
    a_b = 0.
  end do
  do k = kde-1, 2, -1
! recdepend vars : i_end,i_start,j
! recompute pos : DOLOOP_STMT module_small_step_em.f90:658
! recompute vars : gamma
    do i = i_start, i_end
      gamma(i,1,j) = 0.
    end do
! recompute vars : gamma
    do k1 = 2, k-1
      do i = i_start, i_end
        b = 1.+cqw(i,k1,j)*cof(i)*rdn(k1)*(rdnw(k1)*c2a(i,k1,j)+rdnw(k1-1)*c2a(i,k1-1,j))
        c = -(cqw(i,k1,j)*cof(i)*rdn(k1)*rdnw(k1)*c2a(i,k1,j))
        alpha(i,k1,j) = 1./(b-a(i,k1,j)*gamma(i,k1-1,j))
        gamma(i,k1,j) = c*alpha(i,k1,j)
      end do
    end do
    do i = i_start, i_end
      a_b = 0.
      a_c = 0.
      b = 1.+cqw(i,k,j)*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
! recompute : b
      c = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j))
! recompute : c
      alpha(i,k,j) = 1./(b-a(i,k,j)*gamma(i,k-1,j))
! recompute : alpha
      a_alpha(i,k,j) = a_alpha(i,k,j)+a_gamma(i,k,j)*c
      a_c = a_c+a_gamma(i,k,j)*alpha(i,k,j)
      a_gamma(i,k,j) = 0.
      a_a(i,k,j) = a_a(i,k,j)+a_alpha(i,k,j)*(1.*gamma(i,k-1,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j))))
      a_b = a_b-a_alpha(i,k,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j)))
      a_gamma(i,k-1,j) = a_gamma(i,k-1,j)+a_alpha(i,k,j)*(1.*a(i,k,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j))))
      a_alpha(i,k,j) = 0.
      a_c2a(i,k,j) = a_c2a(i,k,j)-a_c*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)
      a_cof(i) = a_cof(i)-a_c*cqw(i,k,j)*rdn(k)*rdnw(k)*c2a(i,k,j)
      a_cqw(i,k,j) = a_cqw(i,k,j)-a_c*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j)
      a_c = 0.
      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)+a_b*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)
      a_c2a(i,k,j) = a_c2a(i,k,j)+a_b*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)
      a_cof(i) = a_cof(i)+a_b*cqw(i,k,j)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      a_cqw(i,k,j) = a_cqw(i,k,j)+a_b*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      a_b = 0.
    end do
  end do
  do k = 3, kde-1
    do i = i_start, i_end
      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)-a_a(i,k,j)*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)
      a_cof(i) = a_cof(i)-a_a(i,k,j)*cqw(i,k,j)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j)
      a_cqw(i,k,j) = a_cqw(i,k,j)-a_a(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j)
      a_a(i,k,j) = 0.
    end do
  end do
  do i = i_start, i_end
    cof(i) = (0.5*dts*g*(1.+epssm)/mut(i,j))**2
! recompute : cof
    a_gamma(i,1,j) = 0.
    a_c2a(i,kde-1,j) = a_c2a(i,kde-1,j)-2*a_a(i,kde,j)*cof(i)*rdnw(kde-1)**2
    a_cof(i) = a_cof(i)-2*a_a(i,kde,j)*rdnw(kde-1)**2*c2a(i,kde-1,j)
    a_a(i,kde,j) = 0.
    a_a(i,2,j) = 0.
    a_mut(i,j) = a_mut(i,j)-2*a_cof(i)*0.5*dts*g*(1.+epssm)/(mut(i,j)*mut(i,j))*(0.5*dts*g*(1.+epssm)/mut(i,j))
    a_cof(i) = 0.
  end do
end do

   call trace_exit("a_calc_coef_w")

end subroutine a_calc_coef_w


subroutine a_calc_p_rho( al, a_al, p, a_p, ph, a_ph, alt, a_alt, t_2, a_t_2, t_1, a_t_1, c2a, a_c2a, a_pm1, mu, a_mu, muts, a_muts,&
& znu, t0, rdnw, dnw, smdiv, non_hydrostatic, step, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_al(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_pm1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(out) :: al(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dnw(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
logical, intent(in) :: non_hydrostatic
real, intent(out) :: p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: smdiv
integer, intent(in) :: step
real, intent(in) :: t0
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: znu(kms:kme)

!==============================================
! declare local variables
!==============================================
real a_ptmp
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
integer k_start

   call trace_entry("a_calc_p_rho")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_ptmp = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = min(kte,kde-1)
! recompute : k_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (step .eq. 0) then
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        a_p(i,k,j) = a_p(i,k,j)+a_pm1(i,k,j)
        a_pm1(i,k,j) = 0.
      end do
    end do
  end do
else
  do j = j_start, j_end
    a_ptmp = 0.
    do k = k_start, k_end
      a_ptmp = 0.
      do i = i_start, i_end
        a_ptmp = 0.
        a_ptmp = a_ptmp+a_pm1(i,k,j)
        a_pm1(i,k,j) = 0.
        a_pm1(i,k,j) = a_pm1(i,k,j)-a_p(i,k,j)*smdiv
        a_p(i,k,j) = a_p(i,k,j)*(1+smdiv)
        a_p(i,k,j) = a_p(i,k,j)+a_ptmp
        a_ptmp = 0.
      end do
    end do
  end do
endif
if (non_hydrostatic) then
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        al(i,k,j) = -(1./muts(i,j)*(alt(i,k,j)*mu(i,j)+rdnw(k)*(ph(i,k+1,j)-ph(i,k,j))))
! recompute : al
        a_al(i,k,j) = a_al(i,k,j)-a_p(i,k,j)*c2a(i,k,j)
        a_alt(i,k,j) = a_alt(i,k,j)+a_p(i,k,j)*c2a(i,k,j)*((t_2(i,k,j)-mu(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j))))
        a_c2a(i,k,j) = a_c2a(i,k,j)+a_p(i,k,j)*(alt(i,k,j)*(t_2(i,k,j)-mu(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)))-al(i,k,j))
        a_mu(i,j) = a_mu(i,j)-a_p(i,k,j)*c2a(i,k,j)*(alt(i,k,j)*t_1(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j))))
        a_muts(i,j) = a_muts(i,j)-a_p(i,k,j)*c2a(i,k,j)*(alt(i,k,j)*(t_2(i,k,j)-mu(i,j)*t_1(i,k,j))*(t0+t_1(i,k,j))/(muts(i,j)*(t0+&
&t_1(i,k,j))*muts(i,j)*(t0+t_1(i,k,j))))
        a_t_1(i,k,j) = a_t_1(i,k,j)-a_p(i,k,j)*c2a(i,k,j)*(alt(i,k,j)*mu(i,j)/(muts(i,j)*(t0+t_1(i,k,j)))+alt(i,k,j)*(t_2(i,k,j)-&
&mu(i,j)*t_1(i,k,j))*muts(i,j)/(muts(i,j)*(t0+t_1(i,k,j))*muts(i,j)*(t0+t_1(i,k,j))))
        a_t_2(i,k,j) = a_t_2(i,k,j)+a_p(i,k,j)*c2a(i,k,j)*(alt(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j))))
        a_p(i,k,j) = 0.
        a_alt(i,k,j) = a_alt(i,k,j)-a_al(i,k,j)*1./muts(i,j)*mu(i,j)
        a_mu(i,j) = a_mu(i,j)-a_al(i,k,j)*1./muts(i,j)*alt(i,k,j)
        a_muts(i,j) = a_muts(i,j)+a_al(i,k,j)/(muts(i,j)*muts(i,j))*(alt(i,k,j)*mu(i,j)+rdnw(k)*(ph(i,k+1,j)-ph(i,k,j)))
        a_ph(i,k+1,j) = a_ph(i,k+1,j)-a_al(i,k,j)*1./muts(i,j)*rdnw(k)
        a_ph(i,k,j) = a_ph(i,k,j)+a_al(i,k,j)*1./muts(i,j)*rdnw(k)
        a_al(i,k,j) = 0.
      end do
    end do
  end do
else
  do j = j_start, j_end
    do k = k_end, k_start, -1
      do i = i_start, i_end
        p(i,k,j) = mu(i,j)*znu(k)
! recompute : p
        al(i,k,j) = alt(i,k,j)*(t_2(i,k,j)-mu(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)))-p(i,k,j)/c2a(i,k,j)
! recompute : al
        a_al(i,k,j) = a_al(i,k,j)-a_ph(i,k+1,j)*dnw(k)*muts(i,j)
        a_alt(i,k,j) = a_alt(i,k,j)-a_ph(i,k+1,j)*dnw(k)*mu(i,j)
        a_mu(i,j) = a_mu(i,j)-a_ph(i,k+1,j)*dnw(k)*alt(i,k,j)
        a_muts(i,j) = a_muts(i,j)-a_ph(i,k+1,j)*dnw(k)*al(i,k,j)
        a_ph(i,k,j) = a_ph(i,k,j)+a_ph(i,k+1,j)
        a_ph(i,k+1,j) = 0.
        a_alt(i,k,j) = a_alt(i,k,j)+a_al(i,k,j)*((t_2(i,k,j)-mu(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j))))
        a_c2a(i,k,j) = a_c2a(i,k,j)+a_al(i,k,j)*(p(i,k,j)/(c2a(i,k,j)*c2a(i,k,j)))
        a_mu(i,j) = a_mu(i,j)-a_al(i,k,j)*(alt(i,k,j)*t_1(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j))))
        a_muts(i,j) = a_muts(i,j)-a_al(i,k,j)*(alt(i,k,j)*(t_2(i,k,j)-mu(i,j)*t_1(i,k,j))*(t0+t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)&
&)*muts(i,j)*(t0+t_1(i,k,j))))
        a_p(i,k,j) = a_p(i,k,j)-a_al(i,k,j)/c2a(i,k,j)
        a_t_1(i,k,j) = a_t_1(i,k,j)-a_al(i,k,j)*(alt(i,k,j)*mu(i,j)/(muts(i,j)*(t0+t_1(i,k,j)))+alt(i,k,j)*(t_2(i,k,j)-mu(i,j)*&
&t_1(i,k,j))*muts(i,j)/(muts(i,j)*(t0+t_1(i,k,j))*muts(i,j)*(t0+t_1(i,k,j))))
        a_t_2(i,k,j) = a_t_2(i,k,j)+a_al(i,k,j)*(alt(i,k,j)/(muts(i,j)*(t0+t_1(i,k,j))))
        a_al(i,k,j) = 0.
        a_mu(i,j) = a_mu(i,j)+a_p(i,k,j)*znu(k)
        a_p(i,k,j) = 0.
      end do
    end do
  end do
endif

   call trace_exit("a_calc_p_rho")

end subroutine a_calc_p_rho

subroutine a_small_step_finish( u_2, a_u_2, v_2, a_v_2, w_2, a_w_2, t_2, a_t_2, a_ph_2, a_mu_2, mut, a_mut, muts, a_muts, muu, &
&a_muu, muus, a_muus, muv, a_muv, muvs, a_muvs, u_save, a_u_save, v_save, a_v_save, w_save, a_w_save, t_save, a_t_save, a_ph_save, &
&a_mu_save, msfu, msfv, msft, number_of_small_timesteps, dts, ide, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte )

!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_mu_2(ims:ime,jms:jme)
real, intent(inout) :: a_mu_save(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muus(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_muvs(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ph_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_save(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(inout) :: mut(ims:ime,jms:jme)
real, intent(inout) :: muts(ims:ime,jms:jme)
real, intent(inout) :: muu(ims:ime,jms:jme)
real, intent(inout) :: muus(ims:ime,jms:jme)
real, intent(inout) :: muv(ims:ime,jms:jme)
real, intent(inout) :: muvs(ims:ime,jms:jme)
real, intent(inout) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: w_save(ims:ime,kms:kme,jms:jme)


  REAL,   DIMENSION(ims:ime, kms:kme, jms:jme)  ::ww1,a_ww1,a_ww
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: h_diabatic
  INTEGER                   :: number_of_small_timesteps
  REAL                      :: dts



!==============================================
! declare local variables
!==============================================
integer i
integer i_end
integer i_endu
integer i_start
integer j
integer j_end
integer j_endv
integer j_start
integer k

   call trace_entry("a_small_step_finish")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
i_endu = i_end
! recompute : i_endu
j_endv = j_end
! recompute : j_endv
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
do j = j_start, j_end
  do i = i_start, i_end
    a_mu_save(i,j) = a_mu_save(i,j)+a_mu_2(i,j)
  end do
end do
do j = j_start, j_end
  do k = kds, kde-1
    do i = i_start, i_end

      a_mut(i,j) = a_mut(i,j)+a_t_2(i,k,j)*(- dts*number_of_small_timesteps*h_diabatic(i,k,j) +t_save(i,k,j)/muts(i,j))
      a_muts(i,j) = a_muts(i,j)-a_t_2(i,k,j)*((t_2(i,k,j)- dts*number_of_small_timesteps*mut(i,j)*h_diabatic(i,k,j) &
                    +t_save(i,k,j)*mut(i,j))/(muts(i,j)*muts(i,j)))
      a_t_save(i,k,j) = a_t_save(i,k,j)+a_t_2(i,k,j)*(mut(i,j)/muts(i,j))
      a_t_2(i,k,j) = a_t_2(i,k,j)/muts(i,j)

    end do
  end do
end do
do j = j_start, j_end
  do k = kds, kde
    do i = i_start, i_end
!------------------------- added in May 9 -----------------
      a_ww1(i,k,j) =a_ww1(i,k,j) +a_ww(i,k,j)
!------------------------- added in May 9 -----------------

      a_ph_save(i,k,j) = a_ph_save(i,k,j)+a_ph_2(i,k,j)
      a_mut(i,j) = a_mut(i,j)+a_w_2(i,k,j)*(w_save(i,k,j)/muts(i,j))
      a_muts(i,j) = a_muts(i,j)-a_w_2(i,k,j)*((msft(i,j)*w_2(i,k,j)+w_save(i,k,j)*mut(i,j))/(muts(i,j)*muts(i,j)))
      a_w_save(i,k,j) = a_w_save(i,k,j)+a_w_2(i,k,j)*(mut(i,j)/muts(i,j))
      a_w_2(i,k,j) = a_w_2(i,k,j)*(msft(i,j)/muts(i,j))
    end do
  end do
end do
do j = j_start, j_end
  do k = kds, kde-1
    do i = i_start, i_endu
      a_muu(i,j) = a_muu(i,j)+a_u_2(i,k,j)*(u_save(i,k,j)/muus(i,j))
      a_muus(i,j) = a_muus(i,j)-a_u_2(i,k,j)*((msfu(i,j)*u_2(i,k,j)+u_save(i,k,j)*muu(i,j))/(muus(i,j)*muus(i,j)))
      a_u_save(i,k,j) = a_u_save(i,k,j)+a_u_2(i,k,j)*(muu(i,j)/muus(i,j))
      a_u_2(i,k,j) = a_u_2(i,k,j)*(msfu(i,j)/muus(i,j))
    end do
  end do
end do
do j = j_start, j_endv
  do k = kds, kde-1
    do i = i_start, i_end
      a_muv(i,j) = a_muv(i,j)+a_v_2(i,k,j)*(v_save(i,k,j)/muvs(i,j))
      a_muvs(i,j) = a_muvs(i,j)-a_v_2(i,k,j)*((msfv(i,j)*v_2(i,k,j)+v_save(i,k,j)*muv(i,j))/(muvs(i,j)*muvs(i,j)))
      a_v_save(i,k,j) = a_v_save(i,k,j)+a_v_2(i,k,j)*(muv(i,j)/muvs(i,j))
      a_v_2(i,k,j) = a_v_2(i,k,j)*(msfv(i,j)/muvs(i,j))
    end do
  end do
end do

   call trace_exit("a_small_step_finish")

end subroutine a_small_step_finish


subroutine a_small_step_prep( u_1, a_u_1, u_2, a_u_2, v_1, a_v_1, v_2, a_v_2, w_1, a_w_1, w_2, a_w_2, t_1, a_t_1, t_2, a_t_2, &
&a_ph_1, a_ph_2, mub, mu_1, a_mu_1, mu_2, a_mu_2, muu, a_muu, muus, a_muus, muv, a_muv, muvs, a_muvs, mut, a_mut, muts, a_muts, &
&a_mudf, a_u_save, a_v_save, a_w_save, a_t_save, a_ph_save, a_mu_save, a_ww, a_ww_save, a_c2a, pb, p, a_p, alt, a_alt, msfu, msfv, &
&msft, rk_step, leapfrog, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu_1(ims:ime,jms:jme)
real, intent(inout) :: a_mu_2(ims:ime,jms:jme)
real, intent(inout) :: a_mu_save(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muus(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_muvs(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_save(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
logical, intent(in) :: leapfrog
real, intent(inout) :: msft(ims:ime,jms:jme)
real, intent(inout) :: msfu(ims:ime,jms:jme)
real, intent(inout) :: msfv(ims:ime,jms:jme)
real, intent(inout) :: mu_1(ims:ime,jms:jme)
real, intent(inout) :: mu_2(ims:ime,jms:jme)
real, intent(inout) :: mub(ims:ime,jms:jme)
real, intent(inout) :: mut(ims:ime,jms:jme)
real, intent(out) :: muts(ims:ime,jms:jme)
real, intent(inout) :: muu(ims:ime,jms:jme)
real, intent(out) :: muus(ims:ime,jms:jme)
real, intent(inout) :: muv(ims:ime,jms:jme)
real, intent(out) :: muvs(ims:ime,jms:jme)
real, intent(in) :: p(ims:ime,kms:kme,jms:jme)
real, intent(in) :: pb(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: rk_step
real, intent(inout) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_2(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
integer i
integer i_end
integer i_endu
integer i_start
integer j
integer j_end
integer j_endv
integer j_start
integer k
integer k_end
integer k_start

   call trace_entry("a_small_step_prep")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = min(kte,kde-1)
! recompute : k_end
i_endu = i_end
! recompute : i_endu
j_endv = j_end
! recompute : j_endv
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif

! recompute : j_end
if (rk_step .eq. 1 .and. ( .not. leapfrog)) then

!--------- added by zzma -----------
      DO j=j_start, j_end
      DO i=i_start, i_end
        mu_1(i,j)=mu_2(i,j)
      ENDDO
      ENDDO
!--------- added by zzma -----------

  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_endu
        u_1(i,k,j) = u_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_endv
    do k = k_start, k_end
      do i = i_start, i_end
        v_1(i,k,j) = v_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        t_1(i,k,j) = t_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, min(kde,kte)
      do i = i_start, i_end
        w_1(i,k,j) = w_2(i,k,j)

!--------- added by zzma -----------
!        ph_1(i,k,j) = ph_2(i,k,j)
!--------- added by zzma -----------

      end do
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_end
      muts(i,j) = mub(i,j)+mu_2(i,j)
    end do
    do i = i_start, i_endu
      muus(i,j) = muu(i,j)
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      muvs(i,j) = muv(i,j)
    end do
  end do
else
  do j = j_start, j_end
    do i = i_start, i_end
      muts(i,j) = mub(i,j)+mu_1(i,j)
    end do
    do i = i_start, i_endu
      muus(i,j) = 0.5*(mub(i,j)+mu_1(i,j)+mub(i-1,j)+mu_1(i-1,j))
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      muvs(i,j) = 0.5*(mub(i,j)+mu_1(i,j)+mub(i,j-1)+mu_1(i,j-1))
    end do
  end do

!--------- added by zzma -----------
    DO j=j_start, j_end
      DO i=i_start, i_end
        mu_2(i,j)=mu_1(i,j)-mu_2(i,j)
      ENDDO
    ENDDO
!--------- added by zzma -----------

endif
! recompute : muts,muus,muvs,t_1,u_1,v_1,w_1
do j = j_start, j_end
  do k = k_start, kde
    do i = i_start, i_end
      a_ww(i,k,j) = a_ww(i,k,j)+a_ww_save(i,k,j)
      a_ww_save(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do k = k_start, kde
    do i = i_start, i_end
      a_ph_1(i,k,j) = a_ph_1(i,k,j)+a_ph_2(i,k,j)
      a_ph_2(i,k,j) = -a_ph_2(i,k,j)
      a_ph_2(i,k,j) = a_ph_2(i,k,j)+a_ph_save(i,k,j)
      a_ph_save(i,k,j) = 0.
      a_mut(i,j) = a_mut(i,j)-a_w_2(i,k,j)*(w_2(i,k,j)/msft(i,j))
      a_muts(i,j) = a_muts(i,j)+a_w_2(i,k,j)*(w_1(i,k,j)/msft(i,j))
      a_w_1(i,k,j) = a_w_1(i,k,j)+a_w_2(i,k,j)*(muts(i,j)/msft(i,j))
      a_w_2(i,k,j) = -(a_w_2(i,k,j)*(mut(i,j)/msft(i,j)))
      a_w_2(i,k,j) = a_w_2(i,k,j)+a_w_save(i,k,j)
      a_w_save(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_end
      a_mut(i,j) = a_mut(i,j)-a_t_2(i,k,j)*t_2(i,k,j)
      a_muts(i,j) = a_muts(i,j)+a_t_2(i,k,j)*t_1(i,k,j)
      a_t_1(i,k,j) = a_t_1(i,k,j)+a_t_2(i,k,j)*muts(i,j)
      a_t_2(i,k,j) = -(a_t_2(i,k,j)*mut(i,j))
      a_t_2(i,k,j) = a_t_2(i,k,j)+a_t_save(i,k,j)
      a_t_save(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_endv
  do k = k_start, k_end
    do i = i_start, i_end
      a_muv(i,j) = a_muv(i,j)-a_v_2(i,k,j)*(v_2(i,k,j)/msfv(i,j))
      a_muvs(i,j) = a_muvs(i,j)+a_v_2(i,k,j)*(v_1(i,k,j)/msfv(i,j))
      a_v_1(i,k,j) = a_v_1(i,k,j)+a_v_2(i,k,j)*(muvs(i,j)/msfv(i,j))
      a_v_2(i,k,j) = -(a_v_2(i,k,j)*(muv(i,j)/msfv(i,j)))
      a_v_2(i,k,j) = a_v_2(i,k,j)+a_v_save(i,k,j)
      a_v_save(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_endu
      a_muu(i,j) = a_muu(i,j)-a_u_2(i,k,j)*(u_2(i,k,j)/msfu(i,j))
      a_muus(i,j) = a_muus(i,j)+a_u_2(i,k,j)*(u_1(i,k,j)/msfu(i,j))
      a_u_1(i,k,j) = a_u_1(i,k,j)+a_u_2(i,k,j)*(muus(i,j)/msfu(i,j))
      a_u_2(i,k,j) = -(a_u_2(i,k,j)*(muu(i,j)/msfu(i,j)))
      a_u_2(i,k,j) = a_u_2(i,k,j)+a_u_save(i,k,j)
      a_u_save(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_end
      a_alt(i,k,j) = a_alt(i,k,j)-a_c2a(i,k,j)*(cpovcv*(pb(i,k,j)+p(i,k,j))/(alt(i,k,j)*alt(i,k,j)))
      a_p(i,k,j) = a_p(i,k,j)+a_c2a(i,k,j)*(cpovcv/alt(i,k,j))
      a_c2a(i,k,j) = 0.
    end do
  end do
end do
do j = j_start, j_end
  do i = i_start, i_end
    a_ww_save(i,1,j) = 0.
    a_ww_save(i,kde,j) = 0.
  end do
end do
if (rk_step .eq. 1 .and. ( .not. leapfrog)) then
  do j = j_start, j_end
    do i = i_start, i_end
      a_mu_2(i,j) = 0.
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_save(i,j)
      a_mu_save(i,j) = 0.
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      a_muv(i,j) = a_muv(i,j)+a_muvs(i,j)
      a_muvs(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_endu
      a_muu(i,j) = a_muu(i,j)+a_muus(i,j)
      a_muus(i,j) = 0.
    end do
    do i = i_start, i_end
      a_mu_2(i,j) = a_mu_2(i,j)+a_muts(i,j)
      a_muts(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do k = k_start, min(kde,kte)
      do i = i_start, i_end
        a_ph_2(i,k,j) = a_ph_2(i,k,j)+a_ph_1(i,k,j)
        a_ph_1(i,k,j) = 0.
        a_w_2(i,k,j) = a_w_2(i,k,j)+a_w_1(i,k,j)
        a_w_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        a_t_2(i,k,j) = a_t_2(i,k,j)+a_t_1(i,k,j)
        a_t_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_endv
    do k = k_start, k_end
      do i = i_start, i_end
        a_v_2(i,k,j) = a_v_2(i,k,j)+a_v_1(i,k,j)
        a_v_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_endu
        a_u_2(i,k,j) = a_u_2(i,k,j)+a_u_1(i,k,j)
        a_u_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_end
      a_mudf(i,j) = 0.
      a_ww_save(i,1,j) = 0.
      a_ww_save(i,kde,j) = 0.
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_1(i,j)
      a_mu_1(i,j) = 0.
    end do
  end do
else
!---------- zzma -----------
  do j = j_start, j_end
    do i = i_start, i_end
!      a_mu_1(i,j) = 0.0
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
!      a_mu_1(i,j) = 0.0
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_endu
!      a_mu_1(i,j) = 0.0
    end do
  end do

!   a_mu_1=0
!   a_u_1=0
!   a_v_1=0
!   a_w_1=0
!   a_t_1=0
!  a_ph_1=0
!  a_muts =0
!  a_muvs=0
!  a_muus=0
!  a_mu_save=0

!---------- zzma -----------
  do j = j_start, j_end
    do i = i_start, i_end
      a_mu_1(i,j) = a_mu_1(i,j)+a_mu_2(i,j)
      a_mu_2(i,j) = -a_mu_2(i,j)
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_save(i,j)
      a_mu_save(i,j) = 0.
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      a_mu_1(i,j-1) = a_mu_1(i,j-1)+0.5*a_muvs(i,j)
      a_mu_1(i,j) = a_mu_1(i,j)+0.5*a_muvs(i,j)
      a_muvs(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_endu
      a_mu_1(i-1,j) = a_mu_1(i-1,j)+0.5*a_muus(i,j)
      a_mu_1(i,j) = a_mu_1(i,j)+0.5*a_muus(i,j)
      a_muus(i,j) = 0.
    end do
    do i = i_start, i_end
      a_mu_1(i,j) = a_mu_1(i,j)+a_muts(i,j)
      a_muts(i,j) = 0.
    end do
  end do
endif

   call trace_exit("a_small_step_prep")

end subroutine a_small_step_prep


subroutine a_sumflux( a_ru, a_rv, a_ww, u_lin, a_u_lin, v_lin, a_v_lin, a_ww_lin, muu, a_muu, muv, a_muv, a_ru_m, a_rv_m, a_ww_m, &
&msfu, msfv, iteration, number_of_small_timesteps, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ru(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_m(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_m(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_m(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: iteration
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
integer, intent(in) :: number_of_small_timesteps
real, intent(in) :: u_lin(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_lin(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
integer i
integer j
integer k

   call trace_entry("a_sumflux")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (iteration .eq. number_of_small_timesteps) then
  do j = jts, min(jde-1,jte)
    do k = kts, kte
      do i = its, min(ide-1,ite)
        a_ww_lin(i,k,j) = a_ww_lin(i,k,j)+a_ww_m(i,k,j)
        a_ww_m(i,k,j) = a_ww_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
  do j = jts, jte
    do k = kts, min(kde-1,kte)
      do i = its, min(ide-1,ite)
        a_muv(i,j) = a_muv(i,j)+a_rv_m(i,k,j)*(v_lin(i,k,j)/msfv(i,j))
        a_v_lin(i,k,j) = a_v_lin(i,k,j)+a_rv_m(i,k,j)*(muv(i,j)/msfv(i,j))
        a_rv_m(i,k,j) = a_rv_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
  do j = jts, min(jde-1,jte)
    do k = kts, min(kde-1,kte)
      do i = its, ite
        a_muu(i,j) = a_muu(i,j)+a_ru_m(i,k,j)*(u_lin(i,k,j)/msfu(i,j))
        a_u_lin(i,k,j) = a_u_lin(i,k,j)+a_ru_m(i,k,j)*(muu(i,j)/msfu(i,j))
        a_ru_m(i,k,j) = a_ru_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
endif
do j = jts, min(jde-1,jte)
  do k = kts, kte
    do i = its, min(ide-1,ite)
      a_ww(i,k,j) = a_ww(i,k,j)+a_ww_m(i,k,j)
    end do
  end do
end do
do j = jts, jte
  do k = kts, min(kde-1,kte)
    do i = its, min(ide-1,ite)
      a_rv(i,k,j) = a_rv(i,k,j)+a_rv_m(i,k,j)
    end do
  end do
end do
do j = jts, min(jde-1,jte)
  do k = kts, min(kde-1,kte)
    do i = its, ite
      a_ru(i,k,j) = a_ru(i,k,j)+a_ru_m(i,k,j)
    end do
  end do
end do
if (iteration .eq. 1) then
  do j = jts, jte
    do k = kts, kte
      do i = its, ite
        a_ww_m(i,k,j) = 0.
        a_rv_m(i,k,j) = 0.
        a_ru_m(i,k,j) = 0.
      end do
    end do
  end do
endif

   call trace_exit("a_sumflux")

end subroutine a_sumflux


end module     a_module_small_step_em


