!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     a_module_small_step_em
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_configure
use module_model_constants
use module_small_step_em

USE module_trace, only : trace_entry, trace_exit
#ifdef DM_PARALLEL
use module_dm
#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains

subroutine a_advance_mu_t( ww, a_ww, ww_1, a_ww_1, u, a_u, u_1, a_u_1, v, a_v, v_1, a_v_1, a_mu, a_mut, a_muave, a_muts, muu, &
&a_muu, muv, a_muv, a_mudf, a_t, t_1, a_t_1, a_t_ave, a_ft, mu_tend, a_mu_tend, rdx, rdy, dts, epssm, dnw, fnm, fnp, rdnw, msfu, &
&msfv, msft, config_flags, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ft(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_mu_tend(ims:ime,jms:jme)
real, intent(inout) :: a_muave(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_t(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_ave(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_1(ims:ime,kms:kme,jms:jme)
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: dnw(kms:kme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kds
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(in) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ww_1(ims:ime,kms:kme,jms:jme)
real gwalls(ims:ime),walls(3)

!==============================================
! declare local variables
!==============================================
#ifdef DM_PARALLEL
real a_dmdt(its-1:ite+1)
real a_dvdxi(its-1:ite+1,kts:kte)
real a_wdtn(its-1:ite+1,kts:kte)
real dmdt(its-1:ite+1)
real dvdxi(its-1:ite+1,kts:kte)
#else
real a_dmdt(its:ite)
real a_dvdxi(its:ite,kts:kte)
real a_wdtn(its:ite,kts:kte)
real dmdt(its:ite)
real dvdxi(its:ite,kts:kte)
#endif
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
integer k_start
#ifdef DM_PARALLEL
integer ips, ipe, jps, jpe, kps, kpe
#endif


   call trace_entry("a_advance_mu_t")

#ifdef DM_PARALLEL
ips = its
ipe = ite
jps = jts
jpe = jte
kps = kts
kpe = kte
#endif

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
!a_dvdxi(:,:) = 0.
!a_wdtn(:,:)  = 0.
a_dmdt(:)    = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = kte-1
! recompute : k_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. its .eq. ids) then
  i_start = i_start+1
else
  i_start = i_start-1
endif
! recompute : i_start
if ((config_flags%specified .or. config_flags%nested) .and. ite .eq. ide) then
  i_end = i_end-1
else
  i_end = i_end+1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. jts .eq. jds) then
  j_start = j_start+1
else
  j_start = j_start-1
endif
! recompute : j_start
if ((config_flags%specified .or. config_flags%nested) .and. jte .eq. jde) then
  j_end = j_end-1
else
  j_end = j_end+1
endif

!a_dvdxi(:,kts:1) = 0.
a_dvdxi(:,k_end:kte) = 0.

! recompute : j_end
#ifdef DM_PARALLEL
!xinzhang parallel tuning
#include "HALO_ADJ_ADVANCE_MU_T.inc" 
#endif
!!!do j = j_start, j_end
!!!! do i = i_start, i_end
!!!!   dmdt(i) = 0.
!!!! end do
!!!  dmdt(i_start:i_end) = 0.

!!!  do k = k_start, k_end
!!!!   walls(1)=dnw(k)
!!!    do i = i_start, i_end
!!!      dvdxi(i,k) = msft(i,j)*msft(i,j)*(rdy*(v(i,k,j+1)+muv(i,j+1)*v_1(i,k,j+1)/msfv(i,j+1)-(v(i,k,j)+muv(i,j)*v_1(i,k,j)/msfv(i,j)&
!!!&))+rdx*(u(i+1,k,j)+muu(i+1,j)*u_1(i+1,k,j)/msfu(i+1,j)-(u(i,k,j)+muu(i,j)*u_1(i,k,j)/msfu(i,j))))
!!!!     dmdt(i) = dmdt(i)+walls(1)*dvdxi(i,k)
!!!    end do
!!!    dmdt(i_start:i_end) = dmdt(i_start:i_end)+dnw(k)*dvdxi(i_start:i_end,k)
!!!  end do
!!!  do k = 2, k_end
!!!    walls(1)=dnw(k-1)
!!!    do i = i_start, i_end
!!!      ww(i,k,j) = ww(i,k-1,j)-walls(1)*(dmdt(i)+dvdxi(i,k-1)+mu_tend(i,j))/msft(i,j)
!!!    end do
!!!  end do
!!!! do k = 1, k_end
!!!!   do i = i_start, i_end
!!!!     ww(i,k,j) = ww(i,k,j)-ww_1(i,k,j)
!!!!   end do
!!!! end do
!!!  ww(i_start:i_end,1:k_end,j) =ww(i_start:i_end,1:k_end,j)-ww_1(i_start:i_end,1:k_end,j)
!!!end do
!!!! recompute : ww

!print*, i_start, i_end, j_start, j_end
!print*, ims,ime,jms,jme
!!real, intent(in) :: msfv(ims:ime,jms:jme)

do j = j_start, j_end
  a_wdtn(:,:)  = 0.
  do k = 1, k_end
    walls(2)=rdnw(k)
    do i = i_start, i_end
      gwalls(i)=0.5*a_t(i,k,j)*dts*msft(i,j)*msft(i,j)
    end do
    do i = i_start, i_end
      walls(3)=a_t(i,k,j)*dts*msft(i,j)*walls(2)
      a_wdtn(i,k+1)  = a_wdtn(i,k+1)-walls(3)
      a_wdtn(i,k)    = a_wdtn(i,k)+walls(3)
      a_t_1(i,k,j-1) = a_t_1(i,k,j-1)+gwalls(i)*rdy*v(i,k,j)
      a_t_1(i,k,j+1) = a_t_1(i,k,j+1)-gwalls(i)*rdy*v(i,k,j+1)
      a_t_1(i-1,k,j) = a_t_1(i-1,k,j)+gwalls(i)*rdx*u(i,k,j)
      a_t_1(i+1,k,j) = a_t_1(i+1,k,j)-gwalls(i)*rdx*u(i+1,k,j)
      a_t_1(i,k,j) = a_t_1(i,k,j)-gwalls(i)*(rdy*(v(i,k,j+1)-v(i,k,j))+rdx*(u(i+1,k,j)-u(i,k,j)))
    end do
    do i = i_start, i_end
      a_u(i+1,k,j) = a_u(i+1,k,j)-gwalls(i)*rdx*(t_1(i+1,k,j)+t_1(i,k,j))
      a_u(i,k,j) = a_u(i,k,j)+gwalls(i)*rdx*(t_1(i,k,j)+t_1(i-1,k,j))
      a_v(i,k,j+1) = a_v(i,k,j+1)-gwalls(i)*rdy*(t_1(i,k,j+1)+t_1(i,k,j))
      a_v(i,k,j) = a_v(i,k,j)+gwalls(i)*rdy*(t_1(i,k,j)+t_1(i,k,j-1))
    end do
  end do

  do k = 2, k_end
    walls(1)=fnp(k); walls(2)=fnm(k)
    gwalls(i_start:i_end)=walls(2)*t_1(i_start:i_end,k,j)+walls(1)*t_1(i_start:i_end,k-1,j)
    do i = i_start, i_end
      a_t_1(i,k-1,j) = a_t_1(i,k-1,j)+a_wdtn(i,k)*ww(i,k,j)*walls(1)
      a_t_1(i,k,j)   = a_t_1(i,k,j)  +a_wdtn(i,k)*ww(i,k,j)*walls(2)
      a_ww(i,k,j)    = a_ww(i,k,j)   +a_wdtn(i,k)*gwalls(i)
!     a_wdtn(i,k)    = 0.
    end do
!   a_wdtn(i_start:i_end,k)    = 0.
  end do

! do i = i_start, i_end
!   a_wdtn(i,kde) = 0.
!   a_wdtn(i,1)   = 0.
! end do
! a_wdtn(i_start:i_end,kde) = 0.
! a_wdtn(i_start:i_end,1)   = 0.
end do


do j = j_start, j_end
  do k = 1, k_end
    do i = i_start, i_end
      a_ft(i,k,j) = a_ft(i,k,j)+a_t(i,k,j)*msft(i,j)*dts
!     a_t_ave(i,k,j) = 0.
    end do
  end do
end do
a_t(i_start:i_end,1:k_end,j_start:j_end)=a_t(i_start:i_end,1:k_end,j_start:j_end)+a_t_ave(i_start:i_end,1:k_end,j_start:j_end)
a_t_ave(i_start:i_end,1:k_end,j_start:j_end) = 0.


!print*, 'RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR'

do j = j_start, j_end
! do k = 1, k_end
!   do i = i_start, i_end
!     a_ww_1(i,k,j) = a_ww_1(i,k,j)-a_ww(i,k,j)
!   end do
! end do
  a_ww_1(i_start:i_end,1:k_end,j) =a_ww_1(i_start:i_end,1:k_end,j)-a_ww(i_start:i_end,1:k_end,j)

  do k = k_end, 2, -1
    walls(1)=dnw(k-1)
    do i = i_start, i_end
      walls(2)=a_ww(i,k,j)*(walls(1)/msft(i,j))
      a_dmdt(i) = a_dmdt(i)-walls(2)
!     a_dvdxi(i,k-1) = a_dvdxi(i,k-1)-walls(2)
      a_dvdxi(i,k-1) = -walls(2)
      a_mu_tend(i,j) = a_mu_tend(i,j)-walls(2)
      a_ww(i,k-1,j)  = a_ww(i,k-1,j)+a_ww(i,k,j)
!     a_ww(i,k,j)    = 0.
    end do
    a_ww(i_start:i_end,k,j) = 0.
  end do

  walls(1)=0.5*(1+epssm)
  walls(2)=0.5*(1.-epssm)
  do i = i_start, i_end
    a_mu(i,j) = a_mu(i,j)+walls(1)*a_muave(i,j)
    a_muave(i,j) = walls(2)*a_muave(i,j)
    a_mu(i,j) = a_mu(i,j)+a_muts(i,j)
    a_mut(i,j) = a_mut(i,j)+a_muts(i,j)
    a_dmdt(i) = a_dmdt(i)+a_mudf(i,j)
    a_mu_tend(i,j) = a_mu_tend(i,j)+a_mudf(i,j)
    a_dmdt(i) = a_dmdt(i)+a_mu(i,j)*dts
    a_mu_tend(i,j) = a_mu_tend(i,j)+a_mu(i,j)*dts
    a_mu(i,j) = a_mu(i,j)+a_muave(i,j)
  end do

! a_mu(i_start:i_end,j) = a_mu(i_start:i_end,j)+0.5*(1+epssm)*a_muave(i_start:i_end,j)
! a_muave(i_start:i_end,j) = 0.5*(1.-epssm)*a_muave(i_start:i_end,j)
! a_mu(i_start:i_end,j) = a_mu(i_start:i_end,j)+a_muts(i_start:i_end,j)
! a_mut(i_start:i_end,j) = a_mut(i_start:i_end,j)+a_muts(i_start:i_end,j)
! a_dmdt(i_start:i_end) = a_dmdt(i_start:i_end)+a_mudf(i_start:i_end,j)
! a_mu_tend(i_start:i_end,j) = a_mu_tend(i_start:i_end,j)+a_mudf(i_start:i_end,j)
! a_dmdt(i_start:i_end) = a_dmdt(i_start:i_end)+a_mu(i_start:i_end,j)*dts
! a_mu_tend(i_start:i_end,j) = a_mu_tend(i_start:i_end,j)+a_mu(i_start:i_end,j)*dts
! a_mu(i_start:i_end,j) = a_mu(i_start:i_end,j)+a_muave(i_start:i_end,j)

  a_muts(i_start:i_end,j) = 0.
  a_muave(i_start:i_end,j)= 0.
  a_mudf(i_start:i_end,j) = 0.

  do k = k_end, k_start, -1
    walls(1)=dnw(k)
    do i = i_start, i_end
      gwalls(i)=(a_dvdxi(i,k)+a_dmdt(i)*walls(1))*msft(i,j)*msft(i,j)
    end do
    do i = i_start, i_end
      walls(1)=gwalls(i)*rdx
      walls(2)=gwalls(i)*rdy

!     print*, msfu(i+1,j),msfv(i,j+1)

!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS

      IF(msfu(i+1,j).NE.0.0) THEN   !ADDED BY WALLS
      a_muu(i+1,j) = a_muu(i+1,j)+walls(1)*(u_1(i+1,k,j)/msfu(i+1,j))
      a_u_1(i+1,k,j) = a_u_1(i+1,k,j)+walls(1)*(muu(i+1,j)/msfu(i+1,j))
      END IF   !ADDED BY WALLS

      a_muu(i,j)   = a_muu(i,j)-walls(1)*(u_1(i,k,j)/msfu(i,j))
      a_u_1(i,k,j) = a_u_1(i,k,j)-walls(1)*(muu(i,j)/msfu(i,j))

!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
      IF(msfv(i,j+1).NE.0.0) THEN   !ADDED BY WALLS
      a_muv(i,j+1) = a_muv(i,j+1)+walls(2)*(v_1(i,k,j+1)/msfv(i,j+1))
      a_v_1(i,k,j+1) = a_v_1(i,k,j+1)+walls(2)*(muv(i,j+1)/msfv(i,j+1))
      END IF   !ADDED BY WALLS

      a_u(i+1,k,j) = a_u(i+1,k,j)+walls(1)
      a_u(i,k,j)   = a_u(i,k,j)-walls(1)
      a_v(i,k,j+1) = a_v(i,k,j+1)+walls(2)
      a_v(i,k,j)   = a_v(i,k,j)-walls(2)
      a_v_1(i,k,j)   = a_v_1(i,k,j)-walls(2)*(muv(i,j)/msfv(i,j))
      a_muv(i,j)   = a_muv(i,j)-walls(2)*(v_1(i,k,j)/msfv(i,j))
    end do
!   a_dvdxi(i_start:i_end,k) = 0.
!A12
  end do
! do i = i_start, i_end
!   a_dmdt(i) = 0.
! end do
  a_dmdt(i_start:i_end) = 0.
end do

!print*, '0000000000000000000000000000000000000000000'
!print*, 'RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR'

   call trace_exit("a_advance_mu_t")

end subroutine a_advance_mu_t


subroutine a_advance_uv( a_u, a_ru_tend, a_v, a_rv_tend, p, a_p, pb, ph, a_ph, php, a_php, alt, a_alt, al, a_al, mu, a_mu, muu, &
&a_muu, cqu, a_cqu, muv, a_muv, cqv, a_cqv, a_mudf, rdx, rdy, dts, cf1, cf2, cf3, fnm, fnp, emdiv, rdnw, config_flags, spec_zone, &
&non_hydrostatic, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_al(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqu(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_php(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(in) :: al(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cf1
real, intent(in) :: cf2
real, intent(in) :: cf3
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: cqu(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cqv(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: emdiv
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
logical, intent(in) :: non_hydrostatic
real, intent(in) :: p(ims:ime,kms:kme,jms:jme)
real, intent(in) :: pb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: php(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
integer, intent(in) :: spec_zone
real walls(5)
real gwalls(ims:ime,kms:kme)
real kwalls(ims:ime,kms:kme)

!==============================================
! declare local variables
!==============================================
#ifdef DM_PARALLEL
real a_dpn(its:ite+1,kts:kte)
real a_dpxy(its:ite+1,kts:kte)
real a_mudf_xy(its:ite+1)
real dpn(its:ite+1,kts:kte)
real dpxy(its:ite+1,kts:kte)
#else
real a_dpn(its:ite,kts:kte)
real a_dpxy(its:ite,kts:kte)
real a_mudf_xy(its:ite)
real dpn(its:ite,kts:kte)
real dpxy(its:ite,kts:kte)
#endif
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
real keep_ph1(its-1:ite+1,kts-1:kte+1)   !REVISED BY WALLS
real keep_ph2(its-1:ite+1,kts-1:kte+1)   !REVISED BY WALLS
real keep_pb1(its-1:ite+1,kts-1:kte+1)   !REVISED BY WALLS
real keep_alt1(its-1:ite+1,kts-1:kte+1)  !REVISED BY WALLS
real dx
real dy
integer i
integer i_end
integer i_end_up
integer i_endu
integer i_start
integer i_start_up
integer j
integer j_end
integer j_end_vp
integer j_endv
integer j_start
integer j_start_vp
integer k
integer k_end
integer k_start
integer i_end_parallel, j_end_parallel
integer i_endu_parallel, j_endv_parallel
integer i_end_up_parallel, j_end_vp_parallel
#ifdef DM_PARALLEL
integer ips, ipe, jps, jpe, kps, kpe, kds
#endif

   call trace_entry("a_advance_uv")

#ifdef DM_PARALLEL
ips = its
ipe = ite
jps = jts
jpe = jte
kps = kts
kpe = kte
kds = kts
#endif

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_dpn(:,:) = 0.
!a_dpxy(:,:) = 0.
a_mudf_xy(:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (config_flags%nested .or. config_flags%specified) then
  i_start = max(its,ids+spec_zone)
  i_end = min(ite,ide-spec_zone-1)
  j_start = max(jts,jds+spec_zone)
  j_end = min(jte,jde-spec_zone-1)
  k_start = kts
  k_end = min(kte,kde-1)
  i_endu = min(ite,ide-spec_zone)
  j_endv = min(jte,jde-spec_zone)
else
  i_start = its
  i_end = ite
  j_start = jts
  j_end = jte
  k_start = kts
  k_end = kte-1
  i_endu = i_end
  j_endv = j_end
  if (j_end .eq. jde) then
    j_end = j_end-1
  endif
  if (i_end .eq. ide) then
    i_end = i_end-1
  endif
endif
! recompute : i_end,i_endu,i_start,j_end,j_endv,j_start,k_end,k_start
i_start_up = i_start
! recompute : i_start_up
i_end_up = i_endu
! recompute : i_end_up
j_start_vp = j_start
! recompute : j_start_vp
j_end_vp = j_endv
! recompute : j_end_vp
if ((config_flags%open_xs .or. config_flags%symmetric_xs) .and. its .eq. ids) then
  i_start_up = i_start_up+1
endif
! recompute : i_start_up
if ((config_flags%open_xe .or. config_flags%symmetric_xe) .and. ite .eq. ide) then
  i_end_up = i_end_up-1
endif
! recompute : i_end_up
if ((config_flags%open_ys .or. config_flags%symmetric_ys) .and. jts .eq. jds) then
  j_start_vp = j_start_vp+1
endif
! recompute : j_start_vp
if ((config_flags%open_ye .or. config_flags%symmetric_ye) .and. jte .eq. jde) then
  j_end_vp = j_end_vp-1
endif
if (ite .eq. ide) then
   i_end_parallel = i_end
   i_endu_parallel = i_endu
   i_end_up_parallel = i_end_up
else
   i_end_parallel = i_end+1
   i_endu_parallel = i_endu+1
   i_end_up_parallel = i_end_up+1
endif
if (jte .eq. jde) then
   j_end_parallel = j_end
   j_endv_parallel = j_endv
   j_end_vp_parallel = j_end_vp
else
   j_end_parallel = j_end+1
   j_endv_parallel = j_endv+1
   j_end_vp_parallel = j_end_vp+1
endif
#ifdef DM_PARALLEL
!xinzhang parallel tuning
#include "HALO_ADJ_ADVANCE_UV.inc" 
#endif
! recompute : j_end_vp
dx = 1./rdx
! recompute : dx
dy = 1./rdy
! recompute : dy

a_v_outer_j_loop: do j = j_endv_parallel, j_start, -1
  if (j .ge. j_start_vp .and. j .le. j_end_vp_parallel) then   !AAA-IF-START

! keep_ph1(i,k)=ph(i,k+1,j)-ph(i,k+1,j-1)+ph(i,k,j)-ph(i,k,j-1)
  keep_ph1(i_start_up:i_end_up_parallel,k_start:k_end)=ph(i_start_up:i_end_up_parallel,k_start+1:k_end+1,j)&
&-ph(i_start_up:i_end_up_parallel,k_start+1:k_end+1,j-1)+ph(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&-ph(i_start_up:i_end_up_parallel,k_start:k_end,j-1)
  keep_pb1(i_start_up:i_end_up_parallel,k_start:k_end)=pb(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&-pb(i_start_up:i_end_up_parallel,k_start:k_end,j-1)
  keep_alt1(i_start_up:i_end_up_parallel,k_start:k_end)=alt(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&+alt(i_start_up:i_end_up_parallel,k_start:k_end,j-1)

    kwalls(i_start_up:i_end_up_parallel,k_start:k_end)=p(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&-p(i_start_up:i_end_up_parallel,k_start:k_end,j-1)
    gwalls(i_start_up:i_end_up_parallel,k_start:k_end)=al(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&+al(i_start_up:i_end_up_parallel,k_start:k_end,j-1)

    do k = k_start, k_end
      do i = i_start, i_end_parallel
        dpxy(i,k) = 0.5*rdy*muv(i,j)*(keep_ph1(i,k)+keep_alt1(i,k)*kwalls(i,k)+gwalls(i,k)*keep_pb1(i,k))
      end do
    end do
! recompute : dpxy
    if (non_hydrostatic) then
!     do i = i_start, i_end_parallel
!       dpn(i,1) = 0.5*(cf1*(p(i,1,j)+p(i,1,j-1))+cf2*(p(i,2,j)+p(i,2,j-1))+cf3*(p(i,3,j)+p(i,3,j-1)))
!     end do
      dpn(i_start:i_end_parallel,1) = 0.5*(cf1*(p(i_start:i_end_parallel,1,j)+p(i_start:i_end_parallel,1,j-1))&
&+cf2*(p(i_start:i_end_parallel,2,j)+p(i_start:i_end_parallel,2,j-1))+cf3*(p(i_start:i_end_parallel,3,j)&
&+p(i_start:i_end_parallel,3,j-1)))
      dpn(i_start:i_end_parallel,kde) = 0.
      do k = k_start+1, k_end
!       do i = i_start, i_end_parallel
!         dpn(i,k) = 0.5*(fnm(k)*(p(i,k,j)+p(i,k,j-1))+fnp(k)*(p(i,k-1,j)+p(i,k-1,j-1)))
!       end do
        dpn(i_start:i_end_parallel,k) = 0.5*(fnm(k)*(p(i_start:i_end_parallel,k,j)+p(i_start:i_end_parallel,k,j-1))&
&+fnp(k)*(p(i_start:i_end_parallel,k-1,j)+p(i_start:i_end_parallel,k-1,j-1)))
      end do
      do k = k_start, k_end
        walls(1)=rdnw(k)
        do i = i_start, i_end_parallel
          dpxy(i,k) = dpxy(i,k)+rdy*(php(i,k,j)-php(i,k,j-1))*(walls(1)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i,j-1)+mu(i,j)))
        end do
      end do
    endif
! recompute : dpxy
    do k = k_start, k_end
      do i = i_start, i_end_parallel
        a_cqv(i,k,j) = a_cqv(i,k,j)-a_v(i,k,j)*dts*dpxy(i,k)
!       a_dpxy(i,k)  = a_dpxy(i,k)-a_v(i,k,j)*dts*cqv(i,k,j)
        a_dpxy(i,k)  = -a_v(i,k,j)*dts*cqv(i,k,j)
      end do
      a_mudf_xy(i_start:i_end_parallel) = a_mudf_xy(i_start:i_end_parallel)+a_v(i_start:i_end_parallel,k,j)
    end do
    if (non_hydrostatic) then
! recompute : dpn
      do k = k_start, k_end
        walls(2)=rdnw(k)
        do i = i_start, i_end_parallel
          walls(1)=a_dpxy(i,k)*rdy
          walls(3)=walls(1)*(php(i,k,j)-php(i,k,j-1))
          a_dpn(i,k+1) = a_dpn(i,k+1)+walls(3)*walls(2)
          a_dpn(i,k) = a_dpn(i,k)-walls(3)*walls(2)
          a_mu(i,j-1) = a_mu(i,j-1)-0.5*walls(3)
          a_mu(i,j) = a_mu(i,j)-0.5*walls(3)
          walls(3)=walls(1)*(walls(2)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i,j-1)+mu(i,j)))
          a_php(i,k,j-1) = a_php(i,k,j-1)-walls(3)
          a_php(i,k,j)   = a_php(i,k,j)  +walls(3)
        end do
      end do

      do k = k_start+1, k_end
        walls(1)=fnp(k)
        walls(2)=fnm(k)
        do i = i_start, i_end_parallel
          a_p(i,k-1,j-1) = a_p(i,k-1,j-1)+0.5*a_dpn(i,k)*walls(1)
          a_p(i,k-1,j) = a_p(i,k-1,j)+0.5*a_dpn(i,k)*walls(1)
          a_p(i,k,j-1) = a_p(i,k,j-1)+0.5*a_dpn(i,k)*walls(2)
          a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpn(i,k)*walls(2)
        end do
      end do
      a_dpn(i_start:i_end_parallel,k_start+1:k_end) = 0.

      a_dpn(i_start:i_end_parallel,kde) = 0.
      do i = i_start, i_end_parallel
        a_p(i,3,j-1) = a_p(i,3,j-1)+0.5*a_dpn(i,1)*cf3
        a_p(i,3,j) = a_p(i,3,j)+0.5*a_dpn(i,1)*cf3
        a_p(i,2,j-1) = a_p(i,2,j-1)+0.5*a_dpn(i,1)*cf2
        a_p(i,2,j) = a_p(i,2,j)+0.5*a_dpn(i,1)*cf2
        a_p(i,1,j-1) = a_p(i,1,j-1)+0.5*a_dpn(i,1)*cf1
        a_p(i,1,j) = a_p(i,1,j)+0.5*a_dpn(i,1)*cf1
      end do
      a_dpn(i_start:i_end_parallel,1) = 0.
    endif
    do k = k_start, k_end
      do i = i_start, i_end_parallel
        walls(1)=0.5*a_dpxy(i,k)*rdy*muv(i,j)
        walls(2)=keep_pb1(i,k)
        walls(4)=keep_alt1(i,k)
        a_muv(i,j) = a_muv(i,j)+0.5*a_dpxy(i,k)*rdy*(keep_ph1(i,k)+walls(4)*kwalls(i,k)+gwalls(i,k)*walls(2))
        a_al(i,k,j-1) = a_al(i,k,j-1)+walls(1)*walls(2)
        a_al(i,k,j) = a_al(i,k,j)+walls(1)*walls(2)
        a_alt(i,k,j-1) = a_alt(i,k,j-1)+walls(1)*kwalls(i,k)
        a_alt(i,k,j) = a_alt(i,k,j)+walls(1)*kwalls(i,k)
        a_p(i,k,j-1) = a_p(i,k,j-1)-walls(1)*walls(4)
        a_p(i,k,j) = a_p(i,k,j)+walls(1)*walls(4)
        a_ph(i,k+1,j-1) = a_ph(i,k+1,j-1)-walls(1)
        a_ph(i,k+1,j) = a_ph(i,k+1,j)+walls(1)
        a_ph(i,k,j-1) = a_ph(i,k,j-1)-walls(1)
        a_ph(i,k,j) = a_ph(i,k,j)+walls(1)
!       a_dpxy(i,k) = 0.
      end do
    end do
  endif    !AAA-IF-START

  do i = i_start, i_end_parallel
    a_mudf(i,j-1) = a_mudf(i,j-1)+a_mudf_xy(i)*emdiv*dy
    a_mudf(i,j) = a_mudf(i,j)-a_mudf_xy(i)*emdiv*dy
  end do
  a_mudf_xy(i_start:i_end_parallel) = 0.
!  do k = k_start, k_end
!    do i = i_start, i_end_parallel
!      a_rv_tend(i,k,j) = a_rv_tend(i,k,j)+a_v(i,k,j)*dts
!    end do
!  end do
   a_rv_tend(i_start:i_end_parallel,k_start:k_end,j) =a_rv_tend(i_start:i_end_parallel,k_start:k_end,j)&
&+a_v(i_start:i_end_parallel,k_start:k_end,j)*dts

end do a_v_outer_j_loop


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

do j = j_start, j_end_parallel
! keep_ph2(i,k)=ph(i,k+1,j)-ph(i-1,k+1,j)+ph(i,k,j)-ph(i-1,k,j)
  keep_ph2(i_start_up:i_end_up_parallel,k_start:k_end)=ph(i_start_up:i_end_up_parallel,k_start+1:k_end+1,j)&
&-ph(i_start_up-1:i_end_up_parallel-1,k_start+1:k_end+1,j)+ph(i_start_up:i_end_up_parallel,k_start:k_end,j)&
&-ph(i_start_up-1:i_end_up_parallel-1,k_start:k_end,j)

  do k = k_start, k_end
    do i = i_start_up, i_end_up_parallel
      dpxy(i,k) = 0.5*rdx*muu(i,j)*(keep_ph2(i,k)+(alt(i,k,j)+alt(i-1,k,j))*(p(i,k,j)-p(i-1,k,j))&
&+(al(i,k,j)+al(i-1,k,j))*(pb(i,k,j)-pb(i-1,k,j)))
    end do
  end do
! recompute : dpxy
  if (non_hydrostatic) then
    do i = i_start_up, i_end_up_parallel
      dpn(i,1) = 0.5*(cf1*(p(i,1,j)+p(i-1,1,j))+cf2*(p(i,2,j)+p(i-1,2,j))+cf3*(p(i,3,j)+p(i-1,3,j)))
      dpn(i,kde) = 0.
    end do
    do k = k_start+1, k_end
      walls(1)=fnp(k)
      walls(2)=fnm(k)
      do i = i_start_up, i_end_up_parallel
        dpn(i,k) = 0.5*(walls(2)*(p(i,k,j)+p(i-1,k,j))+walls(1)*(p(i,k-1,j)+p(i-1,k-1,j)))
      end do
    end do

    do k = k_start, k_end
      walls(1)=rdnw(k)
      do i = i_start_up, i_end_up_parallel
        gwalls(i,k)=(walls(1)*(dpn(i,k+1)-dpn(i,k))-0.5*(mu(i-1,j)+mu(i,j)))
      end do
    end do

    do k = k_start, k_end
      do i = i_start_up, i_end_up_parallel
        dpxy(i,k) = dpxy(i,k)+rdx*(php(i,k,j)-php(i-1,k,j))*gwalls(i,k)
      end do
    end do
  endif
! recompute : dpxy
  do k = k_start, k_end
    do i = i_start_up, i_end_up_parallel
      a_cqu(i,k,j) = a_cqu(i,k,j)-a_u(i,k,j)*dts*dpxy(i,k)
!     a_dpxy(i,k) = a_dpxy(i,k)-a_u(i,k,j)*dts*cqu(i,k,j)
      a_dpxy(i,k) = -a_u(i,k,j)*dts*cqu(i,k,j)
    end do
    a_mudf_xy(i_start_up:i_end_up_parallel) = a_mudf_xy(i_start_up:i_end_up_parallel)+a_u(i_start_up:i_end_up_parallel,k,j)
  end do
  if (non_hydrostatic) then
! recompute : dpn
    do k = k_start, k_end
      walls(3)=rdnw(k)
      do i = i_start_up, i_end_up_parallel
        walls(1)=a_dpxy(i,k)*rdx; walls(2)=walls(1)*(php(i,k,j)-php(i-1,k,j))
        a_dpn(i,k+1) = a_dpn(i,k+1)+walls(2)*walls(3)
        a_dpn(i,k) = a_dpn(i,k)-walls(2)*walls(3)
        a_mu(i-1,j) = a_mu(i-1,j)-0.5*walls(2)
        a_mu(i,j) = a_mu(i,j)-0.5*walls(2)
        a_php(i-1,k,j) = a_php(i-1,k,j)-walls(1)*gwalls(i,k)
        a_php(i,k,j) = a_php(i,k,j)+walls(1)*gwalls(i,k)
      end do
    end do
    do k = k_start+1, k_end
      walls(1)=fnp(k)
      walls(2)=fnm(k)
      do i = i_start_up, i_end_up_parallel
        a_p(i-1,k-1,j) = a_p(i-1,k-1,j)+0.5*a_dpn(i,k)* walls(1)
        a_p(i,k-1,j) = a_p(i,k-1,j)+0.5*a_dpn(i,k)* walls(1)
        a_p(i-1,k,j) = a_p(i-1,k,j)+0.5*a_dpn(i,k)*walls(2)
        a_p(i,k,j) = a_p(i,k,j)+0.5*a_dpn(i,k)*walls(2)
      end do
      a_dpn(i_start_up:i_end_up_parallel,k) = 0.
    end do
    a_dpn(i_start_up:i_end_up_parallel,kde) = 0.
    do i = i_start_up, i_end_up_parallel
      a_p(i-1,3,j) = a_p(i-1,3,j)+0.5*a_dpn(i,1)*cf3
      a_p(i,3,j) = a_p(i,3,j)+0.5*a_dpn(i,1)*cf3
      a_p(i-1,2,j) = a_p(i-1,2,j)+0.5*a_dpn(i,1)*cf2
      a_p(i,2,j) = a_p(i,2,j)+0.5*a_dpn(i,1)*cf2
      a_p(i-1,1,j) = a_p(i-1,1,j)+0.5*a_dpn(i,1)*cf1
      a_p(i,1,j) = a_p(i,1,j)+0.5*a_dpn(i,1)*cf1
    end do
    a_dpn(i_start_up:i_end_up_parallel,1) = 0.
  endif

  do k = k_start, k_end
    do i = i_start_up, i_end_up_parallel
      walls(1)=0.5*a_dpxy(i,k)*rdx; a_dpxy(i,k)=0.; walls(2)=walls(1)*muu(i,j)
      walls(3)=alt(i,k,j)+alt(i-1,k,j)
      walls(4)=pb(i,k,j)-pb(i-1,k,j)
      walls(5)=p(i,k,j)-p(i-1,k,j)
      a_muu(i,j) = a_muu(i,j)+walls(1)*(keep_ph2(i,k)+walls(3)*walls(5)+(al(i,k,j)+al(i-1,k,j))*walls(4))
      a_al(i-1,k,j) = a_al(i-1,k,j)+walls(2)*walls(4)
      a_al(i,k,j) = a_al(i,k,j)+walls(2)*walls(4)
      a_alt(i-1,k,j) = a_alt(i-1,k,j)+walls(2)*walls(5)
      a_alt(i,k,j) = a_alt(i,k,j)+walls(2)*walls(5)
      a_p(i-1,k,j) = a_p(i-1,k,j)-walls(2)*walls(3)
      a_p(i,k,j) = a_p(i,k,j)+walls(2)*walls(3)
      a_ph(i-1,k+1,j) = a_ph(i-1,k+1,j)-walls(2)
      a_ph(i,k+1,j) = a_ph(i,k+1,j)+walls(2)
      a_ph(i-1,k,j) = a_ph(i-1,k,j)-walls(2)
      a_ph(i,k,j) = a_ph(i,k,j)+walls(2)
!     a_dpxy(i,k) = 0.
    end do
  end do

! a_dpxy(i_start_up:i_end_up_paralle,k_start:k_end) = 0.
! a_dpxy = 0.

! do i = i_start_up, i_end_up_parallel
!   a_mudf(i-1,j) = a_mudf(i-1,j)+a_mudf_xy(i)*emdiv*dx
!   a_mudf(i,j)   = a_mudf(i,j)-a_mudf_xy(i)*emdiv*dx
! end do

  a_mudf(i_start_up-1:i_end_up_parallel-1,j)=a_mudf(i_start_up-1:i_end_up_parallel-1,j)&
&+a_mudf_xy(i_start_up:i_end_up_parallel)*emdiv*dx
  a_mudf(i_start_up:i_end_up_parallel,j) = a_mudf(i_start_up:i_end_up_parallel,j)-a_mudf_xy(i_start_up:i_end_up_parallel)*emdiv*dx

  a_mudf_xy(i_start_up:i_end_up_parallel) = 0.

! do k = k_start, k_end
!   do i = i_start, i_endu_parallel
!     a_ru_tend(i,k,j) = a_ru_tend(i,k,j)+a_u(i,k,j)*dts
!   end do
! end do
  a_ru_tend(i_start:i_endu_parallel,k_start:k_end,j) = a_ru_tend(i_start:i_endu_parallel,k_start:k_end,j)&
&+a_u(i_start:i_endu_parallel,k_start:k_end,j)*dts

end do

   call trace_exit("a_advance_uv")

end subroutine a_advance_uv


subroutine a_advance_w( w, a_w, rw_tend, a_rw_tend, ww, a_ww, u, a_u, v, a_v, mu1, a_mu1, mut, a_mut, muave, a_muave, muts, a_muts,&
& t_2ave, a_t_2ave, t_2, a_t_2, t_1, a_t_1, ph, a_ph, ph_1, a_ph_1, phb, ph_tend, a_ph_tend, ht, c2a, a_c2a, cqw, a_cqw, alt, &
&a_alt, alb, a, a_a, alpha, a_alpha, gamma, a_gamma, rdx, rdy, dts, t0, epssm, fnm, fnp, rdnw, rdn, cf1, cf2, cf3, msft, &
&config_flags, ids, ide, jds, jde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************

#ifdef DM_PARALLEL
use module_dm
#endif

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(in) :: a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alpha(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqw(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_gamma(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu1(ims:ime,jms:jme)
real, intent(inout) :: a_muave(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2ave(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alpha(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cf1
real, intent(in) :: cf2
real, intent(in) :: cf3
type (grid_config_rec_type), intent(in) :: config_flags
real, intent(in) :: cqw(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: fnm(kms:kme)
real, intent(in) :: fnp(kms:kme)
real, intent(in) :: gamma(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ht(ims:ime,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: mu1(ims:ime,jms:jme)
real, intent(in) :: muave(ims:ime,jms:jme)
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
real, intent(inout) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: phb(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: rdx
real, intent(in) :: rdy
real, intent(in) :: rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t0
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: t_2ave(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ww(ims:ime,kms:kme,jms:jme)
real walls(8)

!==============================================
! declare local variables
!==============================================
#ifdef DM_PARALLEL
real a_mut_inv(its-1:ite)
real a_rhs(its-1:ite,kts:kte)
real a_wdwn(its-1:ite,kts:kte)
#else
real a_mut_inv(its:ite)
real a_rhs(its:ite,kts:kte)
real a_wdwn(its:ite,kts:kte)
#endif
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
#ifdef DM_PARALLEL
real msft_inv(its-1:ite)
real mut_inv(its-1:ite)
real rhs(its-1:ite,kts:kte)
real wdwn(its-1:ite,kts:kte)
#else
real msft_inv(its:ite)
real mut_inv(its:ite)
real rhs(its:ite,kts:kte)
real wdwn(its:ite,kts:kte)
#endif
!real t_2aveh(ims:ime,kms:kme,jms:jme)
!real wh(ims:ime,kms:kme,jms:jme)
real t_2aveh(ims:ime,kms:kme)
real wh(ims:ime,kms:kme)
real keep1_w(ims:ime,kms:kme)
real keep2_w(ims:ime,kms:kme)
real keep3_w(ims:ime,kms:kme)
real keep4_alpha_a(ims:ime,kms:kme)
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
real keep_ph_rhs1(its-1:ite+1,kts-1:kte+1)  !REVISED BY WALLS
real keep_ph_rhs2(its-1:ite+1,kts-1:kte+1)  !REVISED BY WALLS
real keep_ph_foure(its-1:ite+1,kts-1:kte+1) !REVISED BY WALLS
#ifdef DM_PARALLEL
integer ips, ipe, jps, jpe, kps, kpe, kds, kde
#endif

   call trace_entry("a_advance_w")

#ifdef DM_PARALLEL
ips = its
ipe = ite
jps = jts
jpe = jte
kps = kts
kpe = kte
kds = kts
kde = kte
#endif

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
!wh(:,:,:) = w(:,:,:)
!t_2aveh(:,:,:) = t_2ave(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
!a_mut_inv(:) = 0.
!a_rhs(:,:) = 0.
a_wdwn(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_end = kte-1
! recompute : k_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. its .eq. ids) then
  i_start = i_start+1
else
  i_start = i_start-1
endif
! recompute : i_start
if ((config_flags%specified .or. config_flags%nested) .and. ite .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if ((config_flags%specified .or. config_flags%nested) .and. jts .eq. jds) then
  j_start = j_start+1
else
  j_start = j_start-1
endif
! recompute : j_start
if ((config_flags%specified .or. config_flags%nested) .and. jte .eq. jde) then
  j_end = j_end-1
endif

#ifdef DM_PARALLEL
!xinzhang parallel tuning
#include "HALO_ADJ_ADVANCE_W.inc" 
#endif
! recompute : j_end
do j = j_start, j_end
  wh(:,:) = w(:,:,j)
  t_2aveh(:,:) = t_2ave(:,:,j)

! DO i=i_start, i_end
!   rhs(i,1) = 0.
! ENDDO
  rhs(i_start:i_end,1) = 0.

  do i = i_start, i_end
    mut_inv(i) = 1./mut(i,j)
    msft_inv(i) = 1./msft(i,j)
  end do
! recompute : msft_inv,mut_inv

  do k = 1, k_end
    do i = i_start, i_end
!     t_2ave(i,k,j) = 0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2ave(i,k,j))
!     t_2ave(i,k,j) = (t_2ave(i,k,j)-mu1(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)))
      t_2ave(i,k,j) = (0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2ave(i,k,j))-mu1(i,j)*t_1(i,k,j))/(muts(i,j)*(t0+t_1(i,k,j)))
    end do
  end do
! recompute : t_2ave

! keep_ph_foure(i,k)=ph_1(i,k,j)-ph_1(i,k-1,j)+phb(i,k,j)-phb(i,k-1,j)
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
  keep_ph_foure(i_start:i_end,2:k_end+1)=ph_1(i_start:i_end,2:k_end+1,j)-ph_1(i_start:i_end,1:k_end,j)&
&                                       +phb(i_start:i_end,2:k_end+1,j) -phb(i_start:i_end,1:k_end,j)

  do k = 2, k_end+1
    walls(1)=rdnw(k-1)
    do i = i_start, i_end
      wdwn(i,k) = 0.5*(ww(i,k,j)+ww(i,k-1,j))*walls(1)*keep_ph_foure(i,k)
      rhs(i,k) = dts*(ph_tend(i,k,j)+0.5*g*(1.-epssm)*w(i,k,j))
    end do
  end do
! recompute : rhs,wdwn
  do k = 2, k_end
    walls(1)=dts*fnm(k); walls(2)=dts*fnp(k)
!   do i = i_start, i_end
!     rhs(i,k) = rhs(i,k)-walls(1)*wdwn(i,k+1)-walls(2)*wdwn(i,k)
!   end do
    rhs(i_start:i_end,k) = rhs(i_start:i_end,k)-walls(1)*wdwn(i_start:i_end,k+1)-walls(2)*wdwn(i_start:i_end,k)
  end do
! recompute : rhs

! do k = 2, k_end+1
!   do i = i_start, i_end
!     keep_ph(i,k) = (1.-epssm)*(ph(i,k,j)-ph(i,k-1,j))
!   end do
! end do
! keep_ph(i_start:i_end,2:k_end+1) = (1.-epssm)*(ph(i_start:i_end,2:k_end+1,j)-ph(i_start:i_end,1:k_end,j))

  do k = 2, k_end+1
    do i = i_start, i_end
      rhs(i,k) = ph(i,k,j)+msft(i,j)*rhs(i,k)*mut_inv(i)
    end do
  end do
! do k = 2, k_end+1
!   do i = i_start, i_end
!     keep_rhs(i,k) = (1.+epssm)*(rhs(i,k)-rhs(i,k-1))
!   end do
! end do
  keep_ph_rhs1(i_start:i_end,2:k_end+1) = (1.+epssm)*(rhs(i_start:i_end,2:k_end+1)-rhs(i_start:i_end, 1:k_end)) &
&                                       + (1.-epssm)*(ph(i_start:i_end, 2:k_end+1,j)-ph(i_start:i_end,1:k_end,j))
  keep_ph_rhs2(i_start:i_end,2:k_end)   = (1.+epssm)*(rhs(i_start:i_end,3:k_end+1)-rhs(i_start:i_end, 2:k_end)) &
&                                       + (1.-epssm)*(ph(i_start:i_end, 3:k_end+1,j)-ph(i_start:i_end,2:k_end,j))
! recompute : rhs

  do i = i_start, i_end
    w(i,1,j) = 0.5*rdy*((ht(i,j+1)-ht(i,j))*(cf1*v(i,1,j+1)+cf2*v(i,2,j+1)+cf3*v(i,3,j+1))&
&  +(ht(i,j)-ht(i,j-1))*(cf1*v(i,1,j)+cf2*v(i,2,j)+cf3*v(i,3,j)))&
&  +0.5*rdx*((ht(i+1,j)-ht(i,j))*(cf1*u(i+1,1,j)+cf2*u(i+1,2,j)+cf3*u(i+1,3,j))&
&  +(ht(i,j)-ht(i-1,j))*(cf1*u(i,1,j)+cf2*u(i,2,j)+cf3*u(i,3,j)))
  end do
! recompute : w

  do k = 2, k_end
    walls(1)=rdnw(k-1)
    walls(2)=rdnw(k)
    walls(3)=rdn(k)
    do i = i_start, i_end
      w(i,k,j) = w(i,k,j) +dts*rw_tend(i,k,j) +dts*g*msft_inv(i)*(&

&cqw(i,k,j)*0.5*mut_inv(i)*walls(3)*(c2a(i,k,j)*walls(2)*keep_ph_rhs2(i,k)-c2a(i,k-1,j)*walls(1)*keep_ph_rhs1(i,k))&

&+& !AAAAA

&walls(3)*(c2a(i,k,j)*alt(i,k,j)*t_2ave(i,k,j)-c2a(i,k-1,j)*alt(i,k-1,j)*t_2ave(i,k-1,j))&
&+(walls(3)*(c2a(i,k,j)*alb(i,k,j)-c2a(i,k-1,j)*alb(i,k-1,j))*mut_inv(i)-1.)*muave(i,j)&

&) !AAAAA
    end do
  end do
! recompute : w
  k = k_end+1
! recompute : k
  walls(1) =2.0*rdnw(k-1)
  do i = i_start, i_end
    w(i,k,j) = w(i,k,j)+dts*rw_tend(i,k,j)+msft_inv(i)*((-(0.5*dts*g*mut_inv(i)*0.5*walls(1)*walls(1)*c2a(i,k-1,j)*keep_ph_rhs1(i,k)))&
&-dts*g*(walls(1)*c2a(i,k-1,j)*alt(i,k-1,j)*t_2ave(i,k-1,j)+(1.+walls(1)*c2a(i,k-1,j)*alb(i,k-1,j)*mut_inv(i))*muave(i,j)))
  end do
! recompute : w
  do k = 2, k_end+1
    do i = i_start, i_end
      keep1_w(i,k-1) =w(i,k-1,j)*alpha(i,k,j)
      keep2_w(i,k) =w(i,k,j)-a(i,k,j)*w(i,k-1,j)
      keep4_alpha_a(i,k) =a(i,k,j)*alpha(i,k,j)
      w(i,k,j) = keep2_w(i,k)*alpha(i,k,j)
    end do
  end do
! recompute : w
  do k = k_end, 2, -1
    do i = i_start, i_end
      keep3_w(i,k+1) =w(i,k+1,j)  
      w(i,k,j) = w(i,k,j)-gamma(i,k,j)*w(i,k+1,j)
    end do
  end do
! recompute : w
  walls(1)=0.5*dts*g*(1.+epssm)
  do k = 2, k_end+1
    do i = i_start, i_end
      walls(2)=a_ph(i,k,j)*walls(1)*msft(i,j)/muts(i,j)
      a_muts(i,j) = a_muts(i,j)-walls(2)*w(i,k,j)/muts(i,j)
!     a_rhs(i,k) = a_rhs(i,k)+a_ph(i,k,j)
!     a_rhs(i,k) = a_ph(i,k,j)
      a_w(i,k,j) = a_w(i,k,j)+walls(2)
!     a_ph(i,k,j) = 0.
    end do
  end do

!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
! a_rhs(i_start:i_end,2:k_end+1) = a_ph(i_start:i_end,2:k_end+1,j)
  a_rhs(i_start:i_end,1:k_end+1) = a_ph(i_start:i_end,1:k_end+1,j)  !REVISED BY WALLS
! a_ph(i_start:i_end,2:k_end+1,j) = 0.
  a_ph(i_start:i_end,1:k_end+1,j) = 0.   !REVISED BY WALLS

  do k = 2, k_end
    do i = i_start, i_end
!     w(i,k+1,j) =keep3_w(i,k+1)  
      a_gamma(i,k,j) = a_gamma(i,k,j)-a_w(i,k,j)*keep3_w(i,k+1)
      a_w(i,k+1,j)   = a_w(i,k+1,j)-a_w(i,k,j)*gamma(i,k,j)
    end do
  end do

  do k = k_end+1, 2, -1
    do i = i_start, i_end
!     w(i,k-1,j)=keep1_w(i,k-1) 
!     w(i,k,j)=keep2_w(i,k) 
      a_a(i,k,j) = a_a(i,k,j)-a_w(i,k,j)*keep1_w(i,k-1)
      a_alpha(i,k,j) = a_alpha(i,k,j)+a_w(i,k,j)*keep2_w(i,k)
      a_w(i,k-1,j) = a_w(i,k-1,j)-a_w(i,k,j)*keep4_alpha_a(i,k)
      a_w(i,k,j) = a_w(i,k,j)*alpha(i,k,j)
    end do
  end do

! recdepend vars : k_end
! recompute pos : ASSIGN_STMT module_small_step_em.f90:1404
! recompute vars : k
  k = k_end+1
! recompute vars : k
  walls(1)=rdnw(k-1)
  do i = i_start, i_end
    walls(3)=a_w(i,k,j)*msft_inv(i)*dts*g
    a_rw_tend(i,k,j) = a_rw_tend(i,k,j)+a_w(i,k,j)*dts

    walls(4)=walls(3)*mut_inv(i)*walls(1)*walls(1)*c2a(i,k-1,j)
    walls(5)=alb(i,k-1,j)
    walls(6)=c2a(i,k-1,j)
    a_alt(i,k-1,j) = a_alt(i,k-1,j)-2*walls(3)*walls(1)*walls(6)*t_2ave(i,k-1,j)
    a_c2a(i,k-1,j) = a_c2a(i,k-1,j)-walls(3)*(mut_inv(i)*walls(1)*walls(1)*keep_ph_rhs1(i,k)&
&+2*walls(1)*(alt(i,k-1,j)*t_2ave(i,k-1,j)+walls(5)*mut_inv(i)*muave(i,j)))
    a_muave(i,j) = a_muave(i,j)-walls(3)*(1+2.*walls(1)*walls(6)*walls(5)*mut_inv(i))
    a_mut_inv(i) = -walls(3)*walls(6)*(walls(1)*walls(1)*keep_ph_rhs1(i,k)&
&+2*walls(1)*walls(5)*muave(i,j))
    a_ph(i,k-1,j) = a_ph(i,k-1,j)+walls(4)*(1.-epssm)
    a_ph(i,k,j) = a_ph(i,k,j)-walls(4)*(1.-epssm)
    a_rhs(i,k-1) = a_rhs(i,k-1)+walls(4)*(1.+epssm)
    a_rhs(i,k) = a_rhs(i,k)-walls(4)*(1+epssm)
    a_t_2ave(i,k-1,j) = a_t_2ave(i,k-1,j)-2*walls(3)*walls(1)*walls(6)*alt(i,k-1,j)
  end do

! print*, 'RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR'
  do k = 2, k_end
    walls(3)=rdnw(k-1)
    walls(4) =rdn(k)
    walls(5) =rdnw(k)
    do i = i_start, i_end
      walls(8)=a_w(i,k,j)*msft_inv(i)
      a_rw_tend(i,k,j) = a_rw_tend(i,k,j)+a_w(i,k,j)*dts

      walls(6)=cqw(i,k,j)*dts*g
      walls(2)=0.5*walls(8)*walls(6)*mut_inv(i)*walls(4)
      walls(7)=c2a(i,k,j)
      walls(1)=c2a(i,k-1,j)

      a_muave(i,j) = a_muave(i,j)+walls(8)*dts*g*(-1.0+walls(4)*(walls(7)*alb(i,k,j)-walls(1)*alb(i,k-1,j))*mut_inv(i))

      walls(8)=walls(8)*walls(4)

      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)  +walls(8)*(&
&-0.5*walls(6)*mut_inv(i)*walls(3)*keep_ph_rhs1(i,k)&
&-dts*g*(alt(i,k-1,j)*t_2ave(i,k-1,j) +alb(i,k-1,j)*mut_inv(i)*muave(i,j)) )

      a_c2a(i,k,j) = a_c2a(i,k,j)  +walls(8)*(&
&0.5*walls(6)*mut_inv(i)*walls(5)*keep_ph_rhs2(i,k)&
&+dts*g*(alt(i,k,j)*t_2ave(i,k,j)+alb(i,k,j)*mut_inv(i)*muave(i,j)))

      a_mut_inv(i) = a_mut_inv(i)  +walls(8)*(&
&0.5*walls(6)*(walls(7)*walls(5)*keep_ph_rhs2(i,k)&
&-walls(1)*walls(3)*keep_ph_rhs1(i,k))&
&+dts*g*(walls(7)*alb(i,k,j)-walls(1)*alb(i,k-1,j))*muave(i,j))

      a_ph(i,k-1,j) = a_ph(i,k-1,j)+walls(2)*walls(1)*walls(3)*(1.-epssm)
      a_ph(i,k+1,j) = a_ph(i,k+1,j)+walls(2)*walls(7)*walls(5)*(1.-epssm)
      a_ph(i,k,j) = a_ph(i,k,j)-walls(2)*(walls(7)*walls(5)*(1.-epssm)+walls(1)*walls(3)*(1.-epssm))

!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!XXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLSXXXWALLS
!     print*, a_rhs(i,k-1), i, k-1
      a_rhs(i,k-1) = a_rhs(i,k-1)+walls(2)*walls(1)*walls(3)*(1.+epssm)

      a_rhs(i,k+1) = a_rhs(i,k+1)+walls(2)*walls(7)*walls(5)*(1+epssm)
      a_rhs(i,k) = a_rhs(i,k)-walls(2)*(walls(7)*walls(5)*(1.+epssm)+walls(1)*walls(3)*(1+epssm))

      walls(8)=walls(8)*dts*g

      a_cqw(i,k,j) = a_cqw(i,k,j)+0.5*walls(8)*mut_inv(i)*(walls(7)*walls(5)*(&
&keep_ph_rhs2(i,k))-walls(1)*walls(3)*keep_ph_rhs1(i,k))

      a_t_2ave(i,k-1,j) = a_t_2ave(i,k-1,j)-walls(8)*walls(1)*alt(i,k-1,j)
      a_t_2ave(i,k,j) = a_t_2ave(i,k,j)+walls(8)*walls(7)*alt(i,k,j)

      a_alt(i,k-1,j) = a_alt(i,k-1,j)-walls(8)*walls(1)*t_2ave(i,k-1,j)
      a_alt(i,k,j)   = a_alt(i,k,j)+walls(8)*walls(7)*t_2ave(i,k,j)
    end do
  end do
  do i = i_start, i_end
    walls(1)=0.5*a_w(i,1,j)*rdx*(ht(i+1,j)-ht(i,j))
    walls(2)=0.5*a_w(i,1,j)*rdx*(ht(i,j)-ht(i-1,j))
    walls(3)=0.5*a_w(i,1,j)*rdy*(ht(i,j+1)-ht(i,j))
    walls(4)=0.5*a_w(i,1,j)*rdy*(ht(i,j)-ht(i,j-1))
    a_u(i+1,3,j) = a_u(i+1,3,j)+walls(1)*cf3
    a_u(i+1,2,j) = a_u(i+1,2,j)+walls(1)*cf2
    a_u(i+1,1,j) = a_u(i+1,1,j)+walls(1)*cf1
    a_u(i,3,j) = a_u(i,3,j)+walls(2)*cf3
    a_u(i,2,j) = a_u(i,2,j)+walls(2)*cf2
    a_u(i,1,j) = a_u(i,1,j)+walls(2)*cf1
    a_v(i,3,j+1) = a_v(i,3,j+1)+walls(3)*cf3
    a_v(i,2,j+1) = a_v(i,2,j+1)+walls(3)*cf2
    a_v(i,1,j+1) = a_v(i,1,j+1)+walls(3)*cf1
    a_v(i,3,j) = a_v(i,3,j)+walls(4)*cf3
    a_v(i,2,j) = a_v(i,2,j)+walls(4)*cf2
    a_v(i,1,j) = a_v(i,1,j)+walls(4)*cf1
  end do
  a_w(i_start:i_end,1,j) = 0.

! w(:,:,:) = wh(:,:,:)
! w(:,:,j) = wh(:,:)
! recdepend vars : dts,epssm,g,i_end,i_start,j,k_end,ph_tend,w
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1335
! recompute vars : rhs
  do k = 2, k_end+1
!   do i = i_start, i_end
!     rhs(i,k) = dts*(ph_tend(i,k,j)+0.5*g*(1.-epssm)*w(i,k,j))
!   end do
    rhs(i_start:i_end,k) = dts*(ph_tend(i_start:i_end,k,j)+0.5*g*(1.-epssm)*wh(i_start:i_end,k))
  end do
! recompute vars : rhs
! recdepend vars : dts,fnm,fnp,i_end,i_start,k_end,rhs,wdwn
! recompute pos : DOLOOP_STMT module_small_step_em.f90:1343
! recompute vars : rhs
  do k = 2, k_end
    walls(1) =fnm(k)
    walls(2) =fnp(k)
    do i = i_start, i_end
      rhs(i,k) = rhs(i,k)-dts*(walls(1)*wdwn(i,k+1)+walls(2)*wdwn(i,k))
    end do
  end do
! recompute vars : rhs
  do k = 2, k_end+1
    do i = i_start, i_end
      a_mut_inv(i) = a_mut_inv(i)+a_rhs(i,k)*msft(i,j)*rhs(i,k)
      a_ph(i,k,j)  = a_ph(i,k,j)+a_rhs(i,k)
      a_rhs(i,k)   = a_rhs(i,k)*msft(i,j)*mut_inv(i)
    end do
  end do
  do k = 2, k_end
    walls(1) =dts*fnm(k)
    walls(2) =dts*fnp(k)
    do i = i_start, i_end
      a_wdwn(i,k+1) = a_wdwn(i,k+1)-a_rhs(i,k)*walls(1)
      a_wdwn(i,k)   = a_wdwn(i,k)-a_rhs(i,k)*walls(2)
    end do
  end do
  do k = 2, k_end+1
    walls(2)=rdnw(k-1)
    do i = i_start, i_end
      a_ph_tend(i,k,j) = a_ph_tend(i,k,j)+a_rhs(i,k)*dts
      a_w(i,k,j) = a_w(i,k,j)+0.5*a_rhs(i,k)*dts*g*(1.-epssm)
!     a_rhs(i,k) = 0.
      walls(1)=0.5*a_wdwn(i,k)*walls(2)
!     a_wdwn(i,k) = 0.
      a_ph_1(i,k-1,j) = a_ph_1(i,k-1,j)-walls(1)*(ww(i,k,j)+ww(i,k-1,j))
      a_ph_1(i,k,j) = a_ph_1(i,k,j)+walls(1)*(ww(i,k,j)+ww(i,k-1,j))
      a_ww(i,k-1,j) = a_ww(i,k-1,j)+walls(1)*keep_ph_foure(i,k)
      a_ww(i,k,j) = a_ww(i,k,j)+walls(1)*keep_ph_foure(i,k)
    end do
  end do
  a_wdwn(i_start:i_end,2:k_end+1) = 0.

! t_2ave(:,:,:) = t_2aveh(:,:,:)
! t_2ave(:,:,j) = t_2aveh(:,:)
  do k = 1, k_end
    do i = i_start, i_end
!     t_2ave(i,k,j) = 0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2ave(i,k,j))
      walls(1) = 0.5*((1.+epssm)*t_2(i,k,j)+(1.-epssm)*t_2aveh(i,k))
      walls(2) = (t0+t_1(i,k,j))*muts(i,j)
! recompute : t_2ave
      a_mu1(i,j) = a_mu1(i,j)-a_t_2ave(i,k,j)*t_1(i,k,j)/walls(2)
      a_muts(i,j) = a_muts(i,j)-a_t_2ave(i,k,j)*((walls(1)-mu1(i,j)*t_1(i,k,j))/(muts(i,j)*walls(2)))
      a_t_1(i,k,j) = a_t_1(i,k,j)-a_t_2ave(i,k,j)*(mu1(i,j)/walls(2)+(walls(1)-mu1(i,j)*t_1(i,k,j))*muts(i,&
&j)/(walls(2)*walls(2)))
      a_t_2ave(i,k,j) = a_t_2ave(i,k,j)/walls(2)
      a_t_2(i,k,j) = a_t_2(i,k,j)+0.5*a_t_2ave(i,k,j)*(1+epssm)
      a_t_2ave(i,k,j) = 0.5*a_t_2ave(i,k,j)*(1.-epssm)
    end do
  end do

  do i = i_start, i_end
    a_mut(i,j) = a_mut(i,j)-a_mut_inv(i)/(mut(i,j)*mut(i,j))
!   a_mut_inv(i) = 0.
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

   call trace_exit("a_advance_w")

end subroutine a_advance_w


subroutine a_calc_coef_w( a, a_a, alpha, a_alpha, gamma, a_gamma, mut, a_mut, cqw, a_cqw, rdn, rdnw, c2a, a_c2a, dts, g, epssm, &
&ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alpha(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_cqw(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_gamma(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: alpha(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: cqw(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dts
real, intent(in) :: epssm
real, intent(in) :: g
real, intent(inout) :: gamma(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)
real gwalls

!==============================================
! declare local variables
!==============================================
real a_b
real a_c
real a_cof(ims:ime)
real b
real c
real cof(ims:ime)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k1

   call trace_entry("a_calc_coef_w")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_b = 0.
a_c = 0.
a_cof(:) = 0.
gwalls =0.5*dts*g*(1.+epssm)
!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
do j = j_start, j_end
  a_b = 0.
  a_c = 0.
  do i = i_start, i_end
    cof(i) = (gwalls/mut(i,j))*(gwalls/mut(i,j))
    a(i,2,j) = 0.
    a(i,kde,j) = -(2.*cof(i)*rdnw(kde-1)*rdnw(kde-1)*c2a(i,kde-1,j))
    gamma(i,1,j) = 0.
  end do
! recompute : cof,gamma
  do k = 3, kde-1
    do i = i_start, i_end
      a(i,k,j) = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j))
    end do
  end do
! recompute : a
  do k = 2, kde-1
    do i = i_start, i_end
      b = 1.+cqw(i,k,j)*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      c = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j))
      alpha(i,k,j) = 1./(b-a(i,k,j)*gamma(i,k-1,j))
      gamma(i,k,j) = c*alpha(i,k,j)
    end do
  end do
! recompute : gamma
  do i = i_start, i_end
    a_b = 0.
    a_c = 0.
    b = 1.+2.*cof(i)*rdnw(kde-1)*rdnw(kde-1)*c2a(i,kde-1,j)
! recompute : b
    c = 0.
! recompute : c
    alpha(i,kde,j) = 1./(b-a(i,kde,j)*gamma(i,kde-1,j))
! recompute : alpha
    a_alpha(i,kde,j) = a_alpha(i,kde,j)+a_gamma(i,kde,j)*c
    a_c = a_c+a_gamma(i,kde,j)*alpha(i,kde,j)
    a_gamma(i,kde,j) = 0.
    a_a(i,kde,j) = a_a(i,kde,j)+a_alpha(i,kde,j)*(1.*gamma(i,kde-1,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,kde-1,&
&j))))
    a_b = a_b-a_alpha(i,kde,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,kde-1,j)))
    a_gamma(i,kde-1,j) = a_gamma(i,kde-1,j)+a_alpha(i,kde,j)*(1.*a(i,kde,j)/((b-a(i,kde,j)*gamma(i,kde-1,j))*(b-a(i,kde,j)*gamma(i,&
&kde-1,j))))
    a_alpha(i,kde,j) = 0.
    a_c = 0.
    a_c2a(i,kde-1,j) = a_c2a(i,kde-1,j)+2*a_b*cof(i)*rdnw(kde-1)*rdnw(kde-1)
    a_cof(i) = a_cof(i)+2*a_b*rdnw(kde-1)*rdnw(kde-1)*c2a(i,kde-1,j)
    a_b = 0.
  end do
  do k = kde-1, 2, -1
! recdepend vars : i_end,i_start,j
! recompute pos : DOLOOP_STMT module_small_step_em.f90:658
! recompute vars : gamma
    do i = i_start, i_end
      gamma(i,1,j) = 0.
    end do
! recompute vars : gamma
    do k1 = 2, k-1
      do i = i_start, i_end
        b = 1.+cqw(i,k1,j)*cof(i)*rdn(k1)*(rdnw(k1)*c2a(i,k1,j)+rdnw(k1-1)*c2a(i,k1-1,j))
        c = -(cqw(i,k1,j)*cof(i)*rdn(k1)*rdnw(k1)*c2a(i,k1,j))
        alpha(i,k1,j) = 1./(b-a(i,k1,j)*gamma(i,k1-1,j))
        gamma(i,k1,j) = c*alpha(i,k1,j)
      end do
    end do
    do i = i_start, i_end
      a_b = 0.
      a_c = 0.
      b = 1.+cqw(i,k,j)*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
! recompute : b
      c = -(cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j))
! recompute : c
      alpha(i,k,j) = 1./(b-a(i,k,j)*gamma(i,k-1,j))
! recompute : alpha
      a_alpha(i,k,j) = a_alpha(i,k,j)+a_gamma(i,k,j)*c
      a_c = a_c+a_gamma(i,k,j)*alpha(i,k,j)
      a_gamma(i,k,j) = 0.
      a_a(i,k,j) = a_a(i,k,j)+a_alpha(i,k,j)*(1.*gamma(i,k-1,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j))))
      a_b = a_b-a_alpha(i,k,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j)))
      a_gamma(i,k-1,j) = a_gamma(i,k-1,j)+a_alpha(i,k,j)*(1.*a(i,k,j)/((b-a(i,k,j)*gamma(i,k-1,j))*(b-a(i,k,j)*gamma(i,k-1,j))))
      a_alpha(i,k,j) = 0.
      a_c2a(i,k,j) = a_c2a(i,k,j)-a_c*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)
      a_cof(i) = a_cof(i)-a_c*cqw(i,k,j)*rdn(k)*rdnw(k)*c2a(i,k,j)
      a_cqw(i,k,j) = a_cqw(i,k,j)-a_c*cof(i)*rdn(k)*rdnw(k)*c2a(i,k,j)
      a_c = 0.
      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)+a_b*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)
      a_c2a(i,k,j) = a_c2a(i,k,j)+a_b*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k)
      a_cof(i) = a_cof(i)+a_b*cqw(i,k,j)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      a_cqw(i,k,j) = a_cqw(i,k,j)+a_b*cof(i)*rdn(k)*(rdnw(k)*c2a(i,k,j)+rdnw(k-1)*c2a(i,k-1,j))
      a_b = 0.
    end do
  end do
  do k = 3, kde-1
    do i = i_start, i_end
      a_c2a(i,k-1,j) = a_c2a(i,k-1,j)-a_a(i,k,j)*cqw(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)
      a_cof(i) = a_cof(i)-a_a(i,k,j)*cqw(i,k,j)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j)
      a_cqw(i,k,j) = a_cqw(i,k,j)-a_a(i,k,j)*cof(i)*rdn(k)*rdnw(k-1)*c2a(i,k-1,j)
      a_a(i,k,j) = 0.
    end do
  end do
  do i = i_start, i_end
!   cof(i) = (gwalls/mut(i,j))**2
! recompute : cof
    a_gamma(i,1,j) = 0.
    a_c2a(i,kde-1,j) = a_c2a(i,kde-1,j)-2*a_a(i,kde,j)*cof(i)*rdnw(kde-1)*rdnw(kde-1)
    a_cof(i) = a_cof(i)-2*a_a(i,kde,j)*rdnw(kde-1)*rdnw(kde-1)*c2a(i,kde-1,j)
    a_a(i,kde,j) = 0.
    a_a(i,2,j) = 0.
    a_mut(i,j) = a_mut(i,j)-2*a_cof(i)*gwalls/(mut(i,j)*mut(i,j))*(gwalls/mut(i,j))
    a_cof(i) = 0.
  end do
end do

   call trace_exit("a_calc_coef_w")

end subroutine a_calc_coef_w


subroutine a_calc_p_rho( al, a_al, p, a_p, ph, a_ph, alt, a_alt, t_2, a_t_2, t_1, a_t_1, c2a, a_c2a, a_pm1, mu, a_mu, muts, a_muts,&
& znu, t0, rdnw, dnw, smdiv, non_hydrostatic, step, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_al(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_pm1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(out) :: al(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: c2a(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dnw(kms:kme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
logical, intent(in) :: non_hydrostatic
real, intent(out) :: p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rdnw(kms:kme)
real, intent(in) :: smdiv
integer, intent(in) :: step
real, intent(in) :: t0
real, intent(in) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: znu(kms:kme)
real walls(8)

!==============================================
! declare local variables
!==============================================
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer k_end
integer k_start

   call trace_entry("a_calc_p_rho")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = min(kte,kde-1)
! recompute : k_end
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
if (step .eq. 0) then
! do j = j_start, j_end
!   do k = k_start, k_end
!     do i = i_start, i_end
!       a_p(i,k,j) = a_p(i,k,j)+a_pm1(i,k,j)
!       a_pm1(i,k,j) = 0.
!     end do
!   end do
! end do
  a_p(i_start:i_end,k_start:k_end,j_start:j_end) = a_p(i_start:i_end,k_start:k_end,j_start:j_end)&
&+a_pm1(i_start:i_end,k_start:k_end,j_start:j_end)
  a_pm1(i_start:i_end,k_start:k_end,j_start:j_end) = 0.
else
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        walls(1)     = a_pm1(i,k,j)
        a_pm1(i,k,j) = -a_p(i,k,j)*smdiv
        a_p(i,k,j)   = a_p(i,k,j)*(1+smdiv)+walls(1)
      end do
    end do
  end do
endif
if (non_hydrostatic) then
  do j = j_start, j_end
    do k = k_start, k_end
      walls(1)=rdnw(k)
      do i = i_start, i_end
        walls(2) = t_1(i,k,j)
        walls(3) = (t0+walls(2))*muts(i,j)
        walls(4) = muts(i,j)
        walls(5) = (t_2(i,k,j)-mu(i,j)*walls(2))/walls(3)
        walls(6) = a_p(i,k,j)*c2a(i,k,j)
        walls(8) = alt(i,k,j)
        walls(7) = (walls(8)*mu(i,j)+walls(1)*(ph(i,k+1,j)-ph(i,k,j)))/walls(4)
        al(i,k,j) = -walls(7)
        a_alt(i,k,j) = a_alt(i,k,j)+walls(6)*walls(5)
        a_c2a(i,k,j) = a_c2a(i,k,j)+a_p(i,k,j)*(walls(8)*walls(5)-al(i,k,j))
        a_mu(i,j) = a_mu(i,j)-walls(6)*(walls(8)*walls(2)/walls(3))
        a_muts(i,j) = a_muts(i,j)-walls(6)*(walls(8)*walls(5)*(t0+walls(2))/(walls(4)*(t0+walls(2))))
        a_t_1(i,k,j) = a_t_1(i,k,j)-walls(6)*walls(8)*(mu(i,j)+walls(5)*walls(4))/walls(3)
        a_t_2(i,k,j) = a_t_2(i,k,j)+walls(6)*(walls(8)/walls(3))
        walls(5) = (a_al(i,k,j)-walls(6))/walls(4)
        a_alt(i,k,j) = a_alt(i,k,j)-walls(5)*mu(i,j)
        a_mu(i,j) = a_mu(i,j)-walls(5)*walls(8)
        a_muts(i,j) = a_muts(i,j)+walls(5)*walls(7)
        a_ph(i,k+1,j) = a_ph(i,k+1,j)-walls(5)*walls(1)
        a_ph(i,k,j) = a_ph(i,k,j)+walls(5)*walls(1)
      end do
    end do
  end do
  a_p(i_start:i_end,k_start:k_end,j_start:j_end) = 0.
  a_al(i_start:i_end,k_start:k_end,j_start:j_end) = 0.
else
  do j = j_start, j_end
    do k = k_end, k_start, -1
      walls(1)=znu(k)
      walls(2)=dnw(k)
      do i = i_start, i_end
        walls(3) = a_ph(i,k+1,j)
        walls(4) = muts(i,j)*t0+t_1(i,k,j)
        walls(5) = (t_2(i,k,j)-mu(i,j)*t_1(i,k,j))/walls(4)
        walls(6) = mu(i,j)/c2a(i,k,j)
        walls(7) = alt(i,k,j)
        walls(8) = a_al(i,k,j)-walls(3)*walls(2)*muts(i,j)
        a_alt(i,k,j) = a_alt(i,k,j)-walls(3)*walls(2)*mu(i,j)
        a_mu(i,j) = a_mu(i,j)-walls(3)*walls(2)*walls(7)
        a_muts(i,j) = a_muts(i,j)-walls(3)*walls(2)*al(i,k,j)*walls(5)-walls(1)*walls(6)
        a_ph(i,k,j) = a_ph(i,k,j)+walls(3)
        walls(3) = t0+t_1(i,k,j)
        a_alt(i,k,j) = a_alt(i,k,j)+walls(8)*walls(5)
        a_c2a(i,k,j) = a_c2a(i,k,j)+walls(8)*walls(1)*walls(6)*walls(6)/mu(i,j)
        walls(7) =walls(8)*walls(7)/walls(4)
        a_mu(i,j) = a_mu(i,j)-walls(7)*t_1(i,k,j)
        a_muts(i,j) = a_muts(i,j)-walls(7)*walls(5)*walls(3)
        a_p(i,k,j) = a_p(i,k,j)-walls(8)/c2a(i,k,j)
        a_t_1(i,k,j) = a_t_1(i,k,j)-walls(7)*(mu(i,j)+walls(4)*walls(5)/walls(3))
        a_t_2(i,k,j) = a_t_2(i,k,j)+walls(7)
        a_mu(i,j) = a_mu(i,j)+a_p(i,k,j)*walls(1)
      end do
      a_ph(i_start:i_end,k+1,j) = 0.
    end do
  end do
  a_al(i_start:i_end,k_start:k_end,j_start:j_end) = 0.
  a_p(i_start:i_end,k_start:k_end,j_start:j_end) = 0.
endif

   call trace_exit("a_calc_p_rho")

end subroutine a_calc_p_rho

subroutine a_small_step_finish( u_2, a_u_2, v_2, a_v_2, w_2, a_w_2, t_2, a_t_2, a_ph_2, a_mu_2, mut, a_mut, muts, a_muts, muu, &
&a_muu, muus, a_muus, muv, a_muv, muvs, a_muvs, u_save, a_u_save, v_save, a_v_save, w_save, a_w_save, t_save, a_t_save, a_ph_save, &
&a_mu_save, msfu, msfv, msft, number_of_small_timesteps, dts, ide, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte )

!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_mu_2(ims:ime,jms:jme)
real, intent(inout) :: a_mu_save(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muus(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_muvs(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ph_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_save(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(in) :: msft(ims:ime,jms:jme)
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(inout) :: mut(ims:ime,jms:jme)
real, intent(inout) :: muts(ims:ime,jms:jme)
real, intent(inout) :: muu(ims:ime,jms:jme)
real, intent(inout) :: muus(ims:ime,jms:jme)
real, intent(inout) :: muv(ims:ime,jms:jme)
real, intent(inout) :: muvs(ims:ime,jms:jme)
real, intent(inout) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_2(ims:ime,kms:kme,jms:jme)
real, intent(in) :: w_save(ims:ime,kms:kme,jms:jme)


  REAL,   DIMENSION(ims:ime, kms:kme, jms:jme)  ::ww1,a_ww1,a_ww
  REAL, DIMENSION(ims:ime, kms:kme, jms:jme) :: h_diabatic
  INTEGER                   :: number_of_small_timesteps
  REAL                      :: dts



!==============================================
! declare local variables
!==============================================
real walls(4),gwalls(ims:ime)
integer i
integer i_end
integer i_endu
integer i_start
integer j
integer j_end
integer j_endv
integer j_start
integer k

   call trace_entry("a_small_step_finish")

ww1 = 0.0; a_ww1=0.0; a_ww=0.0
h_diabatic = 0.0
!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
i_endu = i_end
! recompute : i_endu
j_endv = j_end
! recompute : j_endv
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif
! recompute : j_end
!do j = j_start, j_end
!  do i = i_start, i_end
!    a_mu_save(i,j) = a_mu_save(i,j)+a_mu_2(i,j)
!  end do
!end do
a_mu_save(i_start:i_end,j_start:j_end) = a_mu_save(i_start:i_end,j_start:j_end)+a_mu_2(i_start:i_end,j_start:j_end)

walls(1)=dts*number_of_small_timesteps
do j = j_start, j_end
  do k = kds, kde-1
    gwalls(i_start:i_end)=walls(1)*h_diabatic(i_start:i_end,k,j)
    do i = i_start, i_end
      walls(2)=a_t_2(i,k,j)/muts(i,j)
      a_mut(i,j) = a_mut(i,j)+walls(2)*(-gwalls(i)*muts(i,j)+t_save(i,k,j))
      a_muts(i,j) = a_muts(i,j)-walls(2)*(t_2(i,k,j)-gwalls(i)*mut(i,j)+t_save(i,k,j)*mut(i,j))/muts(i,j)
      a_t_save(i,k,j) = a_t_save(i,k,j)+walls(2)*mut(i,j)
      a_t_2(i,k,j) = walls(2)
    end do
  end do
end do

a_ww1(i_start:i_end,kds:kde,j_start:j_end) =a_ww1(i_start:i_end,kds:kde,j_start:j_end) +a_ww(i_start:i_end,kds:kde,j_start:j_end)
a_ph_save(i_start:i_end,kds:kde,j_start:j_end) = a_ph_save(i_start:i_end,kds:kde,j_start:j_end)+a_ph_2(i_start:i_end,kds:kde,j_start:j_end)

do j = j_start, j_end
  do k = kds, kde
    do i = i_start, i_end
      walls(1)=a_w_2(i,k,j)
      walls(2)=w_save(i,k,j)/muts(i,j)
      a_mut(i,j) = a_mut(i,j)+walls(1)*walls(2)
      a_muts(i,j) = a_muts(i,j)-walls(1)*(msft(i,j)/muts(i,j)*w_2(i,k,j)+walls(2)*mut(i,j))/muts(i,j)
      a_w_save(i,k,j) = a_w_save(i,k,j)+walls(1)*(mut(i,j)/muts(i,j))
      a_w_2(i,k,j) = walls(1)*(msft(i,j)/muts(i,j))
    end do
  end do
end do
do j = j_start, j_end
  do k = kds, kde-1
    do i = i_start, i_endu
      walls(1)=a_u_2(i,k,j)/muus(i,j)
      a_muu(i,j) = a_muu(i,j)+walls(1)*u_save(i,k,j)
      a_muus(i,j) = a_muus(i,j)-walls(1)*((msfu(i,j)*u_2(i,k,j)+u_save(i,k,j)*muu(i,j))/muus(i,j))
      a_u_save(i,k,j) = a_u_save(i,k,j)+walls(1)*muu(i,j)
      a_u_2(i,k,j) = walls(1)*msfu(i,j)
    end do
  end do
end do
do j = j_start, j_endv
  do k = kds, kde-1
    do i = i_start, i_end
      walls(1)=a_v_2(i,k,j)/muvs(i,j)
      a_muv(i,j) = a_muv(i,j)+walls(1)*v_save(i,k,j)
      a_muvs(i,j) = a_muvs(i,j)-walls(1)*((msfv(i,j)*v_2(i,k,j)+v_save(i,k,j)*muv(i,j))/muvs(i,j))
      a_v_save(i,k,j) = a_v_save(i,k,j)+walls(1)*muv(i,j)
      a_v_2(i,k,j) = walls(1)*msfv(i,j)
    end do
  end do
end do

   call trace_exit("a_small_step_finish")

end subroutine a_small_step_finish


subroutine a_small_step_prep( u_1, a_u_1, u_2, a_u_2, v_1, a_v_1, v_2, a_v_2, w_1, a_w_1, w_2, a_w_2, t_1, a_t_1, t_2, a_t_2, &
&a_ph_1, a_ph_2, mub, mu_1, a_mu_1, mu_2, a_mu_2, muu, a_muu, muus, a_muus, muv, a_muv, muvs, a_muvs, mut, a_mut, muts, a_muts, &
&a_mudf, a_u_save, a_v_save, a_w_save, a_t_save, a_ph_save, a_mu_save, a_ww, a_ww_save, a_c2a, pb, p, a_p, alt, a_alt, msfu, msfv, &
&msft, rk_step, leapfrog, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_c2a(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu_1(ims:ime,jms:jme)
real, intent(inout) :: a_mu_2(ims:ime,jms:jme)
real, intent(inout) :: a_mu_save(ims:ime,jms:jme)
real, intent(inout) :: a_mudf(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muus(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
real, intent(inout) :: a_muvs(ims:ime,jms:jme)
real, intent(inout) :: a_p(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ph_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_save(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_save(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
logical, intent(in) :: leapfrog
real, intent(inout) :: msft(ims:ime,jms:jme)
real, intent(inout) :: msfu(ims:ime,jms:jme)
real, intent(inout) :: msfv(ims:ime,jms:jme)
real, intent(inout) :: mu_1(ims:ime,jms:jme)
real, intent(inout) :: mu_2(ims:ime,jms:jme)
real, intent(inout) :: mub(ims:ime,jms:jme)
real, intent(inout) :: mut(ims:ime,jms:jme)
real, intent(out) :: muts(ims:ime,jms:jme)
real, intent(inout) :: muu(ims:ime,jms:jme)
real, intent(out) :: muus(ims:ime,jms:jme)
real, intent(inout) :: muv(ims:ime,jms:jme)
real, intent(out) :: muvs(ims:ime,jms:jme)
real, intent(in) :: p(ims:ime,kms:kme,jms:jme)
real, intent(in) :: pb(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: rk_step
real, intent(inout) :: t_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: t_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: u_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: v_2(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_1(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: w_2(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
integer i
integer i_end
integer i_endu
integer i_start
integer j
integer j_end
integer j_endv
integer j_start
integer k
integer k_end
integer k_start
real    walls(4)

   call trace_entry("a_small_step_prep")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
i_start = its
! recompute : i_start
i_end = ite
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = jte
! recompute : j_end
k_start = kts
! recompute : k_start
k_end = min(kte,kde-1)
! recompute : k_end
i_endu = i_end
! recompute : i_endu
j_endv = j_end
! recompute : j_endv
if (i_end .eq. ide) then
  i_end = i_end-1
endif
! recompute : i_end
if (j_end .eq. jde) then
  j_end = j_end-1
endif

! recompute : j_end
if (rk_step .eq. 1 .and. ( .not. leapfrog)) then

!--------- added by zzma -----------
      DO j=j_start, j_end
      DO i=i_start, i_end
        mu_1(i,j)=mu_2(i,j)
      ENDDO
      ENDDO
!--------- added by zzma -----------

  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_endu
        u_1(i,k,j) = u_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_endv
    do k = k_start, k_end
      do i = i_start, i_end
        v_1(i,k,j) = v_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        t_1(i,k,j) = t_2(i,k,j)
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, min(kde,kte)
      do i = i_start, i_end
        w_1(i,k,j) = w_2(i,k,j)

!--------- added by zzma -----------
!        ph_1(i,k,j) = ph_2(i,k,j)
!--------- added by zzma -----------

      end do
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_end
      muts(i,j) = mub(i,j)+mu_2(i,j)
    end do
    do i = i_start, i_endu
      muus(i,j) = muu(i,j)
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      muvs(i,j) = muv(i,j)
    end do
  end do

else

  do j = j_start, j_end
    do i = i_start, i_end
      muts(i,j) = mub(i,j)+mu_1(i,j)
    end do
    do i = i_start, i_endu
      muus(i,j) = 0.5*(mub(i,j)+mu_1(i,j)+mub(i-1,j)+mu_1(i-1,j))
    end do
  end do

  do j = j_start, j_endv
    do i = i_start, i_end
      muvs(i,j) = 0.5*(mub(i,j)+mu_1(i,j)+mub(i,j-1)+mu_1(i,j-1))
    end do
  end do

    DO j=j_start, j_end
      DO i=i_start, i_end
        mu_2(i,j)=mu_1(i,j)-mu_2(i,j)
      ENDDO
    ENDDO

endif

!do j = j_start, j_end
!  do k = k_start, kde
!    do i = i_start, i_end
!      a_ww(i,k,j) = a_ww(i,k,j)+a_ww_save(i,k,j)
!      a_ww_save(i,k,j) = 0.
!    end do
!  end do
!end do
a_ww(i_start:i_end,k_start:kde,j_start:j_end) = a_ww(i_start:i_end,k_start:kde,j_start:j_end)+a_ww_save(i_start:i_end,k_start:kde,j_start:j_end)
a_ww_save(i_start:i_end,k_start:kde,j_start:j_end) = 0.

do j = j_start, j_end
  do k = k_start, kde
    do i = i_start, i_end
      a_ph_1(i,k,j) = a_ph_1(i,k,j)+a_ph_2(i,k,j)
      a_ph_2(i,k,j) = -a_ph_2(i,k,j)+a_ph_save(i,k,j)
      walls(1)=a_w_2(i,k,j)/msft(i,j)
      a_mut(i,j) = a_mut(i,j)-walls(1)*w_2(i,k,j)
      a_muts(i,j) = a_muts(i,j)+walls(1)*w_1(i,k,j)
      a_w_1(i,k,j) = a_w_1(i,k,j)+walls(1)*muts(i,j)
      a_w_2(i,k,j) = -walls(1)*mut(i,j)+a_w_save(i,k,j)
    end do
  end do
end do
a_ph_save(i_start:i_end,k_start:kde,j_start:j_end) = 0.
a_w_save(i_start:i_end,k_start:kde,j_start:j_end) = 0.

do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_end
      walls(1)=a_t_2(i,k,j)
      a_mut(i,j) = a_mut(i,j)-walls(1)*t_2(i,k,j)
      a_muts(i,j) = a_muts(i,j)+walls(1)*t_1(i,k,j)
      a_t_1(i,k,j) = a_t_1(i,k,j)+walls(1)*muts(i,j)
      a_t_2(i,k,j) = -walls(1)*mut(i,j)+a_t_save(i,k,j)
    end do
  end do
end do
a_t_save(i_start:i_end,k_start:k_end,j_start:j_end) = 0.

do j = j_start, j_endv
  do k = k_start, k_end
    do i = i_start, i_end
      walls(1)=a_v_2(i,k,j)/msfv(i,j)
      a_muv(i,j) = a_muv(i,j)-walls(1)*v_2(i,k,j)
      a_muvs(i,j) = a_muvs(i,j)+walls(1)*v_1(i,k,j)
      a_v_1(i,k,j) = a_v_1(i,k,j)+walls(1)*muvs(i,j)
      a_v_2(i,k,j) = -walls(1)*muv(i,j)+a_v_save(i,k,j)
    end do
  end do
end do
a_v_save(i_start:i_end,k_start:k_end,j_start:j_endv) = 0.

do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_endu
      walls(1)=a_u_2(i,k,j)/msfu(i,j)
      a_muu(i,j) = a_muu(i,j)-walls(1)*u_2(i,k,j)
      a_muus(i,j) = a_muus(i,j)+walls(1)*u_1(i,k,j)
      a_u_1(i,k,j) = a_u_1(i,k,j)+walls(1)*muus(i,j)
      a_u_2(i,k,j) = -walls(1)*muu(i,j)+a_u_save(i,k,j)
    end do
  end do
end do
a_u_save(i_start:i_endu,k_start:k_end,j_start:j_end) = 0.

do j = j_start, j_end
  do k = k_start, k_end
    do i = i_start, i_end
      walls(1)=a_c2a(i,k,j)*cpovcv/alt(i,k,j)
      a_alt(i,k,j) = a_alt(i,k,j)-walls(1)*(pb(i,k,j)+p(i,k,j))/alt(i,k,j)
      a_p(i,k,j) = a_p(i,k,j)+walls(1)
    end do
  end do
end do
a_c2a(i_start:i_end,k_start:k_end,j_start:j_end) = 0.

do j = j_start, j_end
  do i = i_start, i_end
    a_ww_save(i,1,j) = 0.
    a_ww_save(i,kde,j) = 0.
  end do
end do

if (rk_step .eq. 1 .and. ( .not. leapfrog)) then
  do j = j_start, j_end
    do i = i_start, i_end
      a_mu_2(i,j) = 0.
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_save(i,j)
      a_mu_save(i,j) = 0.
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      a_muv(i,j) = a_muv(i,j)+a_muvs(i,j)
      a_muvs(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_endu
      a_muu(i,j) = a_muu(i,j)+a_muus(i,j)
      a_muus(i,j) = 0.
    end do
    do i = i_start, i_end
      a_mu_2(i,j) = a_mu_2(i,j)+a_muts(i,j)
      a_muts(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do k = k_start, min(kde,kte)
      do i = i_start, i_end
        a_ph_2(i,k,j) = a_ph_2(i,k,j)+a_ph_1(i,k,j)
        a_ph_1(i,k,j) = 0.
        a_w_2(i,k,j) = a_w_2(i,k,j)+a_w_1(i,k,j)
        a_w_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_end
        a_t_2(i,k,j) = a_t_2(i,k,j)+a_t_1(i,k,j)
        a_t_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_endv
    do k = k_start, k_end
      do i = i_start, i_end
        a_v_2(i,k,j) = a_v_2(i,k,j)+a_v_1(i,k,j)
        a_v_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do k = k_start, k_end
      do i = i_start, i_endu
        a_u_2(i,k,j) = a_u_2(i,k,j)+a_u_1(i,k,j)
        a_u_1(i,k,j) = 0.
      end do
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_end
      a_mudf(i,j) = 0.
      a_ww_save(i,1,j) = 0.
      a_ww_save(i,kde,j) = 0.
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_1(i,j)
      a_mu_1(i,j) = 0.
    end do
  end do
else
!---------- zzma -----------
!  do j = j_start, j_end
!    do i = i_start, i_end
!      a_mu_1(i,j) = 0.0
!    end do
!  end do
!  do j = j_start, j_endv
!    do i = i_start, i_end
!      a_mu_1(i,j) = 0.0
!    end do
!  end do
!  do j = j_start, j_endv
!    do i = i_start, i_endu
!      a_mu_1(i,j) = 0.0
!    end do
!  end do

!   a_mu_1=0
!   a_u_1=0
!   a_v_1=0
!   a_w_1=0
!   a_t_1=0
!  a_ph_1=0
!  a_muts =0
!  a_muvs=0
!  a_muus=0
!  a_mu_save=0

!---------- zzma -----------
  do j = j_start, j_end
    do i = i_start, i_end
      a_mu_1(i,j) = a_mu_1(i,j)+a_mu_2(i,j)
      a_mu_2(i,j) = -a_mu_2(i,j)
      a_mu_2(i,j) = a_mu_2(i,j)+a_mu_save(i,j)
      a_mu_save(i,j) = 0.
    end do
  end do
  do j = j_start, j_endv
    do i = i_start, i_end
      a_mu_1(i,j-1) = a_mu_1(i,j-1)+0.5*a_muvs(i,j)
      a_mu_1(i,j) = a_mu_1(i,j)+0.5*a_muvs(i,j)
      a_muvs(i,j) = 0.
    end do
  end do
  do j = j_start, j_end
    do i = i_start, i_endu
      a_mu_1(i-1,j) = a_mu_1(i-1,j)+0.5*a_muus(i,j)
      a_mu_1(i,j) = a_mu_1(i,j)+0.5*a_muus(i,j)
      a_muus(i,j) = 0.
    end do
    do i = i_start, i_end
      a_mu_1(i,j) = a_mu_1(i,j)+a_muts(i,j)
      a_muts(i,j) = 0.
    end do
  end do
  a_mu_save(i_start:i_end,j_start:j_end) = 0.
  a_muvs(i_start:i_end,j_start:j_endv) = 0.
  a_muus(i_start:i_endu,j_start:j_end) = 0.
  a_muts(i_start:i_end,j_start:j_end) = 0.
endif

   call trace_exit("a_small_step_prep")

end subroutine a_small_step_prep


subroutine a_sumflux( a_ru, a_rv, a_ww, u_lin, a_u_lin, v_lin, a_v_lin, a_ww_lin, muu, a_muu, muv, a_muv, a_ru_m, a_rv_m, a_ww_m, &
&msfu, msfv, iteration, number_of_small_timesteps, ide, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_muu(ims:ime,jms:jme)
real, intent(inout) :: a_muv(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ru(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_m(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_m(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_v_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_lin(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ww_m(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: iteration
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: msfu(ims:ime,jms:jme)
real, intent(in) :: msfv(ims:ime,jms:jme)
real, intent(in) :: muu(ims:ime,jms:jme)
real, intent(in) :: muv(ims:ime,jms:jme)
integer, intent(in) :: number_of_small_timesteps
real, intent(in) :: u_lin(ims:ime,kms:kme,jms:jme)
real, intent(in) :: v_lin(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
integer i
integer j
integer k

   call trace_entry("a_sumflux")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (iteration .eq. number_of_small_timesteps) then
  do j = jts, min(jde-1,jte)
    do k = kts, kte
      do i = its, min(ide-1,ite)
        a_ww_lin(i,k,j) = a_ww_lin(i,k,j)+a_ww_m(i,k,j)
        a_ww_m(i,k,j) = a_ww_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
  do j = jts, jte
    do k = kts, min(kde-1,kte)
      do i = its, min(ide-1,ite)
        a_muv(i,j) = a_muv(i,j)+a_rv_m(i,k,j)*(v_lin(i,k,j)/msfv(i,j))
        a_v_lin(i,k,j) = a_v_lin(i,k,j)+a_rv_m(i,k,j)*(muv(i,j)/msfv(i,j))
        a_rv_m(i,k,j) = a_rv_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
  do j = jts, min(jde-1,jte)
    do k = kts, min(kde-1,kte)
      do i = its, ite
        a_muu(i,j) = a_muu(i,j)+a_ru_m(i,k,j)*(u_lin(i,k,j)/msfu(i,j))
        a_u_lin(i,k,j) = a_u_lin(i,k,j)+a_ru_m(i,k,j)*(muu(i,j)/msfu(i,j))
        a_ru_m(i,k,j) = a_ru_m(i,k,j)/float(number_of_small_timesteps)
      end do
    end do
  end do
endif
do j = jts, min(jde-1,jte)
  do k = kts, kte
    do i = its, min(ide-1,ite)
      a_ww(i,k,j) = a_ww(i,k,j)+a_ww_m(i,k,j)
    end do
  end do
end do
do j = jts, jte
  do k = kts, min(kde-1,kte)
    do i = its, min(ide-1,ite)
      a_rv(i,k,j) = a_rv(i,k,j)+a_rv_m(i,k,j)
    end do
  end do
end do
do j = jts, min(jde-1,jte)
  do k = kts, min(kde-1,kte)
    do i = its, ite
      a_ru(i,k,j) = a_ru(i,k,j)+a_ru_m(i,k,j)
    end do
  end do
end do
if (iteration .eq. 1) then
  do j = jts, jte
    do k = kts, kte
      do i = its, ite
        a_ww_m(i,k,j) = 0.
        a_rv_m(i,k,j) = 0.
        a_ru_m(i,k,j) = 0.
      end do
    end do
  end do
endif

   call trace_exit("a_sumflux")

end subroutine a_sumflux


end module     a_module_small_step_em


