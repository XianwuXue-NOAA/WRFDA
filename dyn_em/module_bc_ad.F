!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     a_module_bc
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_configure
use module_wrf_error
use module_bc

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine a_relax_bdytend( a_field, a_field_tend, a_field_bdy, a_field_bdy_tend, variable_in, spec_bdy_width, spec_zone, &
&relax_zone, dtbc, fcx, gcx, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
integer, intent(in) :: spec_bdy_width
real, intent(inout) :: a_field_bdy(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dtbc
real, intent(in) :: fcx(spec_bdy_width)
real, intent(in) :: gcx(spec_bdy_width)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: relax_zone
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
real a_fls0
real a_fls1
real a_fls2
real a_fls3
real a_fls4
integer b_dist
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_fls0 = 0.
a_fls1 = 0.
a_fls2 = 0.
a_fls3 = 0.
a_fls4 = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
variable = variable_in
! recompute : variable
if (variable .eq. 'U') then
  variable = 'u'
endif
! recompute : variable
if (variable .eq. 'V') then
  variable = 'v'
endif
! recompute : variable
if (variable .eq. 'M') then
  variable = 'm'
endif
! recompute : variable
if (variable .eq. 'H') then
  variable = 'h'
endif
! recompute : variable
ibs = ids
! recompute : ibs
ibe = ide-1
! recompute : ibe
itf = min(ite,ide-1)
! recompute : itf
jbs = jds
! recompute : jbs
jbe = jde-1
! recompute : jbe
jtf = min(jte,jde-1)
! recompute : jtf
ktf = kde-1
! recompute : ktf
if (variable .eq. 'u') then
  ibe = ide
endif
! recompute : ibe
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
! recompute : itf
if (variable .eq. 'v') then
  jbe = jde
endif
! recompute : jbe
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
! recompute : jtf
if (variable .eq. 'm') then
  ktf = kte
endif
! recompute : ktf
if (variable .eq. 'h') then
  ktf = kte
endif
! recompute : ktf
if (ibe-itf .lt. relax_zone) then
  do i = max(its,ibe-relax_zone+1), min(itf,ibe-spec_zone)
    a_fls0 = 0.
    a_fls1 = 0.
    a_fls2 = 0.
    a_fls3 = 0.
    a_fls4 = 0.
    b_dist = ibe-i
! recompute : b_dist
    do k = kts, ktf
      a_fls0 = 0.
      a_fls1 = 0.
      a_fls2 = 0.
      a_fls3 = 0.
      a_fls4 = 0.
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_fls0 = 0.
        a_fls1 = 0.
        a_fls2 = 0.
        a_fls3 = 0.
        a_fls4 = 0.
        a_fls0 = a_fls0+a_field_tend(i,k,j)*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))
        a_fls1 = a_fls1-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls2 = a_fls2-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls3 = a_fls3-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls4 = a_fls4-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_field(i-1,k,j) = a_field(i-1,k,j)-a_fls4
        a_field_bdy(j,k,b_dist+2,p_xeb) = a_field_bdy(j,k,b_dist+2,p_xeb)+a_fls4
        a_field_bdy_tend(j,k,b_dist+2,p_xeb) = a_field_bdy_tend(j,k,b_dist+2,p_xeb)+a_fls4*dtbc
        a_fls4 = 0.
        a_field(i+1,k,j) = a_field(i+1,k,j)-a_fls3
        a_field_bdy(j,k,b_dist,p_xeb) = a_field_bdy(j,k,b_dist,p_xeb)+a_fls3
        a_field_bdy_tend(j,k,b_dist,p_xeb) = a_field_bdy_tend(j,k,b_dist,p_xeb)+a_fls3*dtbc
        a_fls3 = 0.
        a_field(i,k,j+1) = a_field(i,k,j+1)-a_fls2
        a_field_bdy(j+1,k,b_dist+1,p_xeb) = a_field_bdy(j+1,k,b_dist+1,p_xeb)+a_fls2
        a_field_bdy_tend(j+1,k,b_dist+1,p_xeb) = a_field_bdy_tend(j+1,k,b_dist+1,p_xeb)+a_fls2*dtbc
        a_fls2 = 0.
        a_field(i,k,j-1) = a_field(i,k,j-1)-a_fls1
        a_field_bdy(j-1,k,b_dist+1,p_xeb) = a_field_bdy(j-1,k,b_dist+1,p_xeb)+a_fls1
        a_field_bdy_tend(j-1,k,b_dist+1,p_xeb) = a_field_bdy_tend(j-1,k,b_dist+1,p_xeb)+a_fls1*dtbc
        a_fls1 = 0.
        a_field(i,k,j) = a_field(i,k,j)-a_fls0
        a_field_bdy(j,k,b_dist+1,p_xeb) = a_field_bdy(j,k,b_dist+1,p_xeb)+a_fls0
        a_field_bdy_tend(j,k,b_dist+1,p_xeb) = a_field_bdy_tend(j,k,b_dist+1,p_xeb)+a_fls0*dtbc
        a_fls0 = 0.
      end do
    end do
  end do
endif
if (its-ibs .lt. relax_zone) then
  do i = max(its,ibs+spec_zone), min(itf,ibs+relax_zone-1)
    a_fls0 = 0.
    a_fls1 = 0.
    a_fls2 = 0.
    a_fls3 = 0.
    a_fls4 = 0.
    b_dist = i-ibs
! recompute : b_dist
    do k = kts, ktf
      a_fls0 = 0.
      a_fls1 = 0.
      a_fls2 = 0.
      a_fls3 = 0.
      a_fls4 = 0.
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_fls0 = 0.
        a_fls1 = 0.
        a_fls2 = 0.
        a_fls3 = 0.
        a_fls4 = 0.
        a_fls0 = a_fls0+a_field_tend(i,k,j)*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))
        a_fls1 = a_fls1-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls2 = a_fls2-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls3 = a_fls3-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls4 = a_fls4-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_field(i+1,k,j) = a_field(i+1,k,j)-a_fls4
        a_field_bdy(j,k,b_dist+2,p_xsb) = a_field_bdy(j,k,b_dist+2,p_xsb)+a_fls4
        a_field_bdy_tend(j,k,b_dist+2,p_xsb) = a_field_bdy_tend(j,k,b_dist+2,p_xsb)+a_fls4*dtbc
        a_fls4 = 0.
        a_field(i-1,k,j) = a_field(i-1,k,j)-a_fls3
        a_field_bdy(j,k,b_dist,p_xsb) = a_field_bdy(j,k,b_dist,p_xsb)+a_fls3
        a_field_bdy_tend(j,k,b_dist,p_xsb) = a_field_bdy_tend(j,k,b_dist,p_xsb)+a_fls3*dtbc
        a_fls3 = 0.
        a_field(i,k,j+1) = a_field(i,k,j+1)-a_fls2
        a_field_bdy(j+1,k,b_dist+1,p_xsb) = a_field_bdy(j+1,k,b_dist+1,p_xsb)+a_fls2
        a_field_bdy_tend(j+1,k,b_dist+1,p_xsb) = a_field_bdy_tend(j+1,k,b_dist+1,p_xsb)+a_fls2*dtbc
        a_fls2 = 0.
        a_field(i,k,j-1) = a_field(i,k,j-1)-a_fls1
        a_field_bdy(j-1,k,b_dist+1,p_xsb) = a_field_bdy(j-1,k,b_dist+1,p_xsb)+a_fls1
        a_field_bdy_tend(j-1,k,b_dist+1,p_xsb) = a_field_bdy_tend(j-1,k,b_dist+1,p_xsb)+a_fls1*dtbc
        a_fls1 = 0.
        a_field(i,k,j) = a_field(i,k,j)-a_fls0
        a_field_bdy(j,k,b_dist+1,p_xsb) = a_field_bdy(j,k,b_dist+1,p_xsb)+a_fls0
        a_field_bdy_tend(j,k,b_dist+1,p_xsb) = a_field_bdy_tend(j,k,b_dist+1,p_xsb)+a_fls0*dtbc
        a_fls0 = 0.
      end do
    end do
  end do
endif
if (jbe-jtf .lt. relax_zone) then
  do j = max(jts,jbe-relax_zone+1), min(jtf,jbe-spec_zone)
    a_fls0 = 0.
    a_fls1 = 0.
    a_fls2 = 0.
    a_fls3 = 0.
    a_fls4 = 0.
    b_dist = jbe-j
! recompute : b_dist
    do k = kts, ktf
      a_fls0 = 0.
      a_fls1 = 0.
      a_fls2 = 0.
      a_fls3 = 0.
      a_fls4 = 0.
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_fls0 = 0.
        a_fls1 = 0.
        a_fls2 = 0.
        a_fls3 = 0.
        a_fls4 = 0.
        a_fls0 = a_fls0+a_field_tend(i,k,j)*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))
        a_fls1 = a_fls1-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls2 = a_fls2-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls3 = a_fls3-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls4 = a_fls4-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_field(i,k,j-1) = a_field(i,k,j-1)-a_fls4
        a_field_bdy(i,k,b_dist+2,p_yeb) = a_field_bdy(i,k,b_dist+2,p_yeb)+a_fls4
        a_field_bdy_tend(i,k,b_dist+2,p_yeb) = a_field_bdy_tend(i,k,b_dist+2,p_yeb)+a_fls4*dtbc
        a_fls4 = 0.
        a_field(i,k,j+1) = a_field(i,k,j+1)-a_fls3
        a_field_bdy(i,k,b_dist,p_yeb) = a_field_bdy(i,k,b_dist,p_yeb)+a_fls3
        a_field_bdy_tend(i,k,b_dist,p_yeb) = a_field_bdy_tend(i,k,b_dist,p_yeb)+a_fls3*dtbc
        a_fls3 = 0.
        a_field(i+1,k,j) = a_field(i+1,k,j)-a_fls2
        a_field_bdy(i+1,k,b_dist+1,p_yeb) = a_field_bdy(i+1,k,b_dist+1,p_yeb)+a_fls2
        a_field_bdy_tend(i+1,k,b_dist+1,p_yeb) = a_field_bdy_tend(i+1,k,b_dist+1,p_yeb)+a_fls2*dtbc
        a_fls2 = 0.
        a_field(i-1,k,j) = a_field(i-1,k,j)-a_fls1
        a_field_bdy(i-1,k,b_dist+1,p_yeb) = a_field_bdy(i-1,k,b_dist+1,p_yeb)+a_fls1
        a_field_bdy_tend(i-1,k,b_dist+1,p_yeb) = a_field_bdy_tend(i-1,k,b_dist+1,p_yeb)+a_fls1*dtbc
        a_fls1 = 0.
        a_field(i,k,j) = a_field(i,k,j)-a_fls0
        a_field_bdy(i,k,b_dist+1,p_yeb) = a_field_bdy(i,k,b_dist+1,p_yeb)+a_fls0
        a_field_bdy_tend(i,k,b_dist+1,p_yeb) = a_field_bdy_tend(i,k,b_dist+1,p_yeb)+a_fls0*dtbc
        a_fls0 = 0.
      end do
    end do
  end do
endif
if (jts-jbs .lt. relax_zone) then
  do j = max(jts,jbs+spec_zone), min(jtf,jbs+relax_zone-1)
    a_fls0 = 0.
    a_fls1 = 0.
    a_fls2 = 0.
    a_fls3 = 0.
    a_fls4 = 0.
    b_dist = j-jbs
! recompute : b_dist
    do k = kts, ktf
      a_fls0 = 0.
      a_fls1 = 0.
      a_fls2 = 0.
      a_fls3 = 0.
      a_fls4 = 0.
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_fls0 = 0.
        a_fls1 = 0.
        a_fls2 = 0.
        a_fls3 = 0.
        a_fls4 = 0.
        a_fls0 = a_fls0+a_field_tend(i,k,j)*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))
        a_fls1 = a_fls1-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls2 = a_fls2-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls3 = a_fls3-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_fls4 = a_fls4-a_field_tend(i,k,j)*gcx(b_dist+1)
        a_field(i,k,j+1) = a_field(i,k,j+1)-a_fls4
        a_field_bdy(i,k,b_dist+2,p_ysb) = a_field_bdy(i,k,b_dist+2,p_ysb)+a_fls4
        a_field_bdy_tend(i,k,b_dist+2,p_ysb) = a_field_bdy_tend(i,k,b_dist+2,p_ysb)+a_fls4*dtbc
        a_fls4 = 0.
        a_field(i,k,j-1) = a_field(i,k,j-1)-a_fls3
        a_field_bdy(i,k,b_dist,p_ysb) = a_field_bdy(i,k,b_dist,p_ysb)+a_fls3
        a_field_bdy_tend(i,k,b_dist,p_ysb) = a_field_bdy_tend(i,k,b_dist,p_ysb)+a_fls3*dtbc
        a_fls3 = 0.
        a_field(i+1,k,j) = a_field(i+1,k,j)-a_fls2
        a_field_bdy(i+1,k,b_dist+1,p_ysb) = a_field_bdy(i+1,k,b_dist+1,p_ysb)+a_fls2
        a_field_bdy_tend(i+1,k,b_dist+1,p_ysb) = a_field_bdy_tend(i+1,k,b_dist+1,p_ysb)+a_fls2*dtbc
        a_fls2 = 0.
        a_field(i-1,k,j) = a_field(i-1,k,j)-a_fls1
        a_field_bdy(i-1,k,b_dist+1,p_ysb) = a_field_bdy(i-1,k,b_dist+1,p_ysb)+a_fls1
        a_field_bdy_tend(i-1,k,b_dist+1,p_ysb) = a_field_bdy_tend(i-1,k,b_dist+1,p_ysb)+a_fls1*dtbc
        a_fls1 = 0.
        a_field(i,k,j) = a_field(i,k,j)-a_fls0
        a_field_bdy(i,k,b_dist+1,p_ysb) = a_field_bdy(i,k,b_dist+1,p_ysb)+a_fls0
        a_field_bdy_tend(i,k,b_dist+1,p_ysb) = a_field_bdy_tend(i,k,b_dist+1,p_ysb)+a_fls0*dtbc
        a_fls0 = 0.
      end do
    end do
  end do
endif

end subroutine a_relax_bdytend


subroutine a_spec_bdytend( a_field_tend, a_field_bdy_tend, variable_in, spec_bdy_width, spec_zone, ijds, ijde, ids, ide, jds, jde, &
&kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
integer, intent(in) :: spec_bdy_width
real, intent(inout) :: a_field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_field_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
variable = variable_in
! recompute : variable
if (variable .eq. 'U') then
  variable = 'u'
endif
! recompute : variable
if (variable .eq. 'V') then
  variable = 'v'
endif
! recompute : variable
if (variable .eq. 'M') then
  variable = 'm'
endif
! recompute : variable
if (variable .eq. 'H') then
  variable = 'h'
endif
! recompute : variable
ibs = ids
! recompute : ibs
ibe = ide-1
! recompute : ibe
itf = min(ite,ide-1)
! recompute : itf
jbs = jds
! recompute : jbs
jbe = jde-1
! recompute : jbe
jtf = min(jte,jde-1)
! recompute : jtf
ktf = kde-1
! recompute : ktf
if (variable .eq. 'u') then
  ibe = ide
endif
! recompute : ibe
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
! recompute : itf
if (variable .eq. 'v') then
  jbe = jde
endif
! recompute : jbe
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
! recompute : jtf
if (variable .eq. 'm') then
  ktf = kte
endif
! recompute : ktf
if (variable .eq. 'h') then
  ktf = kte
endif
! recompute : ktf
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_field_bdy_tend(j,k,b_dist+1,p_xeb) = a_field_bdy_tend(j,k,b_dist+1,p_xeb)+a_field_tend(i,k,j)
        a_field_tend(i,k,j) = 0.
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_field_bdy_tend(j,k,b_dist+1,p_xsb) = a_field_bdy_tend(j,k,b_dist+1,p_xsb)+a_field_tend(i,k,j)
        a_field_tend(i,k,j) = 0.
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_field_bdy_tend(i,k,b_dist+1,p_yeb) = a_field_bdy_tend(i,k,b_dist+1,p_yeb)+a_field_tend(i,k,j)
        a_field_tend(i,k,j) = 0.
      end do
    end do
  end do
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_field_bdy_tend(i,k,b_dist+1,p_ysb) = a_field_bdy_tend(i,k,b_dist+1,p_ysb)+a_field_tend(i,k,j)
        a_field_tend(i,k,j) = 0.
      end do
    end do
  end do
endif

end subroutine a_spec_bdytend


subroutine a_spec_bdyupdate( a_field, a_field_tend, dt, variable_in, spec_zone, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, &
&kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dt
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
variable = variable_in
! recompute : variable
if (variable .eq. 'U') then
  variable = 'u'
endif
! recompute : variable
if (variable .eq. 'V') then
  variable = 'v'
endif
! recompute : variable
if (variable .eq. 'M') then
  variable = 'm'
endif
! recompute : variable
if (variable .eq. 'H') then
  variable = 'h'
endif
! recompute : variable
ibs = ids
! recompute : ibs
ibe = ide-1
! recompute : ibe
itf = min(ite,ide-1)
! recompute : itf
jbs = jds
! recompute : jbs
jbe = jde-1
! recompute : jbe
jtf = min(jte,jde-1)
! recompute : jtf
ktf = kde-1
! recompute : ktf
if (variable .eq. 'u') then
  ibe = ide
endif
! recompute : ibe
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
! recompute : itf
if (variable .eq. 'v') then
  jbe = jde
endif
! recompute : jbe
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
! recompute : jtf
if (variable .eq. 'm') then
  ktf = kte
endif
! recompute : ktf
if (variable .eq. 'h') then
  ktf = kte
endif
! recompute : ktf
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*dt
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*dt
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*dt
      end do
    end do
  end do
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*dt
      end do
    end do
  end do
endif

end subroutine a_spec_bdyupdate


end module     a_module_bc


