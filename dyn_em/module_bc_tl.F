!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.22
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_module_bc
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.22  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_configure
use module_wrf_error
use module_bc

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains
subroutine g_relax_bdytend( field, g_field, field_tend, g_field_tend, field_bdy, g_field_bdy, field_bdy_tend, g_field_bdy_tend, &
&variable_in, spec_bdy_width, spec_zone, relax_zone, dtbc, fcx, gcx, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, &
&kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: dtbc
integer, intent(in) :: spec_bdy_width
real, intent(in) :: fcx(spec_bdy_width)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(in) :: field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(in) :: field_bdy(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_field_bdy(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: g_field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: gcx(spec_bdy_width)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: relax_zone
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
real fls0
real fls1
real fls2
real fls3
real fls4
real g_fls0
real g_fls1
real g_fls2
real g_fls3
real g_fls4
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
variable = variable_in
if (variable .eq. 'U') then
  variable = 'u'
endif
if (variable .eq. 'V') then
  variable = 'v'
endif
if (variable .eq. 'M') then
  variable = 'm'
endif
if (variable .eq. 'H') then
  variable = 'h'
endif
ibs = ids
ibe = ide-1
itf = min(ite,ide-1)
jbs = jds
jbe = jde-1
jtf = min(jte,jde-1)
ktf = kde-1
if (variable .eq. 'u') then
  ibe = ide
endif
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
if (variable .eq. 'v') then
  jbe = jde
endif
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
if (variable .eq. 'm') then
  ktf = kte
endif
if (variable .eq. 'h') then
  ktf = kte
endif
if (jts-jbs .lt. relax_zone) then
  do j = max(jts,jbs+spec_zone), min(jtf,jbs+relax_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_fls0 = (-g_field(i,k,j))+g_field_bdy(i,k,b_dist+1,p_ysb)+g_field_bdy_tend(i,k,b_dist+1,p_ysb)*dtbc
        fls0 = field_bdy(i,k,b_dist+1,p_ysb)+dtbc*field_bdy_tend(i,k,b_dist+1,p_ysb)-field(i,k,j)
        g_fls1 = (-g_field(i-1,k,j))+g_field_bdy(i-1,k,b_dist+1,p_ysb)+g_field_bdy_tend(i-1,k,b_dist+1,p_ysb)*dtbc
        fls1 = field_bdy(i-1,k,b_dist+1,p_ysb)+dtbc*field_bdy_tend(i-1,k,b_dist+1,p_ysb)-field(i-1,k,j)
        g_fls2 = (-g_field(i+1,k,j))+g_field_bdy(i+1,k,b_dist+1,p_ysb)+g_field_bdy_tend(i+1,k,b_dist+1,p_ysb)*dtbc
        fls2 = field_bdy(i+1,k,b_dist+1,p_ysb)+dtbc*field_bdy_tend(i+1,k,b_dist+1,p_ysb)-field(i+1,k,j)
        g_fls3 = (-g_field(i,k,j-1))+g_field_bdy(i,k,b_dist,p_ysb)+g_field_bdy_tend(i,k,b_dist,p_ysb)*dtbc
        fls3 = field_bdy(i,k,b_dist,p_ysb)+dtbc*field_bdy_tend(i,k,b_dist,p_ysb)-field(i,k,j-1)
        g_fls4 = (-g_field(i,k,j+1))+g_field_bdy(i,k,b_dist+2,p_ysb)+g_field_bdy_tend(i,k,b_dist+2,p_ysb)*dtbc
        fls4 = field_bdy(i,k,b_dist+2,p_ysb)+dtbc*field_bdy_tend(i,k,b_dist+2,p_ysb)-field(i,k,j+1)
        g_field_tend(i,k,j) = g_field_tend(i,k,j)+g_fls0*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))-g_fls1*gcx(b_dist+1)-g_fls2*gcx(b_dist+&
&1)-g_fls3*gcx(b_dist+1)-g_fls4*gcx(b_dist+1)
        field_tend(i,k,j) = field_tend(i,k,j)+fcx(b_dist+1)*fls0-gcx(b_dist+1)*(fls1+fls2+fls3+fls4-4.*fls0)
      end do
    end do
  end do
endif
if (jbe-jtf .lt. relax_zone) then
  do j = max(jts,jbe-relax_zone+1), min(jtf,jbe-spec_zone)
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_fls0 = (-g_field(i,k,j))+g_field_bdy(i,k,b_dist+1,p_yeb)+g_field_bdy_tend(i,k,b_dist+1,p_yeb)*dtbc
        fls0 = field_bdy(i,k,b_dist+1,p_yeb)+dtbc*field_bdy_tend(i,k,b_dist+1,p_yeb)-field(i,k,j)
        g_fls1 = (-g_field(i-1,k,j))+g_field_bdy(i-1,k,b_dist+1,p_yeb)+g_field_bdy_tend(i-1,k,b_dist+1,p_yeb)*dtbc
        fls1 = field_bdy(i-1,k,b_dist+1,p_yeb)+dtbc*field_bdy_tend(i-1,k,b_dist+1,p_yeb)-field(i-1,k,j)
        g_fls2 = (-g_field(i+1,k,j))+g_field_bdy(i+1,k,b_dist+1,p_yeb)+g_field_bdy_tend(i+1,k,b_dist+1,p_yeb)*dtbc
        fls2 = field_bdy(i+1,k,b_dist+1,p_yeb)+dtbc*field_bdy_tend(i+1,k,b_dist+1,p_yeb)-field(i+1,k,j)
        g_fls3 = (-g_field(i,k,j+1))+g_field_bdy(i,k,b_dist,p_yeb)+g_field_bdy_tend(i,k,b_dist,p_yeb)*dtbc
        fls3 = field_bdy(i,k,b_dist,p_yeb)+dtbc*field_bdy_tend(i,k,b_dist,p_yeb)-field(i,k,j+1)
        g_fls4 = (-g_field(i,k,j-1))+g_field_bdy(i,k,b_dist+2,p_yeb)+g_field_bdy_tend(i,k,b_dist+2,p_yeb)*dtbc
        fls4 = field_bdy(i,k,b_dist+2,p_yeb)+dtbc*field_bdy_tend(i,k,b_dist+2,p_yeb)-field(i,k,j-1)
        g_field_tend(i,k,j) = g_field_tend(i,k,j)+g_fls0*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))-g_fls1*gcx(b_dist+1)-g_fls2*gcx(b_dist+&
&1)-g_fls3*gcx(b_dist+1)-g_fls4*gcx(b_dist+1)
        field_tend(i,k,j) = field_tend(i,k,j)+fcx(b_dist+1)*fls0-gcx(b_dist+1)*(fls1+fls2+fls3+fls4-4.*fls0)
      end do
    end do
  end do
endif
if (its-ibs .lt. relax_zone) then
  do i = max(its,ibs+spec_zone), min(itf,ibs+relax_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_fls0 = (-g_field(i,k,j))+g_field_bdy(j,k,b_dist+1,p_xsb)+g_field_bdy_tend(j,k,b_dist+1,p_xsb)*dtbc
        fls0 = field_bdy(j,k,b_dist+1,p_xsb)+dtbc*field_bdy_tend(j,k,b_dist+1,p_xsb)-field(i,k,j)
        g_fls1 = (-g_field(i,k,j-1))+g_field_bdy(j-1,k,b_dist+1,p_xsb)+g_field_bdy_tend(j-1,k,b_dist+1,p_xsb)*dtbc
        fls1 = field_bdy(j-1,k,b_dist+1,p_xsb)+dtbc*field_bdy_tend(j-1,k,b_dist+1,p_xsb)-field(i,k,j-1)
        g_fls2 = (-g_field(i,k,j+1))+g_field_bdy(j+1,k,b_dist+1,p_xsb)+g_field_bdy_tend(j+1,k,b_dist+1,p_xsb)*dtbc
        fls2 = field_bdy(j+1,k,b_dist+1,p_xsb)+dtbc*field_bdy_tend(j+1,k,b_dist+1,p_xsb)-field(i,k,j+1)
        g_fls3 = (-g_field(i-1,k,j))+g_field_bdy(j,k,b_dist,p_xsb)+g_field_bdy_tend(j,k,b_dist,p_xsb)*dtbc
        fls3 = field_bdy(j,k,b_dist,p_xsb)+dtbc*field_bdy_tend(j,k,b_dist,p_xsb)-field(i-1,k,j)
        g_fls4 = (-g_field(i+1,k,j))+g_field_bdy(j,k,b_dist+2,p_xsb)+g_field_bdy_tend(j,k,b_dist+2,p_xsb)*dtbc
        fls4 = field_bdy(j,k,b_dist+2,p_xsb)+dtbc*field_bdy_tend(j,k,b_dist+2,p_xsb)-field(i+1,k,j)
        g_field_tend(i,k,j) = g_field_tend(i,k,j)+g_fls0*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))-g_fls1*gcx(b_dist+1)-g_fls2*gcx(b_dist+&
&1)-g_fls3*gcx(b_dist+1)-g_fls4*gcx(b_dist+1)
        field_tend(i,k,j) = field_tend(i,k,j)+fcx(b_dist+1)*fls0-gcx(b_dist+1)*(fls1+fls2+fls3+fls4-4.*fls0)
      end do
    end do
  end do
endif
if (ibe-itf .lt. relax_zone) then
  do i = max(its,ibe-relax_zone+1), min(itf,ibe-spec_zone)
    b_dist = ibe-i
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_fls0 = (-g_field(i,k,j))+g_field_bdy(j,k,b_dist+1,p_xeb)+g_field_bdy_tend(j,k,b_dist+1,p_xeb)*dtbc
        fls0 = field_bdy(j,k,b_dist+1,p_xeb)+dtbc*field_bdy_tend(j,k,b_dist+1,p_xeb)-field(i,k,j)
        g_fls1 = (-g_field(i,k,j-1))+g_field_bdy(j-1,k,b_dist+1,p_xeb)+g_field_bdy_tend(j-1,k,b_dist+1,p_xeb)*dtbc
        fls1 = field_bdy(j-1,k,b_dist+1,p_xeb)+dtbc*field_bdy_tend(j-1,k,b_dist+1,p_xeb)-field(i,k,j-1)
        g_fls2 = (-g_field(i,k,j+1))+g_field_bdy(j+1,k,b_dist+1,p_xeb)+g_field_bdy_tend(j+1,k,b_dist+1,p_xeb)*dtbc
        fls2 = field_bdy(j+1,k,b_dist+1,p_xeb)+dtbc*field_bdy_tend(j+1,k,b_dist+1,p_xeb)-field(i,k,j+1)
        g_fls3 = (-g_field(i+1,k,j))+g_field_bdy(j,k,b_dist,p_xeb)+g_field_bdy_tend(j,k,b_dist,p_xeb)*dtbc
        fls3 = field_bdy(j,k,b_dist,p_xeb)+dtbc*field_bdy_tend(j,k,b_dist,p_xeb)-field(i+1,k,j)
        g_fls4 = (-g_field(i-1,k,j))+g_field_bdy(j,k,b_dist+2,p_xeb)+g_field_bdy_tend(j,k,b_dist+2,p_xeb)*dtbc
        fls4 = field_bdy(j,k,b_dist+2,p_xeb)+dtbc*field_bdy_tend(j,k,b_dist+2,p_xeb)-field(i-1,k,j)
        g_field_tend(i,k,j) = g_field_tend(i,k,j)+g_fls0*(fcx(b_dist+1)-(-4)*gcx(b_dist+1))-g_fls1*gcx(b_dist+1)-g_fls2*gcx(b_dist+&
&1)-g_fls3*gcx(b_dist+1)-g_fls4*gcx(b_dist+1)
        field_tend(i,k,j) = field_tend(i,k,j)+fcx(b_dist+1)*fls0-gcx(b_dist+1)*(fls1+fls2+fls3+fls4-4.*fls0)
      end do
    end do
  end do
endif

end subroutine g_relax_bdytend


subroutine g_spec_bdytend( field_tend, g_field_tend, field_bdy_tend, g_field_bdy_tend, variable_in, spec_bdy_width, spec_zone, &
&ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
integer, intent(in) :: spec_bdy_width
real, intent(in) :: field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(out) :: field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_field_bdy_tend(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(out) :: g_field_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
variable = variable_in
if (variable .eq. 'U') then
  variable = 'u'
endif
if (variable .eq. 'V') then
  variable = 'v'
endif
if (variable .eq. 'M') then
  variable = 'm'
endif
if (variable .eq. 'H') then
  variable = 'h'
endif
ibs = ids
ibe = ide-1
itf = min(ite,ide-1)
jbs = jds
jbe = jde-1
jtf = min(jte,jde-1)
ktf = kde-1
if (variable .eq. 'u') then
  ibe = ide
endif
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
if (variable .eq. 'v') then
  jbe = jde
endif
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
if (variable .eq. 'm') then
  ktf = kte
endif
if (variable .eq. 'h') then
  ktf = kte
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_field_tend(i,k,j) = g_field_bdy_tend(i,k,b_dist+1,p_ysb)
        field_tend(i,k,j) = field_bdy_tend(i,k,b_dist+1,p_ysb)
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_field_tend(i,k,j) = g_field_bdy_tend(i,k,b_dist+1,p_yeb)
        field_tend(i,k,j) = field_bdy_tend(i,k,b_dist+1,p_yeb)
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_field_tend(i,k,j) = g_field_bdy_tend(j,k,b_dist+1,p_xsb)
        field_tend(i,k,j) = field_bdy_tend(j,k,b_dist+1,p_xsb)
      end do
    end do
  end do
endif
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_field_tend(i,k,j) = g_field_bdy_tend(j,k,b_dist+1,p_xeb)
        field_tend(i,k,j) = field_bdy_tend(j,k,b_dist+1,p_xeb)
      end do
    end do
  end do
endif

end subroutine g_spec_bdytend


subroutine g_spec_bdyupdate( field, g_field, field_tend, g_field_tend, dt, variable_in, spec_zone, ids, ide, jds, jde, kde, ims, &
&ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: dt
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: field_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_field_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
variable = variable_in
if (variable .eq. 'U') then
  variable = 'u'
endif
if (variable .eq. 'V') then
  variable = 'v'
endif
if (variable .eq. 'M') then
  variable = 'm'
endif
if (variable .eq. 'H') then
  variable = 'h'
endif
ibs = ids
ibe = ide-1
itf = min(ite,ide-1)
jbs = jds
jbe = jde-1
jtf = min(jte,jde-1)
ktf = kde-1
if (variable .eq. 'u') then
  ibe = ide
endif
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
if (variable .eq. 'v') then
  jbe = jde
endif
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
if (variable .eq. 'm') then
  ktf = kte
endif
if (variable .eq. 'h') then
  ktf = kte
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_field(i,k,j) = g_field(i,k,j)+g_field_tend(i,k,j)*dt
        field(i,k,j) = field(i,k,j)+dt*field_tend(i,k,j)
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_field(i,k,j) = g_field(i,k,j)+g_field_tend(i,k,j)*dt
        field(i,k,j) = field(i,k,j)+dt*field_tend(i,k,j)
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_field(i,k,j) = g_field(i,k,j)+g_field_tend(i,k,j)*dt
        field(i,k,j) = field(i,k,j)+dt*field_tend(i,k,j)
      end do
    end do
  end do
endif
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_field(i,k,j) = g_field(i,k,j)+g_field_tend(i,k,j)*dt
        field(i,k,j) = field(i,k,j)+dt*field_tend(i,k,j)
      end do
    end do
  end do
endif

end subroutine g_spec_bdyupdate


subroutine g_zero_grad_bdy( field, g_field, variable_in, spec_zone, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, &
&ite, jts, jte, kts )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.22  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kts
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
integer i
integer i_inner
integer ibe
integer ibs
integer itf
integer j
integer j_inner
integer jbe
integer jbs
integer jtf
integer k
integer ktf
character variable

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
variable = variable_in
if (variable .eq. 'U') then
  variable = 'u'
endif
if (variable .eq. 'V') then
  variable = 'v'
endif
ibs = ids
ibe = ide-1
itf = min(ite,ide-1)
jbs = jds
jbe = jde-1
jtf = min(jte,jde-1)
ktf = kde-1
if (variable .eq. 'u') then
  ibe = ide
endif
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
if (variable .eq. 'v') then
  jbe = jde
endif
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
if (variable .eq. 'w') then
  ktf = kde
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        i_inner = max(i,ibs+spec_zone)
        i_inner = min(i_inner,ibe-spec_zone)
        g_field(i,k,j) = g_field(i_inner,k,jbs+spec_zone)
        field(i,k,j) = field(i_inner,k,jbs+spec_zone)
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        i_inner = max(i,ibs+spec_zone)
        i_inner = min(i_inner,ibe-spec_zone)
        g_field(i,k,j) = g_field(i_inner,k,jbe-spec_zone)
        field(i,k,j) = field(i_inner,k,jbe-spec_zone)
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        j_inner = max(j,jbs+spec_zone)
        j_inner = min(j_inner,jbe-spec_zone)
        g_field(i,k,j) = g_field(ibs+spec_zone,k,j_inner)
        field(i,k,j) = field(ibs+spec_zone,k,j_inner)
      end do
    end do
  end do
endif
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        j_inner = max(j,jbs+spec_zone)
        j_inner = min(j_inner,jbe-spec_zone)
        g_field(i,k,j) = g_field(ibe-spec_zone,k,j_inner)
        field(i,k,j) = field(ibe-spec_zone,k,j_inner)
      end do
    end do
  end do
endif

end subroutine g_zero_grad_bdy


end module     g_module_bc


