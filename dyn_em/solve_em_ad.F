!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!***********************************************************
!***********************************************************

! program history log:
! 2005-xx-xx generated by TAF
! 2005-06-08 Qingnong Xiao and Zaizhong Ma  - revised and tested 
! 2008-05-xx Wei Huang   - change from static(stack) to dynamic
!                          in order to save compuational cost of the solve_em_ad.F
! 2008-08-18 Zaizhong Ma - finish adjoint check of simplified code
! 2008-08-19 Xin Zhang and Zaizhong Ma - make parallel 
! 2009-12-28 Hongli Wang - finish the Kessler warm rain scheme
!***********************************************************
!***********************************************************
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!WRF:MEDIATION_LAYER:SOLVER

SUBROUTINE solve_em_ad ( grid , config_flags , &
!
#include "em_dummy_args.inc"
!
                 )

! Driver layer modules
   USE module_domain
   USE module_configure
   USE module_driver_constants
   USE module_machine
   USE module_tiles
   USE module_dm
! Mediation layer modules
! Model layer modules
   USE module_model_constants
   USE module_small_step_em
   USE module_em
   USE module_big_step_utilities_em
   USE module_bc_em
   USE module_solvedebug_em
   USE module_physics_addtendc
   USE module_diffusion_em
! Registry generated module
   USE module_state_description
   USE module_radiation_driver
   USE module_surface_driver
   USE module_cumulus_driver
   USE module_cu_du , only : DUCU_B, DUCU  !Xiaoyan Zhang 12 July, 2007
   USE module_microphysics_driver
   USE module_pbl_driver
   USE module_mp_nconvp   !Xiaoyan Zhang
   USE module_mp_kessler_db  
#ifdef WRF_CHEM
   USE module_input_chem_data
#endif

   USE a_module_small_step_em
   USE a_module_em
   USE a_module_big_step_utilities_em
   USE a_module_bc
   USE a_module_bc_em
   USE a_module_diffusion_em

   USE module_linked_list2

   USE module_trace, only : trace_entry, trace_exit

   IMPLICIT NONE

   !  Input data.

   TYPE(domain) , TARGET          :: grid

   !  Definitions of dummy arguments to solve
#include <em_dummy_decl.inc>

   !  WRF state bcs
   TYPE (grid_config_rec_type) , INTENT(IN)          :: config_flags

   ! WRF state data

   ! Local data

   INTEGER                         :: k_start , k_end, its, ite, jts, jte
   INTEGER                         :: ids , ide , jds , jde , kds , kde , &
                                      ims , ime , jms , jme , kms , kme , &
                                      ips , ipe , jps , jpe , kps , kpe
   INTEGER                         :: i, j, k, ij , iteration
   INTEGER                         :: im , num_3d_m , ic , num_3d_c
   INTEGER                         :: ijds, ijde
   INTEGER                         :: itmpstep
   INTEGER                         :: sz

! storage for tendencies and decoupled state (generated from Registry)
#include <em_i1_decl.inc>

   INTEGER :: number_of_small_timesteps, rk_step
   INTEGER :: rk_order
   REAL    :: dt_rk, dts_rk, dtm
   LOGICAL :: leapfrog
   LOGICAL ::  solverDisabled  ! 091012 bp; aix allowed declaration after statements; correcting for PGI

real, DIMENSION(max(grid%ed31,grid%ed33),grid%sd32:grid%ed32,grid%spec_bdy_width,4) :: a_rqc_bth
real, DIMENSION(max(grid%ed31,grid%ed33),grid%sd32:grid%ed32,grid%spec_bdy_width,4) :: a_rqr_bth
real, DIMENSION(max(grid%ed31,grid%ed33),grid%sd32:grid%ed32,grid%spec_bdy_width,4) :: a_rqi_bth
real, DIMENSION(max(grid%ed31,grid%ed33),grid%sd32:grid%ed32,grid%spec_bdy_width,4) :: a_rqs_bth
real, DIMENSION(max(grid%ed31,grid%ed33),grid%sd32:grid%ed32,grid%spec_bdy_width,4) :: a_rqg_bth

!----------------------------------------------------------------------------------------

!Xiaoyan Zhang add
!  real, DIMENSION(grid%sm31:grid%em31,grid%sm32:grid%em32,grid%sm33:grid%em33) :: a_h_diabatic
!  real, DIMENSION(grid%sm31:grid%em31,grid%sm33:grid%em33)                     :: a_rainnc
!  real, DIMENSION(grid%sm31:grid%em31,grid%sm33:grid%em33)                     :: a_rainncv
!  real, DIMENSION(grid%sm31:grid%em31,grid%sm33:grid%em33)                     :: a_rainc
!  real, DIMENSION(grid%sm31:grid%em31,grid%sm33:grid%em33)                     :: a_raincv
   real, DIMENSION(grid%sm31:grid%em31,grid%sm32:grid%em32,grid%sm33:grid%em33) :: a_rqvcuten
   real, DIMENSION(grid%sm31:grid%em31,grid%sm32:grid%em32,grid%sm33:grid%em33) :: a_rthcuten

#ifdef DEREF_KLUDGE
   INTEGER     :: sm31 , em31 , sm32 , em32 , sm33 , em33
   INTEGER     :: sm31x, em31x, sm32x, em32x, sm33x, em33x
   INTEGER     :: sm31y, em31y, sm32y, em32y, sm33y, em33y
#endif

#include "deref_kludge.h"

   
#define COPY_IN
#include <em_scalar_derefs.inc>
#ifdef DM_PARALLEL
#    define REGISTER_I1
#      include <em_data_calls.inc>
#endif

!<DESCRIPTION>
!<pre>
! solve_em is the main driver for advancing a grid a single timestep.
! It is a mediation-layer routine -> DM and SM calls are made where 
! needed for parallel processing.  
!
! solve_em can integrate the equations using 3 time-integration methods
!      
!    - 3rd order Runge-Kutta time integration (recommended)
!      
!    - 2nd order Runge-Kutta time integration
!      
!    - Leapfrog time integration
!      (note: the leapfrog scheme is not correctly implemented
!      for most of the physics)
!
! The main sections of solve_em are
!     
! (1) Runge-Kutta (RK) loop
!     
! (2) Non-timesplit physics (i.e., tendencies computed for updating
!     model state variables during the first RK sub-step (loop)
!     
! (3) Small (acoustic, sound) timestep loop - within the RK sub-steps
!     
! (4) Scalar advance for moist and chem scalar variables (and TKE)
!     within the RK sub-steps.
!     
! (5) time-split physics (after the RK step), currently this includes
!     only microphyics
!
! A more detailed description of these sections follows.
!</pre>
!</DESCRIPTION>

   if(grid%trace_use) call trace_entry("solve_em_ad")

   ! 090921 bp; 
   solverDisabled = .false.
   call nl_get_disable_solver( 1, solverDisabled )
   if(solverDisabled) then
      return
   endif

   CALL wrf_debug ( 10 , 'DEBUG:  begin solve_em_ad()' )
   CALL linkedlist_initialize

!  call check_linkedlist

   call get_ijk_from_grid( grid,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,ips,ipe,jps,jpe,kps,kpe )

   ij = 1

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
    a_a = 0.0
    a_advect_tend = 0.0
    a_alpha = 0.0
    a_bn2 = 0.0
    a_c2a = 0.0
    a_cqu = 0.0
    a_cqv = 0.0
    a_cqw = 0.0
    a_gamma = 0.0
    a_moist_tend = 0.0
    a_mu_save = 0.0
    a_mu_tend = 0.0
    a_muave = 0.0
    a_mut = 0.0
    a_muts = 0.0
    a_muu = 0.0
    a_muus = 0.0
    a_muv = 0.0
    a_muvs = 0.0
    a_p8w = 0.0
    a_p_phy = 0.0
    a_ph_save = 0.0
    a_ph_tend = 0.0
    a_ph_tendf = 0.0
    a_pi_phy = 0.0
    a_pm1 = 0.0
    a_rqc_bth = 0.0
    a_rqg_bth = 0.0
    a_rqi_bth = 0.0
    a_rqr_bth = 0.0
    a_rqs_bth = 0.0
    a_ru_m = 0.0
    a_ru_tend = 0.0
    a_ru_tendf = 0.0
    a_rv_m = 0.0
    a_rv_tend = 0.0
    a_rv_tendf = 0.0
    a_rw_tend = 0.0
    a_rw_tendf = 0.0
    a_t8w = 0.0
    a_t_2save = 0.0
    a_t_phy = 0.0
    a_t_save = 0.0
    a_t_tend = 0.0
    a_t_tendf = 0.0
    a_th_phy = 0.0
    a_u_save = 0.0
    a_v_save = 0.0
    a_w_save = 0.0
    a_ww1 = 0.0
    a_ww_m = 0.0
    a_z_at_w = 0.0
    a_rqvcuten = 0.0
    a_rthcuten = 0.0
    a_php = 0.0
!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
cfn = grid%cfn
cfn1 = grid%cfn1
epsts = grid%epsts
step_number = grid%step_number
rdx = grid%rdx
rdy = grid%rdy
cf1 = grid%cf1
cf2 = grid%cf2
cf3 = grid%cf3
dtbc = grid%dtbc
dx = grid%dx
dy = grid%dy
dt = grid%dt
rk_ord = grid%rk_ord
diff_opt = grid%diff_opt
damp_opt = grid%damp_opt
zdamp = grid%zdamp
dampcoef = grid%dampcoef
khdif = grid%khdif
kvdif = grid%kvdif
smdiv = grid%smdiv
emdiv = grid%emdiv
epssm = grid%epssm

non_hydrostatic = grid%non_hydrostatic
time_step_sound = grid%time_step_sound
kh_tke_upper_bound = grid%kh_tke_upper_bound
spec_bdy_width = grid%spec_bdy_width
spec_zone = grid%spec_zone
relax_zone = grid%relax_zone

k_start = kps
k_end = kpe
ijds = min(ids,jds)
ijde = max(ide,jde)

num_3d_m = num_moist
num_3d_c = 1

  call set_tiles( grid,ids,ide,jds,jde,ips,ipe,jps,jpe )
  if ( grid%num_tiles > 1 ) call wrf_error_fatal( "Adjoint code is not thread safe" )

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#   include "HALO_EM_INIT_1.inc"
#   include "HALO_EM_INIT_2.inc"
#   include "HALO_EM_INIT_3.inc"
#   include "HALO_EM_INIT_4.inc"
#   include "HALO_EM_INIT_5.inc"
#   include "HALO_EM_AD_INIT_1.inc"
#   include "HALO_EM_AD_INIT_2.inc"
#   include "HALO_EM_AD_INIT_3.inc"
#   include "HALO_EM_AD_INIT_5.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  rk_order = config_flags%rk_ord

  leapfrog =  .false. 

  dts = dt/float(time_step_sound)

  if (rk_ord .eq. 1) then
    leapfrog =  .true. 
  endif

!-if(grid%trace_use) call trace_entry("solve_ad_runge_kutta_looq")
!------------------------------
 runge_kutta_looq: do rk_step = 1, rk_order
  dtm=dt
  if (rk_order .eq. 1) then
    if (step_number .ne. 1) then
      number_of_small_timesteps = 2*time_step_sound
      dt_rk = dt
      dtm=2*dt
    else
      number_of_small_timesteps = time_step_sound
      dt_rk = dt/2.
      dtm=dt
    endif
    dts_rk = dts
  else if (rk_order .eq. 2) then
    if (rk_step .eq. 1) then
      dt_rk = 0.5*dt
      dts_rk = dts
      number_of_small_timesteps = time_step_sound/2
    else
      dt_rk = dt
      dts_rk = dts
      number_of_small_timesteps = time_step_sound
    endif
  else if (rk_order .eq. 3) then
    if (rk_step .eq. 1) then
      dt_rk = dt/3.
      dts_rk = dt_rk
      number_of_small_timesteps = 1
    else if (rk_step .eq. 2) then
      dt_rk = 0.5*dt
      dts_rk = dts
      number_of_small_timesteps = time_step_sound/2
    else
      dt_rk = dt
      dts_rk = dts
      number_of_small_timesteps = time_step_sound
    endif
  endif

!---Save for rk_step_prep
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(muu,muv,mub,mut, "muu,muv,mub,mut")
    call push4backup(u_2,v_2,w_2,t_2,ph_2,p,al, "u_2,v_2,w_2,t_2,ph_2,p,al")
    call push4backup(mu_2, "mu_2")
    call push4backup(moist_2, "moist_2")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_em.F
    call rk_step_prep( config_flags,rk_step,u_2,v_2,w_2,t_2,ph_2,mu_2,moist_2, &
                       ru,rv,rw,ww,php,alt,muu,muv,mub,mut,phb,pb,p,al,alb,&
                       cqu,cqv,cqw,msfu,msfv,msft,fnm,fnp,dnw,rdx,rdy,num_3d_m, &
                       ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                       grid%i_start(ij),grid%i_end(ij), &
                       grid%j_start(ij),grid%j_end(ij), &
                       k_start,k_end )

!-----Output: ru,rv,rw,ww,php,cqu,cqv,cqw,alt,muu,muv,mut

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RK_STEP_PREP.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  rk_step_is_ong: if (rk_step .eq. 1) then

  call init_zero_tendency( ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf,tke_tend,moist_tend,chem_tend, &
                           num_3d_m,num_3d_c,rk_step,&
                           ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                           grid%i_start(ij),grid%i_end(ij), &
                           grid%j_start(ij),grid%j_end(ij), &
                           k_start,k_end )

!-Save for: phy_prep:
  if(grid%trace_use) call trace_entry("backup")
  call push4backup(p, u_2, v_2, alt, ph_2, t_2, "p, u_2, v_2, alt, ph_2, t_2")
  call push4backup(tsk, mut, "tsk, mut")
  call push4backup(z,z_at_w, "z,z_at_w")
  call push4backup(th_phy,p_phy,pi_phy,t_phy, "th_phy,p_phy,pi_phy,t_phy")
  if(grid%trace_use) call trace_exit("backup")

!-From module_big_step_utilities_em.F
  call phy_prep( config_flags,mut,u_2,v_2,p,pb,alt,ph_2,phb,t_2,tsk,moist_2,num_3d_m,mu_3d,rho, &
                 th_phy,p_phy,pi_phy,u_phy,v_phy,p8w,t_phy,t8w,z,z_at_w,dz8w,fnm,fnp, &
                 rthraten,rthblten,rublten,rvblten,rqvblten,rqcblten,rqiblten,rthcuten, &
                 rqvcuten,rqccuten,rqrcuten,rqicuten,rqscuten,rthften,rqvften, &
                 ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                 grid%i_start(ij),grid%i_end(ij), &
                 grid%j_start(ij),grid%j_end(ij), &
                 k_start,k_end )

!-Output: th_phy,p_phy,pi_phy,u_phy,v_phy,p8w,t_phy,t8w,z,z_at_w,dz8w,mu_3d,rho
!         rthraten,rthblten,rublten,rvblten,rqvblten,rqcblten,rqiblten,rthcuten
!         rqvcuten,rqccuten,rqrcuten,rqicuten,rqscuten,rthften,rqvften

#ifdef DM_PARALLEL
  if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_PHY_PREP.inc"
  if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  if (diff_opt .eq. 2 .or. diff_opt .eq. 1) then
!---Save for calculate_km_kh:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(xkmh,xkmhd,xkmv,xkhh,xkhv,bn2, "xkmh,xkmhd,xkmv,xkhh,xkhv,bn2")
    call push4backup(defor11,defor22,defor33,defor12,defor13,defor23, &
                    "defor11,defor22,defor33,defor12,defor13,defor23")
    call push4backup(div,tke_2,p8w,t8w,th_phy,t_phy,p_phy,rdz,rdzw, &
                    "div,tke_2,p8w,t8w,th_phy,t_phy,p_phy,rdz,rdzw")
    call push4backup(moist_2, "moist_2")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_diffusion_em.F
    call calculate_km_kh( config_flags,dt,dampcoef,zdamp,damp_opt,xkmh,xkmhd,xkmv,xkhh,xkhv,bn2, &
                          khdif,kvdif,div,defor11,defor22,defor33,defor12,defor13,defor23, &
                          tke_2,p8w,t8w,th_phy,t_phy,p_phy,moist_2,dn,dnw,dx,dy,rdz,rdzw, &
                          mix_cr_len,num_3d_m,cf1,cf2,cf3,warm_rain,kh_tke_upper_bound,kv_tke_upper_bound, &
                          ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                          grid%i_start(ij),grid%i_end(ij), &
                          grid%j_start(ij),grid%j_end(ij), &
                          k_start,k_end )

!---Output: moist_2, xkmv, xkmh, xkmhd, xkhv, xkhh, bn2, tke_2

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALCULATE_KM_KH.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  endif

  endif rk_step_is_ong

!---Save for rk_tendency
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(u_2,v_2,w_2,t_2,ph_2,u_1,v_1,w_1,t_1,ph_1, &
                    "u_2,v_2,w_2,t_2,ph_2,u_1,v_1,w_1,t_1,ph_1")
    call push4backup(ru,rv,rw,ww,t_init,al,alt,p, &
                    "ru,rv,rw,ww,t_init,al,alt,p")
    call push4backup(cqu,cqv,cqw,xkmhd,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf, &
                    "cqu,cqv,cqw,xkmhd,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf")
    call push4backup(mu_2,mut,muu,muv, "mu_2,mut,muu,muv")
!    call push4backup(php, "php")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_em.F
    call rk_tendency( config_flags,rk_step,ru_tend,rv_tend,rw_tend,ph_tend,t_tend, &
                      ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf,mu_tend, &
                      u_save,v_save,w_save,ph_save,t_save,mu_save,rthften,ru,rv,rw,ww, &
                      u_2,v_2,w_2,t_2,ph_2,u_1,v_1,w_1,t_1,ph_1,h_diabatic,phb,t_init, &
                      mu_2,mut,muu,muv,mub,al,alt,p,pb,php,cqu,cqv,cqw, &
                      u_base,v_base,t_base,qv_base,z_base, &
                      msfu,msfv,msft,f,e,sina,cosa,fnm,fnp,rdn,rdnw,dt,rdx,rdy, &
                      khdif,kvdif,xkmhd,cf1,cf2,cf3,cfn,cfn1,num_3d_m,non_hydrostatic,leapfrog, &
                      ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                      grid%i_start(ij),grid%i_end(ij), &
                      grid%j_start(ij),grid%j_end(ij), &
                      k_start,k_end )

!-----Output: ru_tend,rv_tend,rw_tend,ph_tend,t_tend,rthften
!             u_save,v_save,w_save,ph_save,t_save,mu_save
!             ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf,mu_tend,cqw

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RK_TENDENCY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!  IF (rk_step == 1 ) then
!
!    if(grid%trace_use) call trace_entry("backup")
!    call push4backup(z, "z")
!    call push4backup(ru_tendf,rv_tendf,u_2,v_2,z_at_w, "ru_tendf,rv_tendf,u_2,v_2,z_at_w")
!    call push4backup(muu,muv, "muu,muv")
!    if(grid%trace_use) call trace_exit("backup")
!
!      CALL surface_drag (ru_tendf, rv_tendf, u_2, v_2, xland,             &    
!                         muu, muv,z,z_at_w,&
!                         ids, ide, jds, jde, kds, kde,                    &    
!                         ims, ime, jms, jme, kms, kme,                    &    
!                         grid%i_start(ij), grid%i_end(ij),                &    
!                         grid%j_start(ij), grid%j_end(ij),                &    
!                         k_start, k_end                                  )    
!
! ENDIF

  if( (config_flags%specified .or. config_flags%nested) .and. rk_step==1 ) then
!-----Save for relax_bdy_dry
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(ru,rv,ph_2,t_2,w_2,u_save,v_save,ph_save,t_save,w_save, &
                      "ru,rv,ph_2,t_2,w_2,u_save,v_save,ph_save,t_save,w_save")
      call push4backup(mu_2,mut,mu_tend, "mu_2,mut,mu_tend")
      if(grid%trace_use) call trace_exit("backup")

!-----From: module_bc_em.F
      call relax_bdy_dry( config_flags,u_save,v_save,ph_save,t_save,w_save,mu_tend, &
                          ru,rv,ph_2,t_2,w_2,mu_2,mut,u_b,v_b,ph_b,t_b,w_b,mu_b, &
                          u_bt,v_bt,ph_bt,t_bt,w_bt,mu_bt, &
                          spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde, &
                          ids,ide, jds,jde, kds,kde,  &
                          ims,ime, jms,jme, kms,kme,  &
                          ips,ipe, jps,jpe, kps,kpe,  &
                          grid%i_start(ij),grid%i_end(ij), &
                          grid%j_start(ij),grid%j_end(ij), &
                          k_start,k_end )

!-----Output: u_save,v_save,ph_save,t_save,w_save,mu_tend

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RELAX_BDY_DRY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  endif

!---Save for rk_addtend_dry:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(ru_tend,rv_tend,rw_tend,ph_tend,t_tend,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf, &
                    "ru_tend,rv_tend,rw_tend,ph_tend,t_tend,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf")
    call push4backup(u_save,v_save,w_save,ph_save,t_save,h_diabatic, &
                    "u_save,v_save,w_save,ph_save,t_save,h_diabatic")
    call push4backup(mut,mu_tend, "mut,mu_tend")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_em.F
    call rk_addtend_dry( ru_tend,rv_tend,rw_tend,ph_tend,t_tend, &
                         ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf, &
                         u_save,v_save,w_save,ph_save,t_save, &
                         rk_step,h_diabatic,mut,msft,msfu,msfv, &
                         ids,ide, jds,jde, kds,kde,  &
                         ims,ime, jms,jme, kms,kme,  &
                         ips,ipe, jps,jpe, kps,kpe,  &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij), &
                         k_start,k_end )

!-----Output: ru_tend,rv_tend,rw_tend,ph_tend,t_tend, ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RK_ADDTEND_DRY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

    if (config_flags%specified .or. config_flags%nested) then
!-----From: module_bc_em.F
      call spec_bdy_dry( config_flags,ru_tend,rv_tend,ph_tend,t_tend,rw_tend,mu_tend, &
                         u_b,v_b,ph_b,t_b,w_b,mu_b,u_bt,v_bt,ph_bt,t_bt,w_bt,mu_bt, &
                         spec_bdy_width,spec_zone,ijds,ijde, &
                         ids,ide, jds,jde, kds,kde,  &
                         ims,ime, jms,jme, kms,kme,  &
                         ips,ipe, jps,jpe, kps,kpe,  &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij), &
                         k_start,k_end )

!-----Output: ru_tend,rv_tend,ph_tend,t_tend,rw_tend,mu_tend

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SPEC_BDY_DRY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

!---Save for small_step_prep
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2, &
                    "u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2")
    call push4backup(p,alt,ww, "p,alt,ww,")
    call push4backup(mu_1,mu_2,muu,muv,mut, "mu_1,mu_2,muu,muv,mut")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_small_step_em.F
    call small_step_prep( u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2, &
                          mub,mu_1,mu_2,muu,muus,muv,muvs,mut,muts,mudf, &
                          u_save,v_save,w_save,t_save,ph_save,mu_save,ww,ww1, &
                          dnw,c2a,pb,p,alt,msfu,msfv,msft,rk_step,leapfrog, &
                          ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                          grid%i_start(ij),grid%i_end(ij), &
                          grid%j_start(ij),grid%j_end(ij), &
                          k_start,k_end )

!-----Output: u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2,
!             mu_1,mu_2,muu,muus,muv,muvs,mut,muts,mudf,
!             u_save,v_save,w_save,t_save,ph_save,mu_save,ww

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SMALL_STEP_PREP.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---Save for calc_p_rho:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(ph_2,alt,t_2,t_save,c2a,pm1, "ph_2,alt,t_2,t_save,c2a,pm1")
    call push4backup(mu_2,muts, "mu_2,muts")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_small_step_em.F
    call calc_p_rho( al,p,ph_2,alt,t_2,t_save,c2a,pm1,mu_2,muts, &
                     znu,t0,rdnw,dnw,smdiv,non_hydrostatic,0, &
                     ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                     grid%i_start(ij),grid%i_end(ij), &
                     grid%j_start(ij),grid%j_end(ij), &
                     k_start,k_end )

!-----Output: al,p,ph_2,pm1

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALC_P_RHO.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

    if (non_hydrostatic) then
!-----Save for calc_coef_w:
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(a,alpha,gamma,cqw,c2a, "a,alpha,gamma,cqw,c2a")
      call push4backup(mut, "mut")
      if(grid%trace_use) call trace_exit("backup")

!-----From: module_small_step_em.F
      call calc_coef_w( a,alpha,gamma,mut,cqw,rdn,rdnw,c2a,dts,g,epssm, &
                        ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                        grid%i_start(ij),grid%i_end(ij), &
                        grid%j_start(ij),grid%j_end(ij), &
                        k_start,k_end )

!-----Output: a,alpha,gamma

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALC_COEF_W.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

!-if(grid%trace_use) call trace_entry("solve_ad_small_stepu")

  small_stepu: do iteration = 1, number_of_small_timesteps

      WRITE(wrf_err_message,*) 'DEBUG:  begin small_stepu, iteration = ',iteration
      CALL wrf_debug( 10, TRIM(wrf_err_message) )

!-----Save for advance_uv
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(php, "php")
      call push4backup(u_2,ru_tend,v_2,rv_tend,p,ph_2,alt,al,cqu,cqv, &
                      "u_2,ru_tend,v_2,rv_tend,p,ph_2,alt,al,cqu,cqv")
      call push4backup(mu_2,muu,muv,mudf, "mu_2,muu,muv,mudf")
      if(grid%trace_use) call trace_exit("backup")

!-----From: module_small_step_em.F
      call advance_uv( u_2,ru_tend,v_2,rv_tend,p,pb,ph_2,php,alt,al, &
                       mu_2,muu,cqu,muv,cqv,mudf,rdx,rdy,dts,cf1,cf2,cf3, &
                       fnm,fnp,emdiv,rdnw,config_flags,spec_zone,non_hydrostatic, &
                       ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                       grid%i_start(ij),grid%i_end(ij), &
                       grid%j_start(ij),grid%j_end(ij), &
                       k_start,k_end )

!-----Output: u_2,v_2,

!-----Combine this with spec_bdyupdate.
!ifdef DM_PARALLEL
!     if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
!include "HALO_ADVANCE_UV.inc"
!     if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
!endif

      if (config_flags%specified .or. config_flags%nested) then
!-------Save for spec_bdyupdate:
        if(grid%trace_use) call trace_entry("backup")
        call push4backup(u_2,ru_tend,v_2,rv_tend, "u_2,ru_tend,v_2,rv_tend")
        if(grid%trace_use) call trace_exit("backup")

!-------From: ../share/module_bc.F
        call spec_bdyupdate( u_2,ru_tend,dts_rk,'u',config_flags,spec_zone, &
                             ids,ide,jds,jde,kds,kde, &
                             ims,ime,jms,jme,kms,kme, &
                             ips,ipe,jps,jpe,kps,kpe, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij), &
                             k_start,k_end )
        call spec_bdyupdate( v_2,rv_tend,dts_rk,'v',config_flags,spec_zone, &
                             ids,ide,jds,jde,kds,kde, &
                             ims,ime,jms,jme,kms,kme, &
                             ips,ipe,jps,jpe,kps,kpe, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij), &
                             k_start,k_end )
!-----Output: u_2,v_2

!ifdef DM_PARALLEL
!     if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
!include "HALO_SPEC_BDYUPDATE_UV.inc"
!     if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
!endif
      endif

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_ADVANCE_UV.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!-----Save for advance_mu_t
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(ww,ww1,u_2,u_save,v_2,v_save,ru_m,rv_m,ww_m, &
                      "ww,ww1,u_2,u_save,v_2,v_save,ru_m,rv_m,ww_m")
      call push4backup(t_2,t_save,t_2save,t_tend, &
                      "t_2,t_save,t_2save,t_tend")
      call push4backup(mu_2,mut,muu,muv,mu_tend, "mu_2,mut,muu,muv,mu_tend")
      if(grid%trace_use) call trace_exit("backup")
               
!-----From: module_small_step_em.F
      call advance_mu_t( ww,ww1,u_2,u_save,v_2,v_save,mu_2,mut,muave,muts,muu,muv,mudf, &
                         ru_m,rv_m,ww_m,t_2,t_save,t_2save,t_tend,mu_tend, &
                         rdx,rdy,dts,epssm,dnw,fnm,fnp,rdnw, &
                         msfu,msfv,msft,iteration,config_flags, &
                         ids,ide,jds,jde,kds,kde, &
                         ims,ime,jms,jme,kms,kme, &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij), &
                         k_start,k_end )

!-----Output: ww,ww1,ru_m,rv_m,ww_m,t_2,t_2save,mu_2,muave,muts,mudf

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_ADVANCE_MU_T.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

      if (config_flags%specified .or. config_flags%nested) then
!-------Save for spec_bdyupdate:
        if(grid%trace_use) call trace_entry("backup")
        call push4backup(t_2,t_tend, "t_2,t_tend")
        call push4backup(mu_2,mu_tend,muts,mu_tend, "mu_2,mu_tend,muts,mu_tend")
        if(grid%trace_use) call trace_exit("backup")

!-------From: ../share/module_bc.F
        call spec_bdyupdate( t_2,t_tend,dts_rk,'t',config_flags,spec_zone, &
                             ids,ide,jds,jde,kds,kde, &
                             ims,ime,jms,jme,kms,kme, &
                             ips,ipe,jps,jpe,kps,kpe, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij), &
                             k_start,k_end )
        call spec_bdyupdate( mu_2,mu_tend,dts_rk,'m',config_flags,spec_zone, &
                             ids,ide,jds,jde,1,1, &
                             ims,ime,jms,jme,1,1, &
                             ips,ipe,jps,jpe,1,1, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij),1,1 )
        call spec_bdyupdate( muts,mu_tend,dts_rk,'m',config_flags,spec_zone, &
                             ids,ide,jds,jde,1,1, &
                             ims,ime,jms,jme,1,1, &
                             ips,ipe,jps,jpe,1,1, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij),1,1 )

!-------Output: t_2, mu_2, muts

#ifdef DM_PARALLEL
        if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SPEC_BDYUPDATE_TMU.inc"
        if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
      endif

!-----Save for sumflux
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(u_2,v_2,ww,u_save,v_save,ww1,ru_m,rv_m,ww_m, "u_2,v_2,ww,u_save,v_save,ww1,ru_m,rv_m,ww_m")
      call push4backup(muu,muv, "muu,muv")
      if(grid%trace_use) call trace_exit("backup")

!-----From: module_small_step_em.F
      call sumflux( u_2,v_2,ww,u_save,v_save,ww1,muu,muv, &
                    ru_m,rv_m,ww_m,epssm,msfu,msfv,iteration, &
                    number_of_small_timesteps,ids,&
                    ide,jds,jde,kds,kde, &
                    ims,ime,jms,jme,kms,kme, &
                    grid%i_start(ij),grid%i_end(ij), &
                    grid%j_start(ij),grid%j_end(ij), &
                    k_start,k_end )

!-----Output: ru_m,rv_m,ww_m

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SUMFLUX.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

      if (non_hydrostatic) then
!-------Save for advance_w:
        if(grid%trace_use) call trace_entry("backup")
        call push4backup(w_2,rw_tend,ww,u_2,v_2,t_2save,t_2,t_save, &
                        "w_2,rw_tend,ww,u_2,v_2,t_2save,t_2,t_save")
        call push4backup(ph_2,ph_save,ph_tend,c2a,cqw,alt,alb,a,alpha,gamma, &
                        "ph_2,ph_save,ph_tend,c2a,cqw,alt,alb,a,alpha,gamma")
        call push4backup(mu_2,mut,muave,muts, "mu_2,mut,muave,muts")
        if(grid%trace_use) call trace_exit("backup")

!-------From: module_small_step_em.F
        call advance_w( w_2,rw_tend,ww,u_2,v_2,mu_2,mut,muave,muts, &
                        t_2save,t_2,t_save,ph_2,ph_save, &
                        phb,ph_tend,ht,c2a,cqw,alt,alb,a,alpha,gamma, &
                        rdx,rdy,dts,t0,epssm,dnw,fnm,fnp,rdnw,rdn, &
                        cf1,cf2,cf3,msft,config_flags, &
                        ids,ide,jds,jde,kds,kde, &
                        ims,ime,jms,jme,kms,kme, &
                        grid%i_start(ij),grid%i_end(ij), &
                        grid%j_start(ij),grid%j_end(ij), &
                        k_start,k_end )

!-----Output: w_2,t_2save,ph_2

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_ADVANCE_W.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
      endif

      if (config_flags%specified .or. config_flags%nested) then
        if (non_hydrostatic) then
!---------Save for spec_bdyupdate_ph
          if(grid%trace_use) call trace_entry("backup")
          call push4backup(ph_save,ph_2,ph_tend, "ph_save,ph_2,ph_tend")
          call push4backup(mu_tend,muts, "mu_tend,muts")
          if(grid%trace_use) call trace_exit("backup")

!---------From: module_bc_em.F
          call spec_bdyupdate_ph( ph_save,ph_2,ph_tend,mu_tend,muts,dts_rk, &
                                  'h',config_flags,spec_zone, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )

!---------Output: ph_2

#ifdef DM_PARALLEL
          if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SPEC_BDYUPDATE_PH.inc"
          if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
          if (config_flags%specified) then
!-----------From: ../share/module_bc.F
            call zero_grad_bdy( w_2,'w',config_flags,spec_zone, &
                                ids,ide,jds,jde,kds,kde, &
                                ims,ime,jms,jme,kms,kme, &
                                ips,ipe,jps,jpe,kps,kpe, &
                                grid%i_start(ij),grid%i_end(ij), &
                                grid%j_start(ij),grid%j_end(ij), &
                                k_start,k_end )
!-----------Output: w_2
          else
!-----------Save for spec_bdyupdate:
            if(grid%trace_use) call trace_entry("backup")
            call push4backup(w_2,rw_tend, "w_2,rw_tend")
            if(grid%trace_use) call trace_exit("backup")

!-----------From: ../share/module_bc.F
            call spec_bdyupdate( w_2,rw_tend,dts_rk,'h',config_flags,spec_zone, &
                                 ids,ide,jds,jde,kds,kde, &
                                 ims,ime,jms,jme,kms,kme, &
                                 ips,ipe,jps,jpe,kps,kpe, &
                                 grid%i_start(ij),grid%i_end(ij), &
                                 grid%j_start(ij),grid%j_end(ij), &
                                 k_start,k_end )
!-----------Output: w_2
          endif

#ifdef DM_PARALLEL
          if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SPEC_BDYUPDATE_W.inc"
          if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
        endif
      endif

!-----Save for calc_p_rho:
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(al,p,ph_2,alt,t_2,t_save,c2a,pm1, "al,p,ph_2,alt,t_2,t_save,c2a,pm1")
      call push4backup(mu_2,muts, "mu_2,muts")
      if(grid%trace_use) call trace_exit("backup")

!-----From: module_small_step_em.F
      call calc_p_rho( al,p,ph_2,alt,t_2,t_save,c2a,pm1,mu_2,muts,znu, &
                       t0,rdnw,dnw,smdiv,non_hydrostatic,iteration, &
                       ids,ide,jds,jde,kds,kde, &
                       ims,ime,jms,jme,kms,kme, &
                       grid%i_start(ij),grid%i_end(ij), &
                       grid%j_start(ij),grid%j_end(ij), &
                       k_start,k_end )

!-----Output: al,p,ph_2,pm1

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALC_P_RHO.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  end do small_stepu

!-if(grid%trace_use) call trace_exit("solve_ad_small_stepu")

!---Save for calc_mu_uv_1: (Will backup next)
!   call push4backup(muts, "muts")

!---From: module_big_step_utilities_em.F
    call calc_mu_uv_1( config_flags,muts,muus,muvs, &
                       ids,ide,jds,jde,kds,kde, &
                       ims,ime,jms,jme,kms,kme, &
                       grid%i_start(ij),grid%i_end(ij), &
                       grid%j_start(ij),grid%j_end(ij), &
                       k_start,k_end )

!-----Output: muus,muvs

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALC_MU_UV_1.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!-----Save for small_step_finish:
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(u_2,u_1,v_2,v_1,w_2,w_1,t_2,t_1,ph_2,ph_1, &
                      "u_2,u_1,v_2,v_1,w_2,w_1,t_2,t_1,ph_2,ph_1")
      call push4backup(ww,ww1,u_save,v_save,w_save,t_save,ph_save,h_diabatic, &
                      "ww,ww1,u_save,v_save,w_save,t_save,ph_save,h_diabatic")
      call push4backup(mu_2,mu_1,mut,muts,muu,muus,muv,muvs,mu_save, &
                      "mu_2,mu_1,mut,muts,muu,muus,muv,muvs,mu_save")

      if(grid%trace_use) call trace_exit("backup")

!-----From: module_small_step_em.F
      CALL small_step_finish( u_2, u_1, v_2, v_1, w_2, w_1,     &
                              t_2, t_1, ph_2, ph_1, ww, ww1,    &
                              mu_2, mu_1,                       &
                              mut, muts, muu, muus, muv, muvs,  &
                              u_save, v_save, w_save,           &
                              t_save, ph_save, mu_save,         &
                              msfu, msfv, msft,                 &
                              h_diabatic,                       &
                              number_of_small_timesteps,dts_rk, &
                              ids, ide, jds, jde, kds, kde,     &
                              ims, ime, jms, jme, kms, kme,     &
                              grid%i_start(ij), grid%i_end(ij), &
                              grid%j_start(ij), grid%j_end(ij), &
                              k_start    , k_end               )

!-----Output: u_2,v_2,w_2,t_2,ph_2,ww,mu_2,mu_1,mut,muts,muu,muus,muv,muvs,mu_save

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_SMALL_STEP_FINISH.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  moist_scalar_advancg: if (num_3d_m .ge. param_first_scalar) then

    moist_variable_loor1: do im = param_first_scalar, num_3d_m

!---Save for rk_scalar_tend:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(xkmhd, "xkmhd")
    call push4backup(ru_m,rv_m,ww_m,alt,advect_tend, &
                    "ru_m,rv_m,ww_m,alt,advect_tend")
    call push4backup(mut, "mut")
    call push4backup(moist_1,moist_2, "moist_1,moist_2")
    if(grid%trace_use) call trace_exit("backup")

!-------From: module_em.F
        call rk_scalar_tend( im,im,config_flags,rk_step,dt_rk, &
                             ru_m,rv_m,ww_m,mut,alt, &
                             moist_1(ims,kms,jms,im),moist_2(ims,kms,jms,im), &
                             moist_tend(ims,kms,jms,im), &
                             advect_tend,rqvften,qv_base, .true. , &
                             fnm,fnp,msfu,msfv,msft,rdx,rdy,rdn,rdnw, &
                             khdif,kvdif,xkmhd,leapfrog, &
                             ids,ide,jds,jde,kds,kde, &
                             ims,ime,jms,jme,kms,kme, &
                             grid%i_start(ij),grid%i_end(ij), &
                             grid%j_start(ij),grid%j_end(ij), &
                             k_start,k_end )

!-------Output: moist_1,moist_2,moist_tend,rqvften

        if ((config_flags%specified .or. config_flags%nested) .and. rk_step .eq. 1) then
          if (im .eq. p_qv) then
!-----------From: module_bc_em.F
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqv_b,rqv_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
!-----------Output: moist_tend
          endif
        endif
        if (config_flags%nested .and. rk_step .eq. 1) then
          if (im .eq. p_qc) then
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqc_b,rqc_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
          else if (im .eq. p_qr) then
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqr_b,rqr_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
          else if (im .eq. p_qi) then
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqi_b,rqi_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
          else if (im .eq. p_qs) then
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqs_b,rqs_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
          else if (im .eq. p_qg) then
            call spec_bdy_scalar( moist_tend(ims,kms,jms,im),rqg_b,rqg_bt,spec_bdy_width,spec_zone, &
                                  ijds,ijde, &
                                  ids,ide,jds,jde,kds,kde, &
                                  ims,ime,jms,jme,kms,kme, &
                                  ips,ipe,jps,jpe,kps,kpe, &
                                  grid%i_start(ij),grid%i_end(ij), &
                                  grid%j_start(ij),grid%j_end(ij), &
                                  k_start,k_end )
          endif
        endif

!-----Output: moist_1,moist_2,moist_tend (...rqvften)

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RK_SCALAR.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---Save for rk_update_scalar:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(advect_tend, "advect_tend")
    call push4backup(mu_1,mu_2, "mu_1,mu_2")
    call push4backup(moist_1,moist_2,moist_tend, "moist_1,moist_2,moist_tend")
    if(grid%trace_use) call trace_exit("backup")

!-------From: module_em.F
        call rk_update_scalar( im,im,moist_1(ims,kms,jms,im),moist_2(ims,kms,jms,im), &
                               moist_tend(ims,kms,jms,im),advect_tend, &
                               msft,mu_1,mu_2,mub,rk_step,dt_rk, &
                               spec_zone,epsts,leapfrog,config_flags, &
                               ids,ide,jds,jde,kds,kde, &
                               ims,ime,jms,jme,kms,kme, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij), &
                               k_start,k_end )

!-------Output: moist_1,moist_2,moist_tend
    end do moist_variable_loor1

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_RK_SCALAR.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  endif moist_scalar_advancg

!---Save for calc_p_rho_phi:
    if(grid%trace_use) call trace_entry("backup")
    call push4backup(ph_2,t_2, "ph_2,t_2")
    call push4backup(mu_2,muts, "mu_2,muts")
    call push4backup(moist_2, "moist_2")
    call push4backup(al,p, "al,p")
    if(grid%trace_use) call trace_exit("backup")

!---From: module_big_step_utilities_em.F
    call calc_p_rho_phi( moist_2,num_3d_m,al,alb,mu_2,muts,ph_2,p,pb,t_2,p0,t0, &
                         znu,dnw,rdnw,rdn,non_hydrostatic, &
                         ids,ide,jds,jde,kds,kde, &
                         ims,ime,jms,jme,kms,kme, &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij), &
                         k_start,k_end )

!-----Output: al,p,ph_2

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_CALC_P_RHO_PHI.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

    if ( .not. non_hydrostatic) then
!-----Save for diagnose_w:
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(ph_tend, "ph_tend")
      call push4backup(muts, "muts")
      if(grid%trace_use) call trace_exit("backup")

!---From: module_big_step_utilities_em.F
      call diagnose_w( ph_tend,ph_2,ph_1,w_2,muts,dt_rk,u_2,v_2,ht, &
                       cf1,cf2,cf3,rdx,rdy,msft, &
                       ids,ide,jds,jde,kds,kde, &
                       ims,ime,jms,jme,kms,kme, &
                       grid%i_start(ij),grid%i_end(ij), &
                       grid%j_start(ij),grid%j_end(ij), &
                       k_start,k_end )

!-----Output: w_2

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_DIAGNOSE_W.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

end do runge_kutta_looq
!whl save the basic state for the mp and large scale rain. 
!
  if (config_flags%mp_physics >= 0) then
   IF( config_flags%specified .or. config_flags%nested ) THEN
     sz = spec_zone
   ELSE
     sz = 0
   ENDIF

       CALL moist_physics_prep_em( t_2, t_1, t0, rho,                &
                                   al, alb, p, p8w, p0, pb,          &
                                   ph_2, phb, pi_phy, p_phy,         &
                                   z, z_at_w, dz8w,                  &
                                   dtm, h_diabatic,                  &
                                   config_flags,fnm, fnp,            &
                                   ids, ide, jds, jde, kds, kde,     &
                                   ims, ime, jms, jme, kms, kme,     &
                                   max(grid%i_start(ij),ids+sz),  &
                                   min(grid%i_end(ij),ide-1-sz),    &
                                   max(grid%j_start(ij),jds+sz),  &
                                   min(grid%j_end(ij),jde-1-sz),k_start,k_end )
    call push4backup(moist_2, "moist_2")
    call push4backup(rho, "rho")
    call push4backup(p_phy, "p_phy")
    call push4backup(pi_phy, "pi_phy")
    call push4backup(th_phy, "th_phy")
    call push4backup(t_2, "t_2")
    call push4backup(z, "z")
    call push4backup(dz8w, "dz8w")

     if(config_flags%mp_physics == 1)then  

      call kessler(t_2,moist_2(ims,kms,jms,P_QV),moist_2(ims,kms,jms,P_QC),moist_2(ims,kms,jms,P_QR), rho, p_phy,pi_phy, dt&
&      , z, xlv, cp, ep_2, svp1, svp2, svp3, svpt0, rhowater, dz8w, rainnc, &
&       rainncv, ids, ide, jds, jde, kds, kde, ims, ime, &
&       jms, jme, kms, kme, &
                                   max(grid%i_start(ij),ids+sz),          &
                                   min(grid%i_end(ij),ide-1-sz),          &
                                   max(grid%j_start(ij),jds+sz),          &
                                   min(grid%j_end(ij),jde-1-sz),k_start    , min(k_end,kde-1)         )
     elseif(config_flags%mp_physics == 0)then
        CALL lscond(t_2, p_phy                                         &
                    ,moist_2(ims,kms,jms,P_QV)                         &
                    ,rho, pi_phy,r_v, xlv, cp                          &
                    ,ep_2, svp1, svp2                                  &
                    ,svp3, svpt0                                       &
                    ,dz8w                                              &
                    ,rainnc, rainncv                                   &
                    ,ids, ide, jds, jde, kds, kde                      &
                    ,ims, ime, jms, jme, kms, kme                      &
                    ,its, ite, jts, jte                                &
                    ,k_start, min(k_end,kde-1)                         )
     endif

        CALL moist_physics_finish_em( t_2, t_1, t0, muts,              &
                                     h_diabatic, dtm, config_flags,    &
                                     ids, ide, jds, jde, kds, kde,     &
                                     ims, ime, jms, jme, kms, kme,     &
                                     max(grid%i_start(ij),ids+sz),     &
                                     min(grid%i_end(ij),ide-1-sz),     &
                                     max(grid%j_start(ij),jds+sz),     &
                                     min(grid%j_end(ij),jde-1-sz),     &
                                     k_start    , k_end               )

    call push4backup(ph_2,t_2, "ph_2,t_2")
    call push4backup(mu_2,muts, "mu_2,muts")
    call push4backup(moist_2, "moist_2")
    call push4backup(al,p, "al,p")

    call calc_p_rho_phi( moist_2,num_3d_m,al,alb,mu_2,muts,ph_2,p,pb,t_2,p0,t0, &
                         znu,dnw,rdnw,rdn,non_hydrostatic, &
                         ids,ide,jds,jde,kds,kde, &
                         ims,ime,jms,jme,kms,kme, &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij), &
                         k_start,k_end )

!-----Save for diagnose_w:
      if(grid%trace_use) call trace_entry("backup")
      call push4backup(ph_tend, "ph_tend")
      call push4backup(muts, "muts")
      if(grid%trace_use) call trace_exit("backup")
!whl diagnose_w
  endif 


!-if(grid%trace_use) call trace_exit("solve_ad_runge_kutta_looq")
  if (config_flags%mp_physics >= 0) then
    if (config_flags%specified .or. config_flags%nested) then
      sz = spec_zone
    else
      sz = 0
    endif

      call pop2restore(muts, "muts")
      call pop2restore(ph_tend, "ph_tend")

   if ( .not. non_hydrostatic) then
      call a_diagnose_w( ph_tend,a_ph_tend,a_ph_2,a_ph_1,&
                     a_w_2,muts,a_muts,dt_rk,a_u_2,a_v_2,ht,cf1,cf2,cf3,rdx,rdy,msft,ide,jde,&
                     ims,ime,jms,jme,kms,kme,&
                     max(grid%i_start(ij),ids+sz),  &
                     min(grid%i_end(ij),ide-1-sz),    &
                     max(grid%j_start(ij),jds+sz),  &
                     min(grid%j_end(ij),jde-1-sz),k_end )

    endif

    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(al,p, "al,p")
    call pop2restore(moist_2, "moist_2")
    call pop2restore(mu_2,muts, "mu_2,muts")
    call pop2restore(ph_2,t_2, "ph_2,t_2")
    if(grid%trace_use) call trace_exit("restore")

    call a_calc_p_rho_phi( moist_2,a_moist_2,num_3d_m,al,a_al,alb,mu_2,&
                      a_mu_2,muts,a_muts,ph_2,a_ph_2,p,a_p,pb,t_2,a_t_2,p0,t0,dnw,&
                      rdnw,rdn,non_hydrostatic,ide,jde,kde,ims,ime,jms,jme,kms,kme,&
                      max(grid%i_start(ij),ids+sz),  &
                      min(grid%i_end(ij),ide-1-sz),    &
                      max(grid%j_start(ij),jds+sz),  &
                      min(grid%j_end(ij),jde-1-sz),k_start,k_end )

       its = max(grid%i_start(ij),ids+sz)
       ite = min(grid%i_end(ij),ide-1-sz)
       jts = max(grid%j_start(ij),jds+sz)
       jte = min(grid%j_end(ij),jde-1-sz)

    call a_moist_physics_finish_em( a_t_2, a_t_1, t0, &
                                    a_h_diabatic, dtm, ide, jde, kde, &
                                    ims, ime, jms, jme, kms, kme, &
                                    its, ite, jts, jte, k_start,k_end )


!       CALL moist_physics_prep_em( t_2, t_1, t0, rho,                &
!                                   al, alb, p, p8w, p0, pb,          &
!                                   ph_2, phb, pi_phy, p_phy,         &
!                                   z, z_at_w, dz8w,                  &
!                                   dtm, h_diabatic,                  &
!                                   config_flags,fnm, fnp,            &
!                                   ids, ide, jds, jde, kds, kde,     &
!                                   ims, ime, jms, jme, kms, kme,     &
!                                   max(grid%i_start(ij),ids+sz),  &
!                                   min(grid%i_end(ij),ide-1-sz),    &
!                                   max(grid%j_start(ij),jds+sz),  &
!                                   min(grid%j_end(ij),jde-1-sz),k_start,k_end )

!---Restore for lscond:
    call pop2restore(dz8w, "dz8w")
    call pop2restore(z, "z")
    call pop2restore(t_2, "t_2")
    call pop2restore(th_phy, "th_phy")
    call pop2restore(pi_phy, "pi_phy")
    call pop2restore(p_phy, "p_phy")
    call pop2restore(rho, "rho")
    call pop2restore(moist_2, "moist_2")
!whl
!     print*,'config_flags%mp_physics in ad ',config_flags%mp_physics

  if (config_flags%mp_physics ==1)then
   call kessler_b(t_2, a_t_2, moist_2(ims,kms,jms,P_QV),  a_moist_2(ims,kms,jms,P_QV),&
&                             moist_2(ims,kms,jms,P_QC),  a_moist_2(ims,kms,jms,P_QC),&
&                             moist_2(ims,kms,jms,P_QR),  a_moist_2(ims,kms,jms,P_QR),&
&     rho, a_rho, p_phy, a_p_phy, pi_phy, a_pi_phy, dtm&
&    , z, xlv, cp, ep_2,svp1, svp2, svp3, svpt0, rhowater, dz8w, rainnc, &
&    a_rainnc, rainncv, a_rainncv, ids, ide, jds, jde, kds, kde, ims, ime, &
&    jms, jme, kms, kme, &
                                   max(grid%i_start(ij),ids+sz),          &
                                   min(grid%i_end(ij),ide-1-sz),          &
                                   max(grid%j_start(ij),jds+sz),          &
                                   min(grid%j_end(ij),jde-1-sz),k_start    , min(k_end,kde-1)        )
  elseif(config_flags%mp_physics ==0)then
    call a_lscond ( t_2,a_t_2,p_phy,a_p_phy,moist_2(ims,kms,jms,P_QV), &
                    a_moist_2(ims,kms,jms,P_QV),rho,a_rho,&
                    pi_phy,a_pi_phy,r_v,xlv,cp,ep_2,svp1,svp2,svp3,svpt0,dz8w,a_dz8w, &
                    rainnc,a_rainnc,rainncv,a_rainncv,ims,ime,jms,jme,kms,kme, &
                    its, ite, jts, jte, min(k_end,kde-1) )
  else
  print*,'no rain process'
  endif
!-----Output: a_t_2,a_p_phy,a_moist_2,a_rho,a_pi_phy,a_rainnc,a_rainncv,a_dz8w


!---From: module_big_step_utilities_em_ad.F
    call a_moist_physics_prep_em( t_2, a_t_2, t_1, a_t_1, t0, rho, a_rho, &
                                  al, a_al, alb, p, a_p, p8w, a_p8w, p0, &
                                  pb, ph_2, a_ph_2, phb, pi_phy, a_pi_phy, &
                                  p_phy, a_p_phy, z, a_z, z_at_w, a_z_at_w, &
                                  dz8w, a_dz8w, h_diabatic, a_h_diabatic, fnm, fnp, &
                                  ide, jde, kde, ims, ime, jms, jme, kms, kme, &
                                  its, ite, jts, jte, k_start,k_end )

!-----Output: a_t_2,a_t_1,a_rho,a_al,a_p,a_p8w,a_ph_2,a_pi_phy,a_p_phy,a_z,a_z_at_w,a_dz8w,a_h_diabatic

endif  ! micro phy
!------------------------------

!-if(grid%trace_use) call trace_entry("solve_ad_a_runge_kutta_loop")

a_runge_kutta_loop: do rk_step = rk_order, 1, -1

    dtm = dt
    if (rk_order .eq. 1) then
      if (step_number .ne. 1) then
        number_of_small_timesteps = 2*time_step_sound
        dt_rk = dt
        dtm = 2*dt
      else
        number_of_small_timesteps = time_step_sound
        dt_rk = dt/2.
        dtm = dt
      endif
      dts_rk = dts
    else if (rk_order .eq. 2) then
      if (rk_step .eq. 1) then
        dt_rk = 0.5*dt
        dts_rk = dts
        number_of_small_timesteps = time_step_sound/2
      else
        dt_rk = dt
        dts_rk = dts
        number_of_small_timesteps = time_step_sound
      endif
    else if (rk_order .eq. 3) then
      if (rk_step .eq. 1) then
        dt_rk = dt/3.
        dts_rk = dt_rk
        number_of_small_timesteps = 1
      else if (rk_step .eq. 2) then
        dt_rk = 0.5*dt
        dts_rk = dts
        number_of_small_timesteps = time_step_sound/2
      else
        dt_rk = dt
        dts_rk = dts
        number_of_small_timesteps = time_step_sound
      endif
    endif

    if ( .not. non_hydrostatic) then
!-----Restore for diagnose_w:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(muts, "muts")
      call pop2restore(ph_tend, "ph_tend")
      if(grid%trace_use) call trace_exit("restore")

!-----From: module_big_step_utilities_em_ad.F
      call a_diagnose_w( ph_tend,a_ph_tend,a_ph_2,a_ph_1,a_w_2,muts,a_muts,dt_rk, &
                         a_u_2,a_v_2,ht,cf1,cf2,cf3,rdx,rdy,msft, &
                         ide,jde,ims,ime,jms,jme,kms,kme, &
                         grid%i_start(ij),grid%i_end(ij), &
                         grid%j_start(ij),grid%j_end(ij),k_end )

!-----Output: a_ph_tend,a_ph_2,a_ph_1,a_w_2,a_u_2,a_v_2

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_DIAGNOSE_W.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

!---Restore for calc_p_rho_phi:
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(al,p, "al,p")
    call pop2restore(moist_2, "moist_2")
    call pop2restore(mu_2,muts, "mu_2,muts")
    call pop2restore(ph_2,t_2, "ph_2,t_2")
    if(grid%trace_use) call trace_exit("restore")

!---From: module_big_step_utilities_em_ad.F
    call a_calc_p_rho_phi( moist_2,a_moist_2,num_3d_m,al,a_al,alb,mu_2, &
                           a_mu_2,muts,a_muts,ph_2,a_ph_2,p,a_p,pb,t_2,a_t_2,p0,t0, &
                           dnw,rdnw,rdn,non_hydrostatic, &
                           ide,jde,kde,ims,ime,jms,jme,kms,kme, &
                           grid%i_start(ij),grid%i_end(ij), &
                           grid%j_start(ij),grid%j_end(ij), &
                           k_start,k_end )

!---Output: a_moist_2,a_al,a_mu_2,a_muts,a_ph_2,a_p,a_t_2
#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALC_P_RHO_PHI.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---------------------------------------------------------------------------------

  a_moist_scalar_advance: if (num_3d_m .ge. param_first_scalar) then

    a_moist_variable_loop2: do im = num_3d_m, param_first_scalar, -1

!---Restore for a_rk_update_scalar:
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(moist_1,moist_2,moist_tend, "moist_1,moist_2,moist_tend")
    call pop2restore(mu_1,mu_2, "mu_1,mu_2")
    call pop2restore(advect_tend, "advect_tend")
    if(grid%trace_use) call trace_exit("restore")

    its = max(grid%i_start(ij)-1,ids)
    ite = min(grid%i_end(ij)+1,ide)
    jts = max(grid%j_start(ij)-1,jds)
    jte = min(grid%j_end(ij)+1,jde)

!-------From: module_em_ad.F
        call a_rk_update_scalar( im,im,moist_1(ims,kms,jms,im),a_moist_1(ims,kms,jms,im), &
                                 moist_2(ims,kms,jms,im),a_moist_2(ims,kms,jms,im), &
                                 moist_tend(ims,kms,jms,im),a_moist_tend(ims,kms,jms,im), &
                                 advect_tend,a_advect_tend, &
                                 msft,mu_1,a_mu_1,mu_2,a_mu_2,mub, &
                                 rk_step,dt_rk,spec_zone,epsts,leapfrog,config_flags, &
                                 ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                                 its, ite, jts, jte, k_start,k_end )
!-------Output: a_moist_1,a_moist_2,a_moist_tend,a_advect_tend,a_mu_1,a_mu_2

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RK_UPDATE_SCALAR.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

       if (config_flags%nested .and. rk_step .eq. 1) then
          if (im .eq. p_qc) then
!-----------From: module_bc_em_ad.F
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqc_bth,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
!-----------Output: a_moist_tend
          else if (im .eq. p_qr) then
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqr_bth,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
          else if (im .eq. p_qi) then
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqi_bth,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
          else if (im .eq. p_qs) then
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqs_bth,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
          else if (im .eq. p_qg) then
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqg_bth,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
          endif
        endif

        if ((config_flags%specified .or. config_flags%nested) .and. rk_step .eq. 1) then
          if (im .eq. p_qv) then
            call a_spec_bdy_scalar( a_moist_tend(ims,kms,jms,im),a_rqv_bt,spec_bdy_width,spec_zone, &
                                    ijds,ijde, &
                                    ids,ide,jds,jde,kds,kde, &
                                    ims,ime,jms,jme,kms,kme, &
                                    grid%i_start(ij),grid%i_end(ij), &
                                    grid%j_start(ij),grid%j_end(ij), &
                                    k_start,k_end )
          endif
        endif

!---Restore for a_rk_scalar_tend:
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(moist_1,moist_2, "moist_1,moist_2")
    call pop2restore(mut, "mut")
    call pop2restore(ru_m,rv_m,ww_m,alt,advect_tend, &
                    "ru_m,rv_m,ww_m,alt,advect_tend")
    call pop2restore(xkmhd, "xkmhd")
    if(grid%trace_use) call trace_exit("restore")

        its = max(grid%i_start(ij)-3,ids)
        ite = min(grid%i_end(ij)+3,ide)
        jts = max(grid%j_start(ij)-3,jds)
        jte = min(grid%j_end(ij)+3,jde)

!-------From: module_em_ad.F
        call a_rk_scalar_tend( im,im,config_flags,rk_step, &
                               ru_m,a_ru_m,rv_m,a_rv_m,ww_m,a_ww_m,mut,a_mut, &
                               alt,a_alt,moist_1(ims,kms,jms,im),a_moist_1(ims,kms,jms,im), &
                               moist_2(ims,kms,jms,im),a_moist_2(ims,kms,jms,im), &
                               a_moist_tend(ims,kms,jms,im),a_advect_tend,qv_base, .true. , &
                               fnm,fnp,msfu,msfv,msft,rdx,rdy,rdn,rdnw,kvdif,xkmhd,a_xkmhd,leapfrog, &
                               ids,ide,jds,jde,kds,kde,&
                               ims,ime,jms,jme,kms,kme, &
                               its, ite, jts, jte, k_start,k_end )

!-------Output: a_ru_m,a_rv_m,a_ww_m,a_mut,a_alt,a_moist_1,a_moist_2,a_moist_tend,a_advect_tend,a_xkmhd

    end do a_moist_variable_loop2

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RK_SCALAR_TEND.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  endif a_moist_scalar_advance

!------------------------------

!---Restore for a_small_step_finish:
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(mu_2,mu_1,mut,muts,muu,muus,muv,muvs,mu_save, &
                    "mu_2,mu_1,mut,muts,muu,muus,muv,muvs,mu_save")
    call pop2restore(ww,ww1,u_save,v_save,w_save,t_save,ph_save,h_diabatic, &
                    "ww,ww1,u_save,v_save,w_save,t_save,ph_save,h_diabatic")
    call pop2restore(u_2,u_1,v_2,v_1,w_2,w_1,t_2,t_1,ph_2,ph_1, &
                    "u_2,u_1,v_2,v_1,w_2,w_1,t_2,t_1,ph_2,ph_1")

    if(grid%trace_use) call trace_exit("restore")

    its = max(grid%i_start(ij)-1,ids)
    ite = min(grid%i_end(ij)+1,ide)
    jts = max(grid%j_start(ij)-1,jds)
    jte = min(grid%j_end(ij)+1,jde)

!---From: module_small_step_em_ad.F
    call a_small_step_finish( u_2,a_u_2,v_2,a_v_2,w_2,a_w_2,t_2,a_t_2,a_ph_2, &
                              a_mu_2,mut,a_mut,muts,a_muts,muu,a_muu, &
                              muus,a_muus,muv,a_muv,muvs,a_muvs, &
                              u_save,a_u_save,v_save,a_v_save,w_save,a_w_save, &
                              t_save,a_t_save,a_ph_save,a_mu_save,msfu,msfv,msft, &
			      number_of_small_timesteps,dts_rk, &
                              ide,jde,kds,kde, &
                              ims,ime,jms,jme,kms,kme, &
                              its, ite, jts, jte )

!-----Output: a_u_2,a_v_2,a_w_2,a_t_2,a_ph_2,a_muus,a_muv,a_muvs,a_u_save,a_v_save,a_w_save,a_t_save,a_ph_save,a_mu_save

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SMALL_STEP_FINISH.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---Restore for a_calc_mu_uv_1: (Already restored above)
!---call pop2restore(muts, "muts")

    its = max(grid%i_start(ij)-1,ids)
    ite = min(grid%i_end(ij)+1,ide)
    jts = max(grid%j_start(ij)-1,jds)
    jte = min(grid%j_end(ij)+1,jde)

!---From: module_big_step_utilities_em_ad.F
    call a_calc_mu_uv_1( config_flags,a_muts,a_muus,a_muvs, &
                         ids,ide,jds,jde,ims,ime,jms,jme, &
                         its, ite, jts, jte )

!---Output: a_muts,a_muus,a_muvs

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALC_MU_UV_1.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!------------------------------
!-if(grid%trace_use) call trace_entry("solve_ad_a_small_steps")

  a_small_steps: do iteration = number_of_small_timesteps, 1, -1

!-----Restore for a_calc_p_rho:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mu_2,muts, "mu_2,muts")
      call pop2restore(al,p,ph_2,alt,t_2,t_save,c2a,pm1, "al,p,ph_2,alt,t_2,t_save,c2a,pm1")
      if(grid%trace_use) call trace_exit("restore")

      its = max(grid%i_start(ij)-1,ids)
      ite = min(grid%i_end(ij)+1,ide)
      jts = max(grid%j_start(ij)-1,jds)
      jte = min(grid%j_end(ij)+1,jde)

!-----From: module_small_step_em_ad.F
      call a_calc_p_rho( al,a_al,p,a_p,ph_2,a_ph_2,alt,a_alt,t_2,a_t_2,t_save,a_t_save, &
                         c2a,a_c2a,a_pm1,mu_2,a_mu_2,muts,a_muts, &
                         znu,t0,rdnw,dnw,smdiv,non_hydrostatic,iteration, &
                         ide,jde,kde,ims,ime,jms,jme,kms,kme, &
                         its,ite,jts,jte,k_start,k_end )

!-----Output: a_al,a_p,a_ph_2,a_alt,a_t_2,a_t_save,a_c2a,a_pm1,a_mu_2,a_muts

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALC_P_RHO.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

      if (config_flags%specified .or. config_flags%nested) then
        if (non_hydrostatic) then
          if (config_flags%specified) then
!-----------From: module_bc_ad.F
            call a_zero_grad_bdy( a_w_2,'w',spec_zone, &
                                  ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme,&
                                  its,ite,jts,jte,k_start)
          else
!-----------Restore for a_spec_bdyupdate:
            if(grid%trace_use) call trace_entry("restore")
            call pop2restore(w_2,rw_tend, "w_2,rw_tend")
            if(grid%trace_use) call trace_exit("restore")

            call a_spec_bdyupdate( a_w_2,a_rw_tend,dts_rk,'h',spec_zone, &
                                   ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme,&
                                   its,ite,jts,jte,k_start,k_end )
          endif

!---------Output: a_w_2,a_rw_tend

#ifdef DM_PARALLEL
          if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SPEC_BDYUPDATE_W.inc"
          if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---------Restore for a_spec_bdyupdate_ph:
          if(grid%trace_use) call trace_entry("restore")
          call pop2restore(mu_tend,muts, "mu_tend,muts")
          call pop2restore(ph_save,ph_2,ph_tend, "ph_save,ph_2,ph_tend")
          if(grid%trace_use) call trace_exit("restore")

!---------From: module_bc_em_ad.F
          call a_spec_bdyupdate_ph( ph_save,a_ph_save,ph_2,a_ph_2,ph_tend,a_ph_tend, &
                                    mu_tend,a_mu_tend,muts,a_muts,dts_rk,'h',spec_zone, &
                                    ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme,&
                                    its,ite,jts,jte,k_start,k_end )
!---------Output: a_ph_save,a_ph_2,a_ph_tend,a_mu_tend,a_muts

#ifdef DM_PARALLEL
          if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SPEC_BDYUPDATE_PH.inc"
          if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

        endif
      endif

      if (non_hydrostatic) then

!-------Restore for a_advance_w:
        if(grid%trace_use) call trace_entry("restore")
        call pop2restore(mu_2,mut,muave,muts, "mu_2,mut,muave,muts")
        call pop2restore(ph_2,ph_save,ph_tend,c2a,cqw,alt,alb,a,alpha,gamma, &
                        "ph_2,ph_save,ph_tend,c2a,cqw,alt,alb,a,alpha,gamma")
        call pop2restore(w_2,rw_tend,ww,u_2,v_2,t_2save,t_2,t_save, &
                        "w_2,rw_tend,ww,u_2,v_2,t_2save,t_2,t_save")
        if(grid%trace_use) call trace_exit("restore")

!-------From: module_small_step_em_ad.F
        call a_advance_w( w_2,a_w_2,rw_tend,a_rw_tend,ww,a_ww, &
                          u_2,a_u_2,v_2,a_v_2,mu_2,a_mu_2,mut,a_mut, &
                          muave,a_muave,muts,a_muts,&
                          t_2save,a_t_2save,t_2,a_t_2,t_save,a_t_save, &
                          ph_2,a_ph_2,ph_save,a_ph_save,phb,ph_tend,a_ph_tend, &
                          ht,c2a,a_c2a,cqw,a_cqw,&
                          alt,a_alt,alb,a,a_a,alpha,a_alpha,gamma,a_gamma, &
                          rdx,rdy,dts,t0,epssm,fnm,fnp,rdnw,rdn, &
                          cf1,cf2,cf3,msft,config_flags, &
                          ids,ide,jds,jde,ims,ime,jms,jme,kms,kme, &
                          its,ite,jts,jte,k_start,k_end )

!-------Output: a_w_2,a_rw_tend,a_ww,a_u_2,a_v_2,a_mu_2,a_mut,a_muave,a_muts
!               a_t_2save,a_t_2,a_t_save,a_ph_2,a_ph_save,a_ph_tend,a_c2a,a_cqw
!               a_alt,a_a,a_alpha,a_gamma

#ifdef DM_PARALLEL
        if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_ADVANCE_W.inc"
        if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
      endif

!-----Restore for a_sumflux:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(muu,muv, "muu,muv")
      call pop2restore(u_2,v_2,ww,u_save,v_save,ww1,ru_m,rv_m,ww_m, "u_2,v_2,ww,u_save,v_save,ww1,ru_m,rv_m,ww_m")
      if(grid%trace_use) call trace_exit("restore")

!-----From: module_small_step_em_ad.F
      call a_sumflux( a_u_2,a_v_2,a_ww,u_save,a_u_save,v_save,a_v_save,a_ww1, &
                      muu,a_muu,muv,a_muv,a_ru_m,a_rv_m,a_ww_m,msfu,msfv,&
                      iteration,number_of_small_timesteps, &
                      ide,jde,kde,ims,ime,jms,jme,kms,kme,&
                      its,ite,jts,jte,k_start,k_end )

!-----Output: a_u_2,a_v_2,a_ww,a_u_save,a_v_save,a_ww1,a_muu,a_muv,a_ru_m,a_rv_m,a_ww_m

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SUMFLUX.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

      if (config_flags%specified .or. config_flags%nested) then
!-------Restore for spec_bdyupdate:
        if(grid%trace_use) call trace_entry("restore")
        call pop2restore(mu_2,mu_tend,muts,mu_tend, "mu_2,mu_tend,muts,mu_tend")
        call pop2restore(t_2,t_tend, "t_2,t_tend")
        if(grid%trace_use) call trace_exit("restore")

!-------From: module_bc_ad.F
        call a_spec_bdyupdate( a_muts,a_mu_tend,dts_rk,'m',spec_zone, &
                               ids,ide,jds,jde,1,ims,ime,jms,jme,1,1, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij),1,1 )
        call a_spec_bdyupdate( a_mu_2,a_mu_tend,dts_rk,'m',spec_zone, &
                               ids,ide,jds,jde,1,ims,ime,jms,jme,1,1, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij),1,1 )
        call a_spec_bdyupdate( a_t_2,a_t_tend,dts_rk,'t',spec_zone, &
                               ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij),k_start,k_end )

!-----Output: a_muts,a_mu_tend,a_mu_2,a_t_2,a_t_tend

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SPEC_BDYUPDATE_TMU.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
      endif

!-----Restore for a_advance_mu_t:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mu_2,mut,muu,muv,mu_tend, "mu_2,mut,muu,muv,mu_tend")
      call pop2restore(t_2,t_save,t_2save,t_tend, &
                      "t_2,t_save,t_2save,t_tend")
      call pop2restore(ww,ww1,u_2,u_save,v_2,v_save,ru_m,rv_m,ww_m, &
                      "ww,ww1,u_2,u_save,v_2,v_save,ru_m,rv_m,ww_m")
      if(grid%trace_use) call trace_exit("restore")

      its = max(grid%i_start(ij)-2,ids)
      ite = min(grid%i_end(ij)+2,ide)
      jts = max(grid%j_start(ij)-2,jds)
      jte = min(grid%j_end(ij)+2,jde)

!-----From: module_small_step_em_ad.F
      call a_advance_mu_t( ww,a_ww,ww1,a_ww1,u_2,a_u_2,u_save,a_u_save,v_2,a_v_2,v_save,a_v_save, &
                           a_mu_2,a_mut,a_muave,a_muts,muu,a_muu,muv,a_muv,a_mudf, &
                           a_t_2,t_save,a_t_save,a_t_2save,a_t_tend, &
                           mu_tend,a_mu_tend,rdx,rdy,dts,epssm,dnw,fnm,fnp,rdnw, &
                           msfu,msfv,msft,config_flags, &
                           ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                           its,ite,jts,jte,k_start,k_end )

!-----Output: a_ww,a_ww1,a_u_2,a_u_save,a_v_2,a_v_save
!             a_mu_2,a_mut,a_muave,a_muts,a_muu,a_muv,a_mudf
!             a_t_2,a_t_save,a_t_2save,a_t_tend,a_mu_tend

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_ADVANCE_MU_T.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

      if (config_flags%specified .or. config_flags%nested) then
!-------Restore for a_spec_bdyupdate:
        if(grid%trace_use) call trace_entry("restore")
        call pop2restore(u_2,ru_tend,v_2,rv_tend, "u_2,ru_tend,v_2,rv_tend")
        if(grid%trace_use) call trace_exit("restore")

!-------From: module_bc_ad.F
        if(grid%trace_use) call trace_entry("restore")
        call a_spec_bdyupdate( a_v_2,a_rv_tend,dts_rk,'v',spec_zone, &
                               ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij),k_start,k_end )
        call a_spec_bdyupdate( a_u_2,a_ru_tend,dts_rk,'u',spec_zone, &
                               ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                               grid%i_start(ij),grid%i_end(ij), &
                               grid%j_start(ij),grid%j_end(ij),k_start,k_end )
        if(grid%trace_use) call trace_exit("restore")

!-------Output: a_u_2,a_ru_tend,a_v_2,a_rv_tend

#ifdef DM_PARALLEL
        if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SPEC_BDYUPDATE_UV.inc"
        if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
      endif

!-----Restore for a_advance_uv:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mu_2,muu,muv,mudf, "mu_2,muu,muv,mudf")
      call pop2restore(u_2,ru_tend,v_2,rv_tend,p,ph_2,alt,al,cqu,cqv, &
                      "u_2,ru_tend,v_2,rv_tend,p,ph_2,alt,al,cqu,cqv")
      call pop2restore(php, "php")
      if(grid%trace_use) call trace_exit("restore")

!-----From: module_small_step_em_ad.F
      call a_advance_uv( a_u_2,a_ru_tend,a_v_2,a_rv_tend,p,a_p,pb,ph_2,a_ph_2,php,a_php, &
                         alt,a_alt,al,a_al,mu_2,a_mu_2,muu,a_muu,&
                         cqu,a_cqu,muv,a_muv,cqv,a_cqv,a_mudf,rdx,rdy,dts,cf1,cf2,cf3, &
                         fnm,fnp,emdiv,rdnw,config_flags,spec_zone,non_hydrostatic,ids, &
                         ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                         its,ite,jts,jte,k_start,k_end )

!-----Output: a_u_2,a_ru_tend,a_v_2,a_rv_tend,a_p,a_ph_2,a_php
!             a_alt,a_al,a_mu_2,a_muu,a_cqu,a_muv,a_cqv,a_mudf

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_ADVANCE_UV.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  end do a_small_steps

!-if(grid%trace_use) call trace_exit("solve_ad_a_small_steps")

!------------------------------

    if (non_hydrostatic) then
!-----Restore for a_calc_coef_w:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mut, "mut")
      call pop2restore(a,alpha,gamma,cqw,c2a, "a,alpha,gamma,cqw,c2a")
      if(grid%trace_use) call trace_exit("restore")

      its = max(grid%i_start(ij)-1,ids)
      ite = min(grid%i_end(ij)+1,ide)
      jts = max(grid%j_start(ij)-1,jds)
      jte = min(grid%j_end(ij)+1,jde)

!-----From: module_small_step_em_ad.F
      call a_calc_coef_w( a,a_a,alpha,a_alpha,gamma,a_gamma,mut,a_mut, &
                          cqw,a_cqw,rdn,rdnw,c2a,a_c2a,dts,g,epssm, &
                          ide,jde,kde,ims,ime,jms,jme,kms,kme,&
                          its,ite,jts,jte )

!-----Output: a_a,a_alpha,a_gamma,a_mut,a_cqw,a_c2a

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALC_COEF_W.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

!-----Restore for a_calc_p_rho:
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mu_2,muts, "mu_2,muts")
      call pop2restore(ph_2,alt,t_2,t_save,c2a,pm1, "ph_2,alt,t_2,t_save,c2a,pm1")
      if(grid%trace_use) call trace_exit("restore")

!-----From: module_small_step_em_ad.F
      call a_calc_p_rho( al,a_al,p,a_p,ph_2,a_ph_2,alt,a_alt,t_2,a_t_2,t_save,a_t_save, &
                         c2a,a_c2a,a_pm1,mu_2,a_mu_2,muts,a_muts, &
                         znu,t0,rdnw,dnw,smdiv,non_hydrostatic,0, &
                         ide,jde,kde,ims,ime,jms,jme,kms,kme, &
                         its,ite,jts,jte,k_start,k_end )

!-----Output: a_al,a_p,a_ph_2,a_alt,a_t_2,a_t_save,a_c2a,a_pm1,a_mu_2,a_muts

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALC_P_RHO.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

!---Restore for small_step_prep
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(mu_1,mu_2,muu,muv,mut, "mu_1,mu_2,muu,muv,mut")
    call pop2restore(p,alt,ww, "p,alt,ww,")
    call pop2restore(u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2, &
                    "u_1,u_2,v_1,v_2,w_1,w_2,t_1,t_2,ph_1,ph_2")
    if(grid%trace_use) call trace_exit("restore")

!---From: module_small_step_em_ad.F
    call a_small_step_prep( u_1,a_u_1,u_2,a_u_2,v_1,a_v_1,v_2,a_v_2,w_1,a_w_1,w_2,a_w_2, &
                            t_1,a_t_1,t_2,a_t_2,a_ph_1,a_ph_2, &
                            mub,mu_1,a_mu_1,mu_2,a_mu_2,muu,a_muu,muus,a_muus, &
                            muv,a_muv,muvs,a_muvs,mut,a_mut,muts,a_muts,a_mudf, &
                            a_u_save,a_v_save,a_w_save,a_t_save,a_ph_save,a_mu_save,a_ww,a_ww1, &
                            a_c2a,pb,p,a_p,alt,a_alt,msfu,msfv,msft,rk_step,leapfrog, &
                            ide,jde,kde,ims,ime,jms,jme,kms,kme, &
                            its,ite,jts,jte,k_start,k_end )

!-----Output: a_u_1,a_u_2,a_v_1,a_v_2,a_w_1,a_w_2,a_t_1,a_t_2,a_ph_1,a_ph_2
!             a_mu_1,a_mu_2,a_muu,a_muus,a_muv,a_muvs,a_mut,a_muts,a_mudf
!             a_u_save,a_v_save,a_w_save,a_t_save,a_ph_save,a_mu_save,a_ww,a_ww1
!             a_c2a,a_p,a_alt

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SMALL_STEP_PREP.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

    if (config_flags%specified .or. config_flags%nested) then

      its = max(grid%i_start(ij)-2,ids)
      ite = min(grid%i_end(ij)+2,ide)
      jts = max(grid%j_start(ij)-2,jds)
      jte = min(grid%j_end(ij)+2,jde)

!-----From: module_bc_em_ad.F
      call a_spec_bdy_dry( config_flags,a_ru_tend,a_rv_tend,a_ph_tend,a_t_tend, &
                           a_rw_tend,a_mu_tend,a_u_bt,a_v_bt,a_ph_bt,a_t_bt, &
                           a_w_bt,a_mu_bt,spec_bdy_width,spec_zone, &
                           ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,&
                           its,ite,jts,jte,k_start,k_end )

!-----Output: a_ru_tend,a_rv_tend,a_ph_tend,a_t_tend,a_rw_tend,a_mu_tend

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_SPEC_BDY_DRY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif

!---From: module_em_ad.F
!---Restore for a_rk_addtend_dry:
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(mut,mu_tend, "mut,mu_tend")
    call pop2restore(u_save,v_save,w_save,ph_save,t_save,h_diabatic, &
                    "u_save,v_save,w_save,ph_save,t_save,h_diabatic")
    call pop2restore(ru_tend,rv_tend,rw_tend,ph_tend,t_tend,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf, &
                    "ru_tend,rv_tend,rw_tend,ph_tend,t_tend,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf")
    if(grid%trace_use) call trace_exit("restore")

      its = max(grid%i_start(ij)-2,ids)
      ite = min(grid%i_end(ij)+2,ide)
      jts = max(grid%j_start(ij)-2,jds)
      jte = min(grid%j_end(ij)+2,jde)

    call a_rk_addtend_dry( a_ru_tend,a_rv_tend,a_rw_tend,a_ph_tend,a_t_tend, &
                           a_ru_tendf,a_rv_tendf,a_rw_tendf,a_ph_tendf,a_t_tendf, &
                           a_u_save,a_v_save,a_w_save,a_ph_save,a_t_save,rk_step,h_diabatic, &
                           a_mut,msft,msfu,msfv, &
                           ide,jde,ims,ime,jms,jme,kms,kme,&
                           its,ite,jts,jte,k_start,k_end )

!---Output: a_ru_tend,a_rv_tend,a_rw_tend,a_ph_tend,a_t_tend, &
!           a_ru_tendf,a_rv_tendf,a_rw_tendf,a_ph_tendf,a_t_tendf, &
!           a_u_save,a_v_save,a_w_save,a_ph_save,a_t_save,a_mut

#ifdef DM_PARALLEL
    if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RK_ADDTEND_DRY.inc"
    if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

    if( (config_flags%specified .or. config_flags%nested) .and. rk_step==1 ) then
!-----Restore for a_relax_bdy_dry
      if(grid%trace_use) call trace_entry("restore")
      call pop2restore(mu_2,mut,mu_tend, "mu_2,mut,mu_tend")
      call pop2restore(ru,rv,ph_2,t_2,w_2,u_save,v_save,ph_save,t_save,w_save, &
                      "ru,rv,ph_2,t_2,w_2,u_save,v_save,ph_save,t_save,w_save")
      if(grid%trace_use) call trace_exit("restore")

      its = max(grid%i_start(ij)-2,ids)
      ite = min(grid%i_end(ij)+2,ide)
      jts = max(grid%j_start(ij)-2,jds)
      jte = min(grid%j_end(ij)+2,jde)

!-----From: module_bc_em_ad.F
      call a_relax_bdy_dry( config_flags,a_u_save,a_v_save,a_ph_save,a_t_save,a_w_save, &
                            a_mu_tend,a_ru,a_rv,ph_2,a_ph_2,t_2,a_t_2, &
                            w_2,a_w_2,a_mu_2,mut,a_mut,a_u_b,a_v_b,a_ph_b,a_t_b,a_w_b, &
                            a_mu_b,a_u_bt,a_v_bt,a_ph_bt,a_t_bt,a_w_bt,a_mu_bt,spec_bdy_width, &
                            spec_zone,relax_zone,dtbc,fcx,gcx, &
                            ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                            its,ite,jts,jte,k_start,k_end )

!-----Output: a_u_save,a_v_save,a_ph_save,a_t_save,a_w_save, &
!             a_mu_tend,a_ru,a_rv,a_ph_2,a_t_2,a_w_2,a_mu_2,a_mut

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RELAX_BDY_DRY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
    endif


!  IF (rk_step == 1 ) then
!    if(grid%trace_use) call trace_entry("restore")
!    call pop2restore(muu,muv, "muu,muv")
!    call pop2restore(ru_tendf,rv_tendf,u_2,v_2,z_at_w, "ru_tendf,rv_tendf,u_2,v_2,z_at_w")
!    call pop2restore(z, "z")
!    if(grid%trace_use) call trace_exit("restore")
!
!    call a_surface_drag(ru_tendf, a_ru_tendf, rv_tendf, a_rv_tendf, &
!                        u_2, a_u_2, v_2, a_v_2, xland, &
!                        muu, a_muu, muv, a_muv, z, &
!                        a_z, z_at_w, a_z_at_w, &
!                        ids, ide, jds, jde, kds, kde, &
!                        ims, ime, jms, jme, kms, kme, &
!                        grid%i_start(ij), grid%i_end(ij), &
!                        grid%j_start(ij), grid%j_end(ij), &
!                        k_start, k_end )
!   ENDIF
!---------------------------------------------------------------------------------------------
!
!---Restore for rk_tendency
    if(grid%trace_use) call trace_entry("restore")
!    call pop2restore(php, "php")
    call pop2restore(mu_2,mut,muu,muv, "mu_2,mut,muu,muv")
    call pop2restore(cqu,cqv,cqw,xkmhd,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf, &
                    "cqu,cqv,cqw,xkmhd,ru_tendf,rv_tendf,rw_tendf,ph_tendf,t_tendf")
    call pop2restore(ru,rv,rw,ww,t_init,al,alt,p, &
                    "ru,rv,rw,ww,t_init,al,alt,p")
    call pop2restore(u_2,v_2,w_2,t_2,ph_2,u_1,v_1,w_1,t_1,ph_1, &
                    "u_2,v_2,w_2,t_2,ph_2,u_1,v_1,w_1,t_1,ph_1")
    if(grid%trace_use) call trace_exit("restore")

    its = max(grid%i_start(ij)-3,ids)
    ite = min(grid%i_end(ij)+3,ide)
    jts = max(grid%j_start(ij)-3,jds)
    jte = min(grid%j_end(ij)+3,jde)


!---From: module_em_ad.F
    call a_rk_tendency1( config_flags,rk_step,a_ru_tend,a_rv_tend,a_rw_tend, &
                         a_ph_tend,a_t_tend,a_ru_tendf,a_rv_tendf,a_rw_tendf, &
                         a_t_tendf,a_mu_tend,a_u_save,a_v_save,a_w_save,a_ph_save, &
                         a_t_save,ru,a_ru,rv,a_rv,rw,a_rw,ww,a_ww, &
                         u_2,a_u_2,v_2,a_v_2,w_2,a_w_2,t_2,a_t_2,ph_2,a_ph_2, &
                         u_1,a_u_1,v_1,a_v_1,w_1,a_w_1,t_1,a_t_1,ph_1,a_ph_1,phb,t_init, &
                         mu_2,a_mu_2,mut,a_mut,muu,a_muu,muv,a_muv,mub, &
                         al,a_al,alt,a_alt,p,a_p,pb,php,a_php,cqu,a_cqu,cqv,a_cqv,cqw,a_cqw, &
                         u_base,v_base,z_base,msfu,msfv,msft, &
                         f,e,sina,cosa,fnm,fnp,rdn,rdnw,dt,rdx,rdy,kvdif,xkmhd,a_xkmhd, &
                         cf1,cf2,cf3,cfn,cfn1,non_hydrostatic,leapfrog, &
                         ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                         its,ite,jts,jte,k_start,k_end )

    call a_rk_tendency2( config_flags,rk_step,a_ru_tend,a_rv_tend,a_rw_tend,a_ph_tend,a_t_tend, &
                         a_ru_tendf,a_rv_tendf,a_rw_tendf,a_t_tendf,a_mu_tend, &
                         a_u_save,a_v_save,a_w_save,a_ph_save,a_t_save, &
                         ru,a_ru,rv,a_rv,rw,a_rw,ww,a_ww,u_2,a_u_2,v_2,a_v_2, &
                         w_2,a_w_2,t_2,a_t_2,ph_2,a_ph_2, &
                         u_1,a_u_1,v_1,a_v_1,w_1,a_w_1,t_1,a_t_1,ph_1,a_ph_1, &
                         phb,t_init,mu_2,a_mu_2,mut,a_mut,muu,a_muu,muv,a_muv,mub, &
                         al,a_al,alt,a_alt,p,a_p,pb,php,a_php, &
                         cqu,a_cqu,cqv,a_cqv,cqw,a_cqw,u_base,v_base,z_base, &
                         msfu,msfv,msft,f,e,sina,cosa,fnm,fnp,rdn,rdnw,dt, &
                         rdx,rdy,kvdif,xkmhd,a_xkmhd, &
                         cf1,cf2,cf3,cfn,cfn1,non_hydrostatic,leapfrog, &
                         ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,&
                         its,ite,jts,jte,k_start,k_end )

!-----Output: a_ru_tend,a_rv_tend,a_rw_tend,a_ph_tend,a_t_tend,a_ru_tendf,a_rv_tendf,a_rw_tendf, &
!             a_t_tendf,a_mu_tend,a_u_save,a_v_save,a_w_save,a_ph_save, &
!             a_t_save,a_ru,a_rv,a_rw,a_ww,a_u_2,a_v_2,a_w_2,a_t_2,a_ph_2, &
!             a_u_1,a_v_1,a_w_1,a_t_1,a_ph_1,a_mu_2,a_mut,a_muu,a_muv, &
!             a_al,a_alt,a_p,a_php,a_cqu,a_cqv,a_cqw

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RK_TENDENCY.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

  a_rk_step_is_one: if (rk_step .eq. 1) then

    its = max(grid%i_start(ij)-1,ids)
    ite = min(grid%i_end(ij)+1,ide)
    jts = max(grid%j_start(ij)-1,jds)
    jte = min(grid%j_end(ij)+1,jde)

    if (diff_opt .eq. 2 .or. diff_opt .eq. 1) then
!-------Resotore for a_calculate_km_kh:
        if(grid%trace_use) call trace_entry("restore")
        call pop2restore(moist_2, "moist_2")
        call pop2restore(div,tke_2,p8w,t8w,th_phy,t_phy,p_phy,rdz,rdzw, &
                        "div,tke_2,p8w,t8w,th_phy,t_phy,p_phy,rdz,rdzw")
        call pop2restore(defor11,defor22,defor33,defor12,defor13,defor23, &
                        "defor11,defor22,defor33,defor12,defor13,defor23")
        call pop2restore(xkmh,xkmhd,xkmv,xkhh,xkhv,bn2, "xkmh,xkmhd,xkmv,xkhh,xkhv,bn2")
        if(grid%trace_use) call trace_exit("restore")

!-------From: module_diffusion_em_ad.F
        call a_calculate_km_kh( config_flags,dt,dampcoef,zdamp,damp_opt, &
                                xkmh,xkmhd,a_xkmhd,xkmv,xkhh,xkhv,bn2,a_bn2,khdif,div,&
                                defor11,defor22,defor33,defor12,defor13,defor23, &
                                tke_2,p8w,a_p8w,t8w,a_t8w,th_phy,a_th_phy,t_phy,a_t_phy,&
                                p_phy,a_p_phy,moist_2,a_moist_2,dn,dnw,dx,dy,rdz,rdzw,num_3d_m, &
                                cf1,cf2,cf3,kh_tke_upper_bound, &
                                ids,ide,jds,jde,kde,ims,ime,jms,jme,kms,kme, &
                                its,ite,jts,jte,k_start,k_end )

!-------Output: a_p8w,a_t8w,a_th_phy,a_t_phy,a_p_phy,a_moist_2,a_bn2

#ifdef DM_PARALLEL
        if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_CALCULATE_KM_KH.inc"
        if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  endif

!-Save for: phy_prep:
  if(grid%trace_use) call trace_entry("restore")
  call pop2restore(th_phy,p_phy,pi_phy,t_phy, "th_phy,p_phy,pi_phy,t_phy")
  call pop2restore(z,z_at_w, "z,z_at_w")
  call pop2restore(tsk, mut, "tsk, mut")
  call pop2restore(p, u_2, v_2, alt, ph_2, t_2, "p, u_2, v_2, alt, ph_2, t_2")
  if(grid%trace_use) call trace_exit("restore")

!-From module_big_step_utilities_em_ad.F
  call a_phy_prep( p,a_p,pb,ph_2,a_ph_2,phb,t_2,a_t_2,th_phy,a_th_phy, &
                   p_phy,a_p_phy,pi_phy,a_pi_phy,a_p8w,t_phy,a_t_phy,a_t8w, &
                   z,a_z,z_at_w,a_z_at_w,fnm,fnp, &
                   ide,jde,kde,ims,ime,jms,jme,kms,kme, &
                   its,ite,jts,jte,k_start,k_end )

!-----Output: a_p,a_ph_2,a_t_2,a_th_phy,a_p_phy,a_pi_phy,a_p8w,a_t_phy,a_t8w,a_z,a_z_at_w

      call a_init_zero_tendency( a_ru_tendf,a_rv_tendf,a_rw_tendf,a_ph_tendf,a_t_tendf,a_moist_tend,num_3d_m,ims,ime,jms,jme,kms,&
&kme,&
        max(grid%i_start(ij)-1,ids),  &
        min(grid%i_end(ij)+1,ide),    &
        max(grid%j_start(ij)-1,jds),  &
        min(grid%j_end(ij)+1,jde),k_start,k_end )

  endif a_rk_step_is_one

!---Restore for a_rk_step_prep
    if(grid%trace_use) call trace_entry("restore")
    call pop2restore(moist_2, "moist_2")
    call pop2restore(mu_2, "mu_2")
    call pop2restore(u_2,v_2,w_2,t_2,ph_2,p,al, "u_2,v_2,w_2,t_2,ph_2,p,al")
    call pop2restore(muu,muv,mub,mut, "muu,muv,mub,mut")
    if(grid%trace_use) call trace_exit("restore")

    its = max(grid%i_start(ij)-1,ids)
    ite = min(grid%i_end(ij)+1,ide)
    jts = max(grid%j_start(ij)-1,jds)
    jte = min(grid%j_end(ij)+1,jde)

!---From: module_em_ad.F
    call a_rk_step_prep( config_flags,u_2,a_u_2,v_2,a_v_2,w_2,a_w_2,a_ph_2, &
                         mu_2,a_mu_2,moist_2,a_moist_2,a_ru,a_rv,a_rw,a_ww,a_php,&
                         a_alt,muu,a_muu,muv,a_muv,mub,mut,a_mut, &
                         a_al,a_cqu,a_cqv,a_cqw,msfu,msfv,msft,dnw,rdx,rdy,num_3d_m, &
                         ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme, &
                         its,ite,jts,jte,k_start,k_end )

!-----Output: a_u_2,a_v_2,a_w_2,a_ph_2,a_mu_2,a_moist_2,a_ru,a_rv,a_rw,a_ww,a_php,&
!             a_alt,a_muu,a_muv,a_mut,a_al,a_cqu,a_cqv,a_cqw

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_RK_STEP_PREP.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif

end do a_runge_kutta_loop

!---if(grid%trace_use) call trace_exit("solve_ad_a_runge_kutta_loop")

#ifdef DM_PARALLEL
      if(grid%trace_use) call trace_entry("solve_ad_halo_comm")
#include "HALO_A_PHY_PREP.inc"
      if(grid%trace_use) call trace_exit("solve_ad_halo_comm")
#endif
  CALL wrf_debug ( 10 , 'DEBUG:  end solve_em_ad()' )

  if(grid%trace_use) call trace_exit("solve_em_ad")

  RETURN

end SUBROUTINE solve_em_ad

!---------------------------------
!!!!  Add CUDU Here   !!!!!!!!
!--------------------------------

!        CALL wrf_debug ( 200 , ' call a_cumulus_driver' )
!        IF (cu_physics .eq. 5) then            !IF for CUDU
!           CALL wrf_debug(100,'in du_cps')

!              do j = grid%j_start(ij), min(grid%j_end(ij), jde-1)
!              do k = k_start, min(k_end, kde-1)
!              do i = grid%i_start(ij), min(grid%i_end(ij), ide-1)
!                 rho(i,k,j) = 1./alt(i,k,j)*(1.+moist_2(i,k,j,P_QV))
!                 u_phy(i,k,j) = 0.5*(u_2(i,k,j)+u_2(i+1,k,j))
!                 v_phy(i,k,j) = 0.5*(v_2(i,k,j)+v_2(i,k,j+1))
!                 rthcuten(i,k,j) = rthcuten(i,k,j)/mut(i,j)
!                 rqvcuten(i,k,j) = rqvcuten(i,k,j)/mut(i,j)
!              end do
!              end do
!              end do

!              do j = grid%j_start(ij), min(grid%j_end(ij), jde-1)
!              do k = k_start, kde-1
!              do i = grid%i_start(ij), min(grid%i_end(ij), ide-1)
!                 dz8w(i,k,j)= z_at_w(i,k+1,j)-z_at_w(i,k,j)
!              end do
!              end do
!              end do

!              do j = grid%j_start(ij), min(grid%j_end(ij), jde-1)
!              do i = grid%i_start(ij), min(grid%i_end(ij), ide-1)
!                 dz8w(i,kde,j) = 0.
!              end do
!              end do

!              CALL DUCU( ids,ide,jds,jde,kds,kde &
!              ,ims,ime,jms,jme,kms,kme &
!              ,grid%i_start(ij),min(grid%i_end(ij), ide-1)      &
!              ,grid%j_start(ij), min(grid%j_end(ij), jde-1)    &
!              ,k_start,min(k_end, kde-1) &
!              ,dt ,itimestep ,dx                    &
!              ,rho,raincv                       &
!              ,nca,u_phy ,v_phy                        &
!              ,th_phy,t_phy                   &
!              ,w_2                                           &
!              ,dz8w,z,p_phy                 &
!              ,pi_phy,grid%W0AVG,XLV              &
!              ,CP ,R_d ,R_v ,G ,EP_2             &
!              ,SVP1 ,SVP2 ,SVP3 ,SVPT0    &
!              ,stepcu                                   &
!              ,cu_act_flag ,warm_rain    &
!              ,HTOP,HBOT                           &
!              ,moist_2(ims,kms,jms,P_QV) &
!             ! optionals
!              ,rthcuten, rqvcuten )

!              do j = grid%j_start(ij), min(grid%j_end(ij), jde-1)
!              do i = grid%i_start(ij), min(grid%i_end(ij), ide-1)
!                 do k = k_start, min(k_end, kde-1)
!                    a_mut(I,J) = a_mut(I,J) + rqvcuten(I,K,J) * a_moist_tend(I,K,J,P_QV)
!                    a_rqvcuten(I,K,J) = a_rqvcuten(I,K,J) + a_moist_tend(I,K,J,P_QV) * mut(I,J)
!                    a_mut(I,J) = a_mut(I,J) + rthcuten(I,K,J) * a_t_tendf(I,K,J)
!                    a_rthcuten(I,K,J) = a_rthcuten(I,K,J) + a_t_tendf(I,K,J) * mut(I,J)
!                 end do
!                 a_raincv(I,J) = a_raincv(I,J) + a_rainc(I,J)
!              end do
!              end do

!              CALL DUCU_B( ids,ide,jds,jde,kds,kde &
!              ,ims,ime,jms,jme,kms,kme &
!              ,grid%i_start(ij),min(grid%i_end(ij), ide-1)      &
!              ,grid%j_start(ij), min(grid%j_end(ij), jde-1)    &
!              ,k_start,min(k_end, kde-1) &
!              ,dt ,itimestep ,dx                    &
!              ,rho,a_rho,raincv,a_raincv                       &
!              ,nca,u_phy ,v_phy                        &
!              ,th_phy,a_th_phy,t_phy,a_t_phy                   &
!              ,w_2                                           &
!              ,dz8w,a_dz8w,z,a_z,p_phy,a_p_phy                 &
!              ,pi_phy,grid%W0AVG,XLV              &
!              ,CP ,R_d ,R_v ,G ,EP_2             &
!              ,SVP1 ,SVP2 ,SVP3 ,SVPT0    &
!              ,stepcu                                   &
!              ,cu_act_flag ,warm_rain    &
!              ,HTOP,HBOT                           &
!              ,moist_2(ims,kms,jms,P_QV),a_moist_2(ims,kms,jms,P_QV)&
!              ,rthcuten,a_rthcuten, rqvcuten,a_rqvcuten ) ! optionals

!              do j = grid%j_start(ij), min(grid%j_end(ij), jde-1)
!              do k = k_start, min(k_end, kde-1)
!              do i = grid%i_start(ij), min(grid%i_end(ij), ide-1)
!                  a_rqvcuten(I,K,J) = a_rqvcuten(I,K,J) / mut(I,J)
!                  a_rthcuten(I,K,J) = a_rthcuten(I,K,J) / mut(I,J) 
!              end do
!              end do
!              end do
!          ENDIF
!---------------------------------
!!!! XIAO CUDU End Here   !!!!!!!!
!---------------------------------

