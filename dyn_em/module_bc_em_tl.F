!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     g_module_bc_em
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_bc
use g_module_bc
use module_configure
use module_wrf_error
use module_bc_em

USE module_trace, only : trace_entry, trace_exit

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains

subroutine g_relax_bdy_dry( config_flags, ru_tendf, g_ru_tendf, rv_tendf, g_rv_tendf, ph_tendf, g_ph_tendf, t_tendf, g_t_tendf, &
&rw_tendf, g_rw_tendf, mu_tend, g_mu_tend, ru, g_ru, rv, g_rv, ph, g_ph, t, g_t, w, g_w, mu, g_mu, mut, g_mut, u_b, g_u_b, v_b, &
&g_v_b, ph_b, g_ph_b, t_b, g_t_b, w_b, g_w_b, mu_b, g_mu_b, u_bt, g_u_bt, v_bt, g_v_bt, ph_bt, g_ph_bt, t_bt, g_t_bt, w_bt, g_w_bt,&
& mu_bt, g_mu_bt, spec_bdy_width, spec_zone, relax_zone, dtbc, fcx, gcx, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, &
&jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
type (grid_config_rec_type) config_flags
real, intent(in) :: dtbc
integer, intent(in) :: spec_bdy_width
real, intent(in) :: fcx(spec_bdy_width)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(in) :: g_mu(ims:ime,jms:jme)
integer, intent(in) :: ijde
integer, intent(in) :: ijds
real, intent(in) :: g_mu_b(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(in) :: g_mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(inout) :: g_mu_tend(ims:ime,jms:jme)
real, intent(in) :: g_mut(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(in) :: g_ph(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(in) :: g_ph_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: g_ph_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_ru(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_ru_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_rv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_rv_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_rw_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_t(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_t_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: g_t_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_u_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_v_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_w(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_w_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: gcx(spec_bdy_width)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu(ims:ime,jms:jme)
real, intent(in) :: mu_b(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(in) :: mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(inout) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: ph(ims:ime,kms:kme,jms:jme)
real, intent(in) :: ph_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: ph_tendf(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: relax_zone
real, intent(in) :: ru(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: ru_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: rv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: rv_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: rw_tendf(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: spec_zone
real, intent(in) :: t(ims:ime,kms:kme,jms:jme)
real, intent(in) :: t_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: t_tendf(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: v_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: w(ims:ime,kms:kme,jms:jme)
real, intent(in) :: w_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)

!==============================================
! declare local variables
!==============================================
real g_rfield(ims:ime,kms:kme,jms:jme)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
real rfield(ims:ime,kms:kme,jms:jme)

  call trace_entry("g_relax_bdy_dry")

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call g_relax_bdytend( ru,g_ru,ru_tendf,g_ru_tendf,u_b,g_u_b,u_bt,g_u_bt,'u',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,&
&ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
call g_relax_bdytend( rv,g_rv,rv_tendf,g_rv_tendf,v_b,g_v_b,v_bt,g_v_bt,'v',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,&
&ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
i_start = max(its-1,ids)
i_end = min(ite+1,ide-1)
j_start = max(jts-1,jds)
j_end = min(jte+1,jde-1)
do j = j_start, j_end
  do k = kts, kte
    do i = i_start, i_end
      g_rfield(i,k,j) = g_mut(i,j)*ph(i,k,j)+g_ph(i,k,j)*mut(i,j)
      rfield(i,k,j) = ph(i,k,j)*mut(i,j)
    end do
  end do
end do
call g_relax_bdytend( rfield,g_rfield,ph_tendf,g_ph_tendf,ph_b,g_ph_b,ph_bt,g_ph_bt,'h',spec_bdy_width,spec_zone,relax_zone,dtbc,&
&fcx,gcx,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
do j = j_start, j_end
  do k = kts, kte-1
    do i = i_start, i_end
      g_rfield(i,k,j) = g_mut(i,j)*t(i,k,j)+g_t(i,k,j)*mut(i,j)
      rfield(i,k,j) = t(i,k,j)*mut(i,j)
    end do
  end do
end do
call g_relax_bdytend( rfield,g_rfield,t_tendf,g_t_tendf,t_b,g_t_b,t_bt,g_t_bt,'t',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,&
&ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
call g_relax_bdytend( mu,g_mu,mu_tend,g_mu_tend,mu_b,g_mu_b,mu_bt,g_mu_bt,'m',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,&
&ijds,ijde,ids,ide,jds,jde,1,1,ims,ime,jms,jme,1,1,its,ite,jts,jte,1,1 )
if (config_flags%nested) then
  i_start = max(its-1,ids)
  i_end = min(ite+1,ide-1)
  j_start = max(jts-1,jds)
  j_end = min(jte+1,jde-1)
  do j = j_start, j_end
    do k = kts, kte
      do i = i_start, i_end
        g_rfield(i,k,j) = g_mut(i,j)*w(i,k,j)+g_w(i,k,j)*mut(i,j)
        rfield(i,k,j) = w(i,k,j)*mut(i,j)
      end do
    end do
  end do
  call g_relax_bdytend( rfield,g_rfield,rw_tendf,g_rw_tendf,w_b,g_w_b,w_bt,g_w_bt,'h',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,&
&gcx,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
endif

  call trace_exit("g_relax_bdy_dry")

end subroutine g_relax_bdy_dry


subroutine g_spec_bdy_dry( config_flags, ru_tend, g_ru_tend, rv_tend, g_rv_tend, ph_tend, g_ph_tend, t_tend, g_t_tend, rw_tend, &
&g_rw_tend, mu_tend, g_mu_tend, u_bt, g_u_bt, v_bt, g_v_bt, ph_bt, g_ph_bt, t_bt, g_t_bt, w_bt, g_w_bt, mu_bt, g_mu_bt, &
&spec_bdy_width, spec_zone, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
type (grid_config_rec_type) config_flags
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: spec_bdy_width
real, intent(in) :: g_mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(out) :: g_mu_tend(ims:ime,jms:jme)
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(in) :: g_ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(out) :: g_ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: g_ru_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: g_rv_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: g_rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(out) :: g_t_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: g_w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(out) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(out) :: ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: ru_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: rv_tend(ims:ime,kms:kme,jms:jme)
real, intent(out) :: rw_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: spec_zone
real, intent(in) :: t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(out) :: t_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(in) :: w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)

  call trace_entry("g_spec_bdy_dry")

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call g_spec_bdytend( ru_tend,g_ru_tend,u_bt,g_u_bt,'u',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,&
&kms,kme,its,ite,jts,jte,kts,kte )
call g_spec_bdytend( rv_tend,g_rv_tend,v_bt,g_v_bt,'v',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,&
&kms,kme,its,ite,jts,jte,kts,kte )
call g_spec_bdytend( ph_tend,g_ph_tend,ph_bt,g_ph_bt,'h',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,&
&jme,kms,kme,its,ite,jts,jte,kts,kte )
call g_spec_bdytend( t_tend,g_t_tend,t_bt,g_t_bt,'t',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,&
&kms,kme,its,ite,jts,jte,kts,kte )
call g_spec_bdytend( mu_tend,g_mu_tend,mu_bt,g_mu_bt,'m',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,1,1,ims,ime,jms,jme,1,&
&1,its,ite,jts,jte,1,1 )
if (config_flags%nested) then
  call g_spec_bdytend( rw_tend,g_rw_tend,w_bt,g_w_bt,'h',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,&
&jme,kms,kme,its,ite,jts,jte,kts,kte )
endif

  call trace_exit("g_spec_bdy_dry")

end subroutine g_spec_bdy_dry


subroutine g_spec_bdy_scalar( scalar_tend, g_scalar_tend, scalar_bt, g_scalar_bt, spec_bdy_width, spec_zone, ijds, ijde, ids, ide, &
&jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
integer, intent(in) :: spec_bdy_width
real, intent(in) :: g_scalar_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(out) :: g_scalar_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: scalar_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(out) :: scalar_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: spec_zone

  call trace_entry("g_spec_bdy_scalar")

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
call g_spec_bdytend( scalar_tend,g_scalar_tend,scalar_bt,g_scalar_bt,'q',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,&
&kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )

  call trace_exit("g_spec_bdy_scalar")

end subroutine g_spec_bdy_scalar


subroutine g_spec_bdyupdate_ph( ph_save, g_ph_save, field, g_field, field_tend, g_field_tend, mu_tend, g_mu_tend, muts, g_muts, dt,&
& variable_in, spec_zone, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
real, intent(in) :: dt
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: field_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: g_field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_field_tend(ims:ime,kms:kme,jms:jme)
real, intent(in) :: g_mu_tend(ims:ime,jms:jme)
real, intent(in) :: g_muts(ims:ime,jms:jme)
real, intent(in) :: g_ph_save(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
real, intent(in) :: ph_save(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
integer b_dist
real g_mu_old(its:ite,jts:jte)
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
real mu_old(its:ite,jts:jte)
character variable

  call trace_entry("g_spec_bdyupdate_ph")

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
variable = variable_in
if (variable .eq. 'U') then
  variable = 'u'
endif
if (variable .eq. 'V') then
  variable = 'v'
endif
if (variable .eq. 'M') then
  variable = 'm'
endif
if (variable .eq. 'H') then
  variable = 'h'
endif
ibs = ids
ibe = ide-1
itf = min(ite,ide-1)
jbs = jds
jbe = jde-1
jtf = min(jte,jde-1)
ktf = kde-1
if (variable .eq. 'u') then
  ibe = ide
endif
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
if (variable .eq. 'v') then
  jbe = jde
endif
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
if (variable .eq. 'm') then
  ktf = kte
endif
if (variable .eq. 'h') then
  ktf = kte
endif
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_mu_old(i,j) = (-(g_mu_tend(i,j)*dt))+g_muts(i,j)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        g_field(i,k,j) = g_field(i,k,j)*(mu_old(i,j)/muts(i,j))+g_field_tend(i,k,j)*(dt/muts(i,j))+g_mu_old(i,j)*(field(i,k,j)/&
&muts(i,j)+ph_save(i,k,j)/muts(i,j))+g_muts(i,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/&
&(muts(i,j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))+g_ph_save(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        g_mu_old(i,j) = (-(g_mu_tend(i,j)*dt))+g_muts(i,j)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        g_field(i,k,j) = g_field(i,k,j)*(mu_old(i,j)/muts(i,j))+g_field_tend(i,k,j)*(dt/muts(i,j))+g_mu_old(i,j)*(field(i,k,j)/&
&muts(i,j)+ph_save(i,k,j)/muts(i,j))+g_muts(i,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/&
&(muts(i,j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))+g_ph_save(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_mu_old(i,j) = (-(g_mu_tend(i,j)*dt))+g_muts(i,j)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        g_field(i,k,j) = g_field(i,k,j)*(mu_old(i,j)/muts(i,j))+g_field_tend(i,k,j)*(dt/muts(i,j))+g_mu_old(i,j)*(field(i,k,j)/&
&muts(i,j)+ph_save(i,k,j)/muts(i,j))+g_muts(i,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/&
&(muts(i,j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))+g_ph_save(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        g_mu_old(i,j) = (-(g_mu_tend(i,j)*dt))+g_muts(i,j)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        g_field(i,k,j) = g_field(i,k,j)*(mu_old(i,j)/muts(i,j))+g_field_tend(i,k,j)*(dt/muts(i,j))+g_mu_old(i,j)*(field(i,k,j)/&
&muts(i,j)+ph_save(i,k,j)/muts(i,j))+g_muts(i,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/&
&(muts(i,j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))+g_ph_save(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif

  call trace_exit("g_spec_bdyupdate_ph")

end subroutine g_spec_bdyupdate_ph


end module     g_module_bc_em


