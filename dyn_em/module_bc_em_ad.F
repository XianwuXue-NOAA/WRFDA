!                           DISCLAIMER
!
!   This file was generated by TAF version 1.7.18
!
!   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
!   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
!   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
!   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
!   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
!   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
!   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
!   OF THE POSSIBILITY OF SUCH DAMAGES.
!
!                           Haftungsbeschraenkung
!   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
!   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
!   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
!   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
!   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
!   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
!   Mitteilung darueber an FastOpt.
!
module     a_module_bc_em
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use module_bc
use a_module_bc
use module_configure
use module_wrf_error
use module_bc_em

USE module_trace, only : trace_entry, trace_exit

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

contains

subroutine a_relax_bdy_dry( config_flags, a_ru_tendf, a_rv_tendf, a_ph_tendf, a_t_tendf, a_rw_tendf, a_mu_tend, a_ru, a_rv, ph, &
&a_ph, t, a_t, w, a_w, a_mu, mut, a_mut, a_u_b, a_v_b, a_ph_b, a_t_b, a_w_b, a_mu_b, a_u_bt, a_v_bt, a_ph_bt, a_t_bt, a_w_bt, &
&a_mu_bt, spec_bdy_width, spec_zone, relax_zone, dtbc, fcx, gcx, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms,&
& kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_mu(ims:ime,jms:jme)
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: spec_bdy_width
real, intent(inout) :: a_mu_b(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(inout) :: a_mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
real, intent(inout) :: a_mu_tend(ims:ime,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ph(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(inout) :: a_ph_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_ph_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rw_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_t_tendf(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_v_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_w(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_w_b(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
type (grid_config_rec_type) config_flags
real, intent(in) :: dtbc
real, intent(in) :: fcx(spec_bdy_width)
real, intent(in) :: gcx(spec_bdy_width)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: ph(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: relax_zone
integer, intent(in) :: spec_zone
real, intent(in) :: t(ims:ime,kms:kme,jms:jme)
real, intent(in) :: w(ims:ime,kms:kme,jms:jme)

!==============================================
! declare local variables
!==============================================
real a_rfield(ims:ime,kms:kme,jms:jme)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k

!  call trace_entry("a_relax_bdy_dry")

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_rfield(:,:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (config_flags%nested) then
  i_start = max(its-1,ids)
! recompute : i_start
  i_end = min(ite+1,ide-1)
! recompute : i_end
  j_start = max(jts-1,jds)
! recompute : j_start
  j_end = min(jte+1,jde-1)
! recompute : j_end
  call a_relax_bdytend( a_rfield,a_rw_tendf,a_w_b,a_w_bt,'h',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,&
&jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
  do j = j_start, j_end
    do k = kts, kte
      do i = i_start, i_end
        a_mut(i,j) = a_mut(i,j)+a_rfield(i,k,j)*w(i,k,j)
        a_w(i,k,j) = a_w(i,k,j)+a_rfield(i,k,j)*mut(i,j)
        a_rfield(i,k,j) = 0.
      end do
    end do
  end do
endif
call a_relax_bdytend( a_mu,a_mu_tend,a_mu_b,a_mu_bt,'m',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,jds,jde,&
&1,1,ims,ime,jms,jme,1,1,its,ite,jts,jte,1,1 )
call a_relax_bdytend( a_rfield,a_t_tendf,a_t_b,a_t_bt,'t',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,jds,&
&jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
! recdepend vars : ids,its
! recompute pos : ASSIGN_STMT module_bc_em.f90:231
! recompute vars : i_start
i_start = max(its-1,ids)
! recompute vars : i_start
! recdepend vars : i_start,ide,ite
! recompute pos : ASSIGN_STMT module_bc_em.f90:232
! recompute vars : i_end
i_end = min(ite+1,ide-1)
! recompute vars : i_end
! recdepend vars : i_end,i_start,jds,jts
! recompute pos : ASSIGN_STMT module_bc_em.f90:233
! recompute vars : j_start
j_start = max(jts-1,jds)
! recompute vars : j_start
! recdepend vars : i_end,i_start,j_start,jde,jte
! recompute pos : ASSIGN_STMT module_bc_em.f90:234
! recompute vars : j_end
j_end = min(jte+1,jde-1)
! recompute vars : j_end
do j = j_start, j_end
  do k = kts, kte-1
    do i = i_start, i_end
      a_mut(i,j) = a_mut(i,j)+a_rfield(i,k,j)*t(i,k,j)
      a_t(i,k,j) = a_t(i,k,j)+a_rfield(i,k,j)*mut(i,j)
      a_rfield(i,k,j) = 0.
    end do
  end do
end do
call a_relax_bdytend( a_rfield,a_ph_tendf,a_ph_b,a_ph_bt,'h',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,&
&jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
! recdepend vars : ids,its
! recompute pos : ASSIGN_STMT module_bc_em.f90:231
! recompute vars : i_start
i_start = max(its-1,ids)
! recompute vars : i_start
! recdepend vars : i_start,ide,ite
! recompute pos : ASSIGN_STMT module_bc_em.f90:232
! recompute vars : i_end
i_end = min(ite+1,ide-1)
! recompute vars : i_end
! recdepend vars : i_end,i_start,jds,jts
! recompute pos : ASSIGN_STMT module_bc_em.f90:233
! recompute vars : j_start
j_start = max(jts-1,jds)
! recompute vars : j_start
! recdepend vars : i_end,i_start,j_start,jde,jte
! recompute pos : ASSIGN_STMT module_bc_em.f90:234
! recompute vars : j_end
j_end = min(jte+1,jde-1)
! recompute vars : j_end
do j = j_start, j_end
  do k = kts, kte
    do i = i_start, i_end
      a_mut(i,j) = a_mut(i,j)+a_rfield(i,k,j)*ph(i,k,j)
      a_ph(i,k,j) = a_ph(i,k,j)+a_rfield(i,k,j)*mut(i,j)
      a_rfield(i,k,j) = 0.
    end do
  end do
end do
call a_relax_bdytend( a_rv,a_rv_tendf,a_v_b,a_v_bt,'v',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,jds,jde,&
&kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )
call a_relax_bdytend( a_ru,a_ru_tendf,a_u_b,a_u_bt,'u',spec_bdy_width,spec_zone,relax_zone,dtbc,fcx,gcx,ijds,ijde,ids,ide,jds,jde,&
&kds,kde,ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte )

!  call trace_exit("a_relax_bdy_dry")

end subroutine a_relax_bdy_dry


subroutine a_spec_bdy_dry( config_flags, a_ru_tend, a_rv_tend, a_ph_tend, a_t_tend, a_rw_tend, a_mu_tend, a_u_bt, a_v_bt, a_ph_bt, &
&a_t_bt, a_w_bt, a_mu_bt, spec_bdy_width, spec_zone, ijds, ijde, ids, ide, jds, jde, kds, kde, ims, ime, jms, jme, kms, kme, its, &
&ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: spec_bdy_width
real, intent(inout) :: a_mu_bt(ijds:ijde,1:1,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
real, intent(inout) :: a_mu_tend(ims:ime,jms:jme)
integer, intent(in) :: kde
integer, intent(in) :: kds
real, intent(inout) :: a_ph_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_ph_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_ru_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rv_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_rw_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_t_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_t_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_u_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_v_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
real, intent(inout) :: a_w_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
type (grid_config_rec_type) config_flags
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone

!  call trace_entry("a_spec_bdy_dry")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
if (config_flags%nested) then
  call a_spec_bdytend( a_rw_tend,a_w_bt,'h',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,&
&ite,jts,jte,kts,kte )
endif
call a_spec_bdytend( a_mu_tend,a_mu_bt,'m',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,1,1,ims,ime,jms,jme,1,1,its,ite,jts,&
&jte,1,1 )
call a_spec_bdytend( a_t_tend,a_t_bt,'t',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,&
&ite,jts,jte,kts,kte )
call a_spec_bdytend( a_ph_tend,a_ph_bt,'h',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,&
&ite,jts,jte,kts,kte )
call a_spec_bdytend( a_rv_tend,a_v_bt,'v',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,&
&ite,jts,jte,kts,kte )
call a_spec_bdytend( a_ru_tend,a_u_bt,'u',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,kme,its,&
&ite,jts,jte,kts,kte )

!  call trace_exit("a_spec_bdy_dry")

end subroutine a_spec_bdy_dry


subroutine a_spec_bdy_scalar( a_scalar_tend, a_scalar_bt, spec_bdy_width, spec_zone, ijds, ijde, ids, ide, jds, jde, kds, kde, ims,&
& ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ijde
integer, intent(in) :: ijds
integer, intent(in) :: kde
integer, intent(in) :: kds
integer, intent(in) :: spec_bdy_width
real, intent(inout) :: a_scalar_bt(ijds:ijde,kds:kde,spec_bdy_width,4)
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_scalar_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kte
integer, intent(in) :: kts
integer, intent(in) :: spec_zone

!  call trace_entry("a_spec_bdy_scalar")

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
call a_spec_bdytend( a_scalar_tend,a_scalar_bt,'q',spec_bdy_width,spec_zone,ijds,ijde,ids,ide,jds,jde,kds,kde,ims,ime,jms,jme,kms,&
&kme,its,ite,jts,jte,kts,kte )

!  call trace_exit("a_spec_bdy_scalar")

end subroutine a_spec_bdy_scalar


subroutine a_spec_bdyupdate_ph( ph_save, a_ph_save, field, a_field, field_tend, a_field_tend, mu_tend, a_mu_tend, muts, a_muts, dt,&
& variable_in, spec_zone, ids, ide, jds, jde, kde, ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_field_tend(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mu_tend(ims:ime,jms:jme)
real, intent(inout) :: a_muts(ims:ime,jms:jme)
real, intent(inout) :: a_ph_save(ims:ime,kms:kme,jms:jme)
real, intent(in) :: dt
real, intent(inout) :: field(ims:ime,kms:kme,jms:jme)
real, intent(in) :: field_tend(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ids
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jds
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: mu_tend(ims:ime,jms:jme)
real, intent(in) :: muts(ims:ime,jms:jme)
real, intent(in) :: ph_save(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: spec_zone
character, intent(in) :: variable_in

!==============================================
! declare local variables
!==============================================
real a_mu_old(its:ite,jts:jte)
integer b_dist
real fieldh(ims:ime,kms:kme,jms:jme)
integer i
integer ibe
integer ibs
integer itf
integer j
integer jbe
integer jbs
integer jtf
integer k
integer ktf
real mu_old(its:ite,jts:jte)
character variable

!  call trace_entry("a_spec_bdyupdate_ph")

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
fieldh(:,:,:) = field(:,:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_mu_old(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
variable = variable_in
! recompute : variable
if (variable .eq. 'U') then
  variable = 'u'
endif
! recompute : variable
if (variable .eq. 'V') then
  variable = 'v'
endif
! recompute : variable
if (variable .eq. 'M') then
  variable = 'm'
endif
! recompute : variable
if (variable .eq. 'H') then
  variable = 'h'
endif
! recompute : variable
ibs = ids
! recompute : ibs
ibe = ide-1
! recompute : ibe
itf = min(ite,ide-1)
! recompute : itf
jbs = jds
! recompute : jbs
jbe = jde-1
! recompute : jbe
jtf = min(jte,jde-1)
! recompute : jtf
ktf = kde-1
! recompute : ktf
if (variable .eq. 'u') then
  ibe = ide
endif
! recompute : ibe
if (variable .eq. 'u') then
  itf = min(ite,ide)
endif
! recompute : itf
if (variable .eq. 'v') then
  jbe = jde
endif
! recompute : jbe
if (variable .eq. 'v') then
  jtf = min(jte,jde)
endif
! recompute : jtf
if (variable .eq. 'm') then
  ktf = kte
endif
! recompute : ktf
if (variable .eq. 'h') then
  ktf = kte
endif
! recompute : ktf
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute : field
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute : field
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute : field
if (ibe-itf .lt. spec_zone) then
  do i = max(its,ibe-spec_zone+1), itf
    b_dist = ibe-i
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
! recompute : mu_old
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*(dt/muts(i,j))
        a_mu_old(i,j) = a_mu_old(i,j)+a_field(i,k,j)*(field(i,k,j)/muts(i,j)+ph_save(i,k,j)/muts(i,j))
        a_muts(i,j) = a_muts(i,j)+a_field(i,k,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/(muts(i,&
&j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))
        a_ph_save(i,k,j) = a_ph_save(i,k,j)+a_field(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        a_field(i,k,j) = a_field(i,k,j)*(mu_old(i,j)/muts(i,j))
        a_mu_tend(i,j) = a_mu_tend(i,j)-a_mu_old(i,j)*dt
        a_muts(i,j) = a_muts(i,j)+a_mu_old(i,j)
        a_mu_old(i,j) = 0.
      end do
    end do
  end do
endif
field(:,:,:) = fieldh(:,:,:)
!  recdepend vars : dt,field,field_tend,ibe,ibs,itf,its,jbs,jtf,jts,ktf,
! kts,mu_tend,muts,ph_save,spec_zone
! recompute pos : IF_STMT module_bc_em.f90:71
! recompute vars : field
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute vars : field
!  recdepend vars : dt,field,field_tend,ibe,ibs,itf,its,jbe,jtf,jts,ktf,
! kts,mu_tend,muts,ph_save,spec_zone
! recompute pos : IF_STMT module_bc_em.f90:88
! recompute vars : field
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute vars : field
if (its-ibs .lt. spec_zone) then
  do i = its, min(itf,ibs+spec_zone-1)
    b_dist = i-ibs
! recompute : b_dist
    do k = kts, ktf
      do j = max(jts,b_dist+jbs+1), min(jtf,jbe-b_dist-1)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
! recompute : mu_old
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*(dt/muts(i,j))
        a_mu_old(i,j) = a_mu_old(i,j)+a_field(i,k,j)*(field(i,k,j)/muts(i,j)+ph_save(i,k,j)/muts(i,j))
        a_muts(i,j) = a_muts(i,j)+a_field(i,k,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/(muts(i,&
&j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))
        a_ph_save(i,k,j) = a_ph_save(i,k,j)+a_field(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        a_field(i,k,j) = a_field(i,k,j)*(mu_old(i,j)/muts(i,j))
        a_mu_tend(i,j) = a_mu_tend(i,j)-a_mu_old(i,j)*dt
        a_muts(i,j) = a_muts(i,j)+a_mu_old(i,j)
        a_mu_old(i,j) = 0.
      end do
    end do
  end do
endif
field(:,:,:) = fieldh(:,:,:)
!  recdepend vars : dt,field,field_tend,ibe,ibs,itf,its,jbs,jtf,jts,ktf,
! kts,mu_tend,muts,ph_save,spec_zone
! recompute pos : IF_STMT module_bc_em.f90:71
! recompute vars : field
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
        field(i,k,j) = field(i,k,j)*mu_old(i,j)/muts(i,j)+dt*field_tend(i,k,j)/muts(i,j)+ph_save(i,k,j)*(mu_old(i,j)/muts(i,j)-1.)
      end do
    end do
  end do
endif
! recompute vars : field
if (jbe-jtf .lt. spec_zone) then
  do j = max(jts,jbe-spec_zone+1), jtf
    b_dist = jbe-j
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
! recompute : mu_old
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*(dt/muts(i,j))
        a_mu_old(i,j) = a_mu_old(i,j)+a_field(i,k,j)*(field(i,k,j)/muts(i,j)+ph_save(i,k,j)/muts(i,j))
        a_muts(i,j) = a_muts(i,j)+a_field(i,k,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/(muts(i,&
&j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))
        a_ph_save(i,k,j) = a_ph_save(i,k,j)+a_field(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        a_field(i,k,j) = a_field(i,k,j)*(mu_old(i,j)/muts(i,j))
        a_mu_tend(i,j) = a_mu_tend(i,j)-a_mu_old(i,j)*dt
        a_muts(i,j) = a_muts(i,j)+a_mu_old(i,j)
        a_mu_old(i,j) = 0.
      end do
    end do
  end do
endif
field(:,:,:) = fieldh(:,:,:)
if (jts-jbs .lt. spec_zone) then
  do j = jts, min(jtf,jbs+spec_zone-1)
    b_dist = j-jbs
! recompute : b_dist
    do k = kts, ktf
      do i = max(its,b_dist+ibs), min(itf,ibe-b_dist)
        mu_old(i,j) = muts(i,j)-dt*mu_tend(i,j)
! recompute : mu_old
        a_field_tend(i,k,j) = a_field_tend(i,k,j)+a_field(i,k,j)*(dt/muts(i,j))
        a_mu_old(i,j) = a_mu_old(i,j)+a_field(i,k,j)*(field(i,k,j)/muts(i,j)+ph_save(i,k,j)/muts(i,j))
        a_muts(i,j) = a_muts(i,j)+a_field(i,k,j)*((-(field(i,k,j)*mu_old(i,j)/(muts(i,j)*muts(i,j))))-dt*field_tend(i,k,j)/(muts(i,&
&j)*muts(i,j))-ph_save(i,k,j)*(mu_old(i,j)/(muts(i,j)*muts(i,j))))
        a_ph_save(i,k,j) = a_ph_save(i,k,j)+a_field(i,k,j)*((-1)+mu_old(i,j)/muts(i,j))
        a_field(i,k,j) = a_field(i,k,j)*(mu_old(i,j)/muts(i,j))
        a_mu_tend(i,j) = a_mu_tend(i,j)-a_mu_old(i,j)*dt
        a_muts(i,j) = a_muts(i,j)+a_mu_old(i,j)
        a_mu_old(i,j) = 0.
      end do
    end do
  end do
endif

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

!  call trace_exit("a_spec_bdyupdate_ph")

end subroutine a_spec_bdyupdate_ph


end module     a_module_bc_em


