<HTML> <BODY BGCOLOR=#eeddee LINK=#0000aa VLINK=#0000ff ALINK=#ff0000 ><BASE TARGET="bottom_target"><PRE><a name='1'>
<font color=#447700>!WRF:DRIVER_LAYER:DOMAIN_OBJECT<a name='2'></font>
<font color=#447700>!<a name='3'></font>
<font color=#447700>!  Following are the routines contained within this MODULE:<a name='4'></font>
<a name='5'>
<font color=#447700>!  alloc_and_configure_domain        1. Allocate the space for a single domain (constants<a name='6'></font>
<font color=#447700>!                                       and null terminate pointers).<a name='7'></font>
<font color=#447700>!                                    2. Connect the domains as a linked list.<a name='8'></font>
<font color=#447700>!                                    3. Store all of the domain constants.<a name='9'></font>
<font color=#447700>!                                    4. CALL alloc_space_field.<a name='10'></font>
<a name='11'>
<font color=#447700>!  alloc_space_field                 1. Allocate space for the gridded data required for<a name='12'></font>
<font color=#447700>!                                       each domain.<a name='13'></font>
<a name='14'>
<font color=#447700>!  dealloc_space_domain              1. Reconnect linked list nodes since the current<a name='15'></font>
<font color=#447700>!                                       node is removed.<a name='16'></font>
<font color=#447700>!                                    2. CALL dealloc_space_field.<a name='17'></font>
<font color=#447700>!                                    3. Deallocate single domain.<a name='18'></font>
<a name='19'>
<font color=#447700>!  dealloc_space_field               1. Deallocate each of the fields for a particular<a name='20'></font>
<font color=#447700>!                                       domain.<a name='21'></font>
<a name='22'>
<font color=#447700>!  first_loc_integer                 1. Find the first incidence of a particular<a name='23'></font>
<font color=#447700>!                                       domain identifier from an array of domain<a name='24'></font>
<font color=#447700>!                                       identifiers.<a name='25'></font>
<a name='26'>
<A NAME='MODULE_DOMAIN'><A href='../../html_code/frame/module_domain.F.html#MODULE_DOMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_purple.gif" border=0></A><a name='27'>
<font color=#993300>MODULE </font><font color=#cc0000>module_domain</font> <A href='../../call_to/MODULE_DOMAIN.html' TARGET='index'>210</A><a name='28'>
<a name='29'>
   USE <A href='../../html_code/frame/module_driver_constants.F.html#MODULE_DRIVER_CONSTANTS'>module_driver_constants</A><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_DRIVER_CONSTANTS_11"><a name='30'>
   USE <A href='../../html_code/frame/module_machine.F.html#MODULE_MACHINE'>module_machine</A><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_MACHINE_9"><a name='31'>
   USE module_state_description<a name='32'>
   USE <A href='../../html_code/frame/module_configure.F.html#MODULE_CONFIGURE'>module_configure</A><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CONFIGURE_40"><a name='33'>
   USE <A href='../../html_code/frame/module_wrf_error.F.html#MODULE_WRF_ERROR'>module_wrf_error</A><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_WRF_ERROR_15"><a name='34'>
   USE WRF_ESMF_MOD<a name='35'>
<a name='36'>
   CHARACTER (LEN=80) program_name<a name='37'>
<a name='38'>
   <font color=#447700>!  An entire domain.  This contains multiple meteorological fields by having<a name='39'></font>
   <font color=#447700>!  arrays (such as "data_3d") of pointers for each field.  Also inside each<a name='40'></font>
   <font color=#447700>!  domain is a link to a couple of other domains, one is just the "next"<a name='41'></font>
   <font color=#447700>!  domain that is to be stored, the other is the next domain which happens to<a name='42'></font>
   <font color=#447700>!  also be on the "same_level".<a name='43'></font>
<a name='44'>
   TYPE domain_ptr<a name='45'>
      TYPE(domain), POINTER :: ptr<a name='46'>
   END TYPE domain_ptr<a name='47'>
<a name='48'>
   INTEGER, PARAMETER :: HISTORY_ALARM=1, AUXHIST1_ALARM=2, AUXHIST2_ALARM=3,     &amp;<a name='49'>
                         AUXHIST3_ALARM=4, AUXHIST4_ALARM=5, AUXHIST5_ALARM=6,    &amp;<a name='50'>
                         AUXINPUT1_ALARM=7, AUXINPUT2_ALARM=8, AUXINPUT3_ALARM=9, &amp;<a name='51'>
                         AUXINPUT4_ALARM=10, AUXINPUT5_ALARM=11,                  &amp;<a name='52'>
                         RESTART_ALARM=12, BOUNDARY_ALARM=13, INPUTOUT_ALARM=14,  &amp;  <font color=#447700>! for outputing input (e.g. for 3dvar)<a name='53'></font>
                         ALARM_SUBTIME=15,                                        &amp;<a name='54'>
                         MAX_WRF_ALARMS=20  <font color=#447700>! ESMF 2.0.1+ requires user to dimension alarm <a name='55'></font>
                                            <font color=#447700>! lists.  MAX_WRF_ALARMS must be big enough <a name='56'></font>
                                            <font color=#447700>! to include all of the above alarms.  <a name='57'></font>
<a name='58'>
#include &lt;<A href='../../html_code/include/state_subtypes.inc.html'>state_subtypes.inc</A>&gt;<A NAME="state_subtypes.inc_1"><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='59'>
<a name='60'>
   TYPE domain<a name='61'>
<a name='62'>
<font color=#447700>! SEE THE INCLUDE FILE FOR DEFINITIONS OF STATE FIELDS WITHIN THE DOMAIN DATA STRUCTURE<a name='63'></font>
#include &lt;<A href='../../html_code/include/state_struct.inc.html'>state_struct.inc</A>&gt;<A NAME="state_struct.inc_2"><A href='../../html_code/frame/module_domain.F.html#module_domain.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='64'>
<a name='65'>
      INTEGER                                             :: comms( max_comms ), shift_x, shift_y<a name='66'>
<a name='67'>
      INTEGER                                             :: id<a name='68'>
      INTEGER                                             :: domdesc<a name='69'>
      INTEGER                                             :: communicator<a name='70'>
      INTEGER                                             :: iocommunicator<a name='71'>
      INTEGER,POINTER                                     :: mapping(:,:)<a name='72'>
      INTEGER,POINTER                                     :: i_start(:),i_end(:)<a name='73'>
      INTEGER,POINTER                                     :: j_start(:),j_end(:)<a name='74'>
      INTEGER                                             :: max_tiles<a name='75'>
      INTEGER                                             :: num_tiles        <font color=#447700>! taken out of namelist 20000908<a name='76'></font>
      INTEGER                                             :: num_tiles_x      <font color=#447700>! taken out of namelist 20000908<a name='77'></font>
      INTEGER                                             :: num_tiles_y      <font color=#447700>! taken out of namelist 20000908<a name='78'></font>
      INTEGER                                             :: num_tiles_spec   <font color=#447700>! place to store number of tiles computed from <a name='79'></font>
                                                                              <font color=#447700>! externally specified params<a name='80'></font>
<a name='81'>
      TYPE(domain_ptr) , DIMENSION( : ) , POINTER         :: parents                            <a name='82'>
      TYPE(domain_ptr) , DIMENSION( : ) , POINTER         :: nests                            <a name='83'>
      TYPE(domain) , POINTER                              :: sibling <font color=#447700>! overlapped domains at same lev<a name='84'></font>
      TYPE(domain) , POINTER                              :: intermediate_grid<a name='85'>
      INTEGER                                             :: num_parents, num_nests, num_siblings<a name='86'>
      INTEGER      , DIMENSION( max_parents )             :: child_of_parent<a name='87'>
      INTEGER      , DIMENSION( max_nests )               :: active<a name='88'>
<a name='89'>
      INTEGER      , DIMENSION(0:5)                       :: nframes          <font color=#447700>! frames per outfile for history <a name='90'></font>
                                                                              <font color=#447700>! streams (0 is main history)                  <a name='91'></font>
<a name='92'>
      TYPE(domain) , POINTER                              :: next<a name='93'>
      TYPE(domain) , POINTER                              :: same_level<a name='94'>
<a name='95'>
      LOGICAL      , DIMENSION ( 4 )                      :: bdy_mask         <font color=#447700>! which boundaries are on processor<a name='96'></font>
<a name='97'>
      LOGICAL                                             :: first_force<a name='98'>
<a name='99'>
<a name='100'>
      <font color=#447700>! domain dimensions<a name='101'></font>
<a name='102'>
      INTEGER    :: sd31,   ed31,   sd32,   ed32,   sd33,   ed33,         &amp;<a name='103'>
                    sd21,   ed21,   sd22,   ed22,                         &amp;<a name='104'>
                    sd11,   ed11<a name='105'>
<a name='106'>
      INTEGER    :: sp31,   ep31,   sp32,   ep32,   sp33,   ep33,         &amp;<a name='107'>
                    sp21,   ep21,   sp22,   ep22,                         &amp;<a name='108'>
                    sp11,   ep11,                                         &amp;<a name='109'>
                    sm31,   em31,   sm32,   em32,   sm33,   em33,         &amp;<a name='110'>
                    sm21,   em21,   sm22,   em22,                         &amp;<a name='111'>
                    sm11,   em11,                                         &amp;<a name='112'>
                    sp31x,  ep31x,  sp32x,  ep32x,  sp33x,  ep33x,        &amp;<a name='113'>
                    sp21x,  ep21x,  sp22x,  ep22x,                        &amp;<a name='114'>
                    sm31x,  em31x,  sm32x,  em32x,  sm33x,  em33x,        &amp;<a name='115'>
                    sm21x,  em21x,  sm22x,  em22x,                        &amp;<a name='116'>
                    sp31y,  ep31y,  sp32y,  ep32y,  sp33y,  ep33y,        &amp;<a name='117'>
                    sp21y,  ep21y,  sp22y,  ep22y,                        &amp;<a name='118'>
                    sm31y,  em31y,  sm32y,  em32y,  sm33y,  em33y,        &amp;<a name='119'>
                    sm21y,  em21y,  sm22y,  em22y<a name='120'>
      Type(ESMF_Clock)                                    :: domain_clock<a name='121'>
      Type(ESMF_Time)                                     :: start_time, stop_time, current_time<a name='122'>
      Type(ESMF_Time)                                     :: start_subtime, stop_subtime<a name='123'>
      Type(ESMF_Time)                                     :: this_bdy_time, next_bdy_time<a name='124'>
      Type(ESMF_Time)                                     :: this_emi_time, next_emi_time<a name='125'>
      Type(ESMF_TimeInterval) :: step_time<a name='126'>
      Type(ESMF_Alarm), pointer :: alarms(:)<a name='127'>
<a name='128'>
   END TYPE domain<a name='129'>
<a name='130'>
   <font color=#447700>!  Now that a "domain" TYPE exists, we can use it to store a few pointers<a name='131'></font>
   <font color=#447700>!  to this type.  These are primarily for use in traversing the linked list.<a name='132'></font>
   <font color=#447700>!  The "head_grid" is always the pointer to the first domain that is<a name='133'></font>
   <font color=#447700>!  allocated.  This is available and is not to be changed.  The others are<a name='134'></font>
   <font color=#447700>!  just temporary pointers.<a name='135'></font>
<a name='136'>
   TYPE(domain) , POINTER :: head_grid , new_grid , next_grid , old_grid<a name='137'>
<a name='138'>
   <font color=#447700>!  To facilitate an easy integration of each of the domains that are on the<a name='139'></font>
   <font color=#447700>!  same level, we have an array for the head pointer for each level.  This<a name='140'></font>
   <font color=#447700>!  removed the need to search through the linked list at each time step to<a name='141'></font>
   <font color=#447700>!  find which domains are to be active.<a name='142'></font>
<a name='143'>
   TYPE domain_levels<a name='144'>
      TYPE(domain) , POINTER                              :: first_domain<a name='145'>
   END TYPE domain_levels<a name='146'>
<a name='147'>
   TYPE(domain_levels) , DIMENSION(max_levels)            :: head_for_each_level<a name='148'>
   <a name='149'>
CONTAINS<a name='150'>
<a name='151'>
<A NAME='ADJUST_DOMAIN_DIMS_FOR_MOVE'><A href='../../html_code/frame/module_domain.F.html#ADJUST_DOMAIN_DIMS_FOR_MOVE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='152'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>adjust_domain_dims_for_move</font>( grid , dx, dy ) <A href='../../call_to/ADJUST_DOMAIN_DIMS_FOR_MOVE.html' TARGET='index'>1</A>,<A href='../../call_from/ADJUST_DOMAIN_DIMS_FOR_MOVE.html' TARGET='index'>2</A><a name='153'>
    IMPLICIT NONE<a name='154'>
<a name='155'>
    TYPE( domain ), POINTER   :: grid<a name='156'>
    INTEGER, INTENT(IN) ::  dx, dy<a name='157'>
<a name='158'>
    data_ordering : SELECT CASE ( model_data_order )<a name='159'>
       CASE  ( DATA_ORDER_XYZ )<a name='160'>
            grid%sm31  =             grid%sm31 + dx<a name='161'>
            grid%em31  =             grid%em31 + dx<a name='162'>
            grid%sm32  =             grid%sm32 + dy<a name='163'>
            grid%em32  =             grid%em32 + dy<a name='164'>
            grid%sp31  =             grid%sp31 + dx<a name='165'>
            grid%ep31  =             grid%ep31 + dx<a name='166'>
            grid%sp32  =             grid%sp32 + dy<a name='167'>
            grid%ep32  =             grid%ep32 + dy<a name='168'>
<a name='169'>
       CASE  ( DATA_ORDER_YXZ )<a name='170'>
            grid%sm31  =             grid%sm31 + dy<a name='171'>
            grid%em31  =             grid%em31 + dy<a name='172'>
            grid%sm32  =             grid%sm32 + dx<a name='173'>
            grid%em32  =             grid%em32 + dx<a name='174'>
            grid%sp31  =             grid%sp31 + dy<a name='175'>
            grid%ep31  =             grid%ep31 + dy<a name='176'>
            grid%sp32  =             grid%sp32 + dx<a name='177'>
            grid%ep32  =             grid%ep32 + dx<a name='178'>
<a name='179'>
       CASE  ( DATA_ORDER_ZXY )<a name='180'>
            grid%sm32  =             grid%sm32 + dx<a name='181'>
            grid%em32  =             grid%em32 + dx<a name='182'>
            grid%sm33  =             grid%sm33 + dy<a name='183'>
            grid%em33  =             grid%em33 + dy<a name='184'>
            grid%sp32  =             grid%sp32 + dx<a name='185'>
            grid%ep32  =             grid%ep32 + dx<a name='186'>
            grid%sp33  =             grid%sp33 + dy<a name='187'>
            grid%ep33  =             grid%ep33 + dy<a name='188'>
<a name='189'>
       CASE  ( DATA_ORDER_ZYX )<a name='190'>
            grid%sm32  =             grid%sm32 + dy<a name='191'>
            grid%em32  =             grid%em32 + dy<a name='192'>
            grid%sm33  =             grid%sm33 + dx<a name='193'>
            grid%em33  =             grid%em33 + dx<a name='194'>
            grid%sp32  =             grid%sp32 + dy<a name='195'>
            grid%ep32  =             grid%ep32 + dy<a name='196'>
            grid%sp33  =             grid%sp33 + dx<a name='197'>
            grid%ep33  =             grid%ep33 + dx<a name='198'>
<a name='199'>
       CASE  ( DATA_ORDER_XZY )<a name='200'>
            grid%sm31  =             grid%sm31 + dx<a name='201'>
            grid%em31  =             grid%em31 + dx<a name='202'>
            grid%sm33  =             grid%sm33 + dy<a name='203'>
            grid%em33  =             grid%em33 + dy<a name='204'>
            grid%sp31  =             grid%sp31 + dx<a name='205'>
            grid%ep31  =             grid%ep31 + dx<a name='206'>
            grid%sp33  =             grid%sp33 + dy<a name='207'>
            grid%ep33  =             grid%ep33 + dy<a name='208'>
<a name='209'>
       CASE  ( DATA_ORDER_YZX )<a name='210'>
            grid%sm31  =             grid%sm31 + dy<a name='211'>
            grid%em31  =             grid%em31 + dy<a name='212'>
            grid%sm33  =             grid%sm33 + dx<a name='213'>
            grid%em33  =             grid%em33 + dx<a name='214'>
            grid%sp31  =             grid%sp31 + dy<a name='215'>
            grid%ep31  =             grid%ep31 + dy<a name='216'>
            grid%sp33  =             grid%sp33 + dx<a name='217'>
            grid%ep33  =             grid%ep33 + dx<a name='218'>
<a name='219'>
    END SELECT data_ordering<a name='220'>
<a name='221'>
    CALL <A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD'>dealloc_space_field</A><A href='../../html_code/frame/module_domain.F.html#ADJUST_DOMAIN_DIMS_FOR_MOVE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DEALLOC_SPACE_FIELD_1"> ( grid )<a name='222'>
<a name='223'>
    CALL <A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD'>alloc_space_field</A><A href='../../html_code/frame/module_domain.F.html#ADJUST_DOMAIN_DIMS_FOR_MOVE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ALLOC_SPACE_FIELD_1"> ( grid, grid%id , 1 ,          &amp;<a name='224'>
                             grid%sd31, grid%ed31, grid%sd32, grid%ed32, grid%sd33, grid%ed33, &amp;<a name='225'>
                             grid%sm31,  grid%em31,  grid%sm32,  grid%em32,  grid%sm33,  grid%em33, &amp;<a name='226'>
                             grid%sm31x, grid%em31x, grid%sm32x, grid%em32x, grid%sm33x, grid%em33x, &amp;   <font color=#447700>! x-xpose<a name='227'></font>
                             grid%sm31y, grid%em31y, grid%sm32y, grid%em32y, grid%sm33y, grid%em33y  &amp;   <font color=#447700>! y-xpose<a name='228'></font>
      )<a name='229'>
<a name='230'>
    RETURN<a name='231'>
<a name='232'>
   END SUBROUTINE adjust_domain_dims_for_move<a name='233'>
<a name='234'>
<a name='235'>
<A NAME='GET_IJK_FROM_GRID'><A href='../../html_code/frame/module_domain.F.html#GET_IJK_FROM_GRID' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='236'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>get_ijk_from_grid</font> (  grid ,                   &amp; <A href='../../call_to/GET_IJK_FROM_GRID.html' TARGET='index'>47</A><a name='237'>
                           ids, ide, jds, jde, kds, kde,    &amp;<a name='238'>
                           ims, ime, jms, jme, kms, kme,    &amp;<a name='239'>
                           ips, ipe, jps, jpe, kps, kpe    )<a name='240'>
<a name='241'>
    IMPLICIT NONE<a name='242'>
<a name='243'>
    TYPE( domain ), INTENT (IN)  :: grid<a name='244'>
    INTEGER, INTENT(OUT) ::                                 &amp;<a name='245'>
                           ids, ide, jds, jde, kds, kde,    &amp;<a name='246'>
                           ims, ime, jms, jme, kms, kme,    &amp;<a name='247'>
                           ips, ipe, jps, jpe, kps, kpe<a name='248'>
<a name='249'>
    data_ordering : SELECT CASE ( model_data_order )<a name='250'>
       CASE  ( DATA_ORDER_XYZ )<a name='251'>
           ids             = grid%sd31 <a name='252'>
           ide             = grid%ed31 <a name='253'>
           jds             = grid%sd32 <a name='254'>
           jde             = grid%ed32 <a name='255'>
           kds             = grid%sd33 <a name='256'>
           kde             = grid%ed33 <a name='257'>
           ims             = grid%sm31 <a name='258'>
           ime             = grid%em31 <a name='259'>
           jms             = grid%sm32 <a name='260'>
           jme             = grid%em32 <a name='261'>
           kms             = grid%sm33 <a name='262'>
           kme             = grid%em33 <a name='263'>
           ips             = grid%sp31 <a name='264'>
           ipe             = grid%ep31 <a name='265'>
           jps             = grid%sp32 <a name='266'>
           jpe             = grid%ep32 <a name='267'>
           kps             = grid%sp33 <a name='268'>
           kpe             = grid%ep33 <a name='269'>
<a name='270'>
       CASE  ( DATA_ORDER_YXZ )<a name='271'>
           ids             = grid%sd32 <a name='272'>
           ide             = grid%ed32 <a name='273'>
           jds             = grid%sd31 <a name='274'>
           jde             = grid%ed31 <a name='275'>
           kds             = grid%sd33 <a name='276'>
           kde             = grid%ed33 <a name='277'>
           ims             = grid%sm32 <a name='278'>
           ime             = grid%em32 <a name='279'>
           jms             = grid%sm31 <a name='280'>
           jme             = grid%em31 <a name='281'>
           kms             = grid%sm33 <a name='282'>
           kme             = grid%em33 <a name='283'>
           ips             = grid%sp32 <a name='284'>
           ipe             = grid%ep32 <a name='285'>
           jps             = grid%sp31 <a name='286'>
           jpe             = grid%ep31 <a name='287'>
           kps             = grid%sp33 <a name='288'>
           kpe             = grid%ep33 <a name='289'>
<a name='290'>
       CASE  ( DATA_ORDER_ZXY )<a name='291'>
           ids             = grid%sd32 <a name='292'>
           ide             = grid%ed32 <a name='293'>
           jds             = grid%sd33 <a name='294'>
           jde             = grid%ed33 <a name='295'>
           kds             = grid%sd31 <a name='296'>
           kde             = grid%ed31 <a name='297'>
           ims             = grid%sm32 <a name='298'>
           ime             = grid%em32 <a name='299'>
           jms             = grid%sm33 <a name='300'>
           jme             = grid%em33 <a name='301'>
           kms             = grid%sm31 <a name='302'>
           kme             = grid%em31 <a name='303'>
           ips             = grid%sp32 <a name='304'>
           ipe             = grid%ep32 <a name='305'>
           jps             = grid%sp33 <a name='306'>
           jpe             = grid%ep33 <a name='307'>
           kps             = grid%sp31 <a name='308'>
           kpe             = grid%ep31 <a name='309'>
<a name='310'>
       CASE  ( DATA_ORDER_ZYX )<a name='311'>
           ids             = grid%sd33 <a name='312'>
           ide             = grid%ed33 <a name='313'>
           jds             = grid%sd32 <a name='314'>
           jde             = grid%ed32 <a name='315'>
           kds             = grid%sd31 <a name='316'>
           kde             = grid%ed31 <a name='317'>
           ims             = grid%sm33 <a name='318'>
           ime             = grid%em33 <a name='319'>
           jms             = grid%sm32 <a name='320'>
           jme             = grid%em32 <a name='321'>
           kms             = grid%sm31 <a name='322'>
           kme             = grid%em31 <a name='323'>
           ips             = grid%sp33 <a name='324'>
           ipe             = grid%ep33 <a name='325'>
           jps             = grid%sp32 <a name='326'>
           jpe             = grid%ep32 <a name='327'>
           kps             = grid%sp31 <a name='328'>
           kpe             = grid%ep31 <a name='329'>
<a name='330'>
       CASE  ( DATA_ORDER_XZY )<a name='331'>
           ids             = grid%sd31 <a name='332'>
           ide             = grid%ed31 <a name='333'>
           jds             = grid%sd33 <a name='334'>
           jde             = grid%ed33 <a name='335'>
           kds             = grid%sd32 <a name='336'>
           kde             = grid%ed32 <a name='337'>
           ims             = grid%sm31 <a name='338'>
           ime             = grid%em31 <a name='339'>
           jms             = grid%sm33 <a name='340'>
           jme             = grid%em33 <a name='341'>
           kms             = grid%sm32 <a name='342'>
           kme             = grid%em32 <a name='343'>
           ips             = grid%sp31 <a name='344'>
           ipe             = grid%ep31 <a name='345'>
           jps             = grid%sp33 <a name='346'>
           jpe             = grid%ep33 <a name='347'>
           kps             = grid%sp32 <a name='348'>
           kpe             = grid%ep32 <a name='349'>
<a name='350'>
       CASE  ( DATA_ORDER_YZX )<a name='351'>
           ids             = grid%sd33 <a name='352'>
           ide             = grid%ed33 <a name='353'>
           jds             = grid%sd31 <a name='354'>
           jde             = grid%ed31 <a name='355'>
           kds             = grid%sd32 <a name='356'>
           kde             = grid%ed32 <a name='357'>
           ims             = grid%sm33 <a name='358'>
           ime             = grid%em33 <a name='359'>
           jms             = grid%sm31 <a name='360'>
           jme             = grid%em31 <a name='361'>
           kms             = grid%sm32 <a name='362'>
           kme             = grid%em32 <a name='363'>
           ips             = grid%sp33 <a name='364'>
           ipe             = grid%ep33 <a name='365'>
           jps             = grid%sp31 <a name='366'>
           jpe             = grid%ep31 <a name='367'>
           kps             = grid%sp32 <a name='368'>
           kpe             = grid%ep32 <a name='369'>
<a name='370'>
    END SELECT data_ordering<a name='371'>
   END SUBROUTINE get_ijk_from_grid<a name='372'>
<a name='373'>
<font color=#447700>! Default version ; Otherwise module containing interface to DM library will provide<a name='374'></font>
<a name='375'>
<A NAME='WRF_PATCH_DOMAIN'><A href='../../html_code/frame/module_domain.F.html#WRF_PATCH_DOMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='376'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>wrf_patch_domain</font>( id , domdesc , parent, parent_id , parent_domdesc , &amp; <A href='../../call_to/WRF_PATCH_DOMAIN.html' TARGET='index'>1</A>,<A href='../../call_from/WRF_PATCH_DOMAIN.html' TARGET='index'>1</A><a name='377'>
                            sd1 , ed1 , sp1 , ep1 , sm1 , em1 , &amp;<a name='378'>
                            sd2 , ed2 , sp2 , ep2 , sm2 , em2 , &amp;<a name='379'>
                            sd3 , ed3 , sp3 , ep3 , sm3 , em3 , &amp;<a name='380'>
                                        sp1x , ep1x , sm1x , em1x , &amp;<a name='381'>
                                        sp2x , ep2x , sm2x , em2x , &amp;<a name='382'>
                                        sp3x , ep3x , sm3x , em3x , &amp;<a name='383'>
                                        sp1y , ep1y , sm1y , em1y , &amp;<a name='384'>
                                        sp2y , ep2y , sm2y , em2y , &amp;<a name='385'>
                                        sp3y , ep3y , sm3y , em3y , &amp;<a name='386'>
                            bdx , bdy , bdy_mask )<a name='387'>
<font color=#447700>!&lt;DESCRIPTION&gt;<a name='388'></font>
<font color=#447700>! Wrf_patch_domain is called as part of the process of initiating a new<a name='389'></font>
<font color=#447700>! domain.  Based on the global domain dimension information that is<a name='390'></font>
<font color=#447700>! passed in it computes the patch and memory dimensions on this<a name='391'></font>
<font color=#447700>! distributed-memory process for parallel compilation when DM_PARALLEL is<a name='392'></font>
<font color=#447700>! defined in configure.wrf.  In this case, it relies on an external<a name='393'></font>
<font color=#447700>! communications package-contributed routine, wrf_dm_patch_domain. For<a name='394'></font>
<font color=#447700>! non-parallel compiles, it returns the patch and memory dimensions based<a name='395'></font>
<font color=#447700>! on the entire domain. In either case, the memory dimensions will be<a name='396'></font>
<font color=#447700>! larger than the patch dimensions, since they allow for distributed<a name='397'></font>
<font color=#447700>! memory halo regions (DM_PARALLEL only) and for boundary regions around<a name='398'></font>
<font color=#447700>! the domain (used for idealized cases only).  The width of the boundary<a name='399'></font>
<font color=#447700>! regions to be accommodated is passed in as bdx and bdy.<a name='400'></font>
<font color=#447700>! <a name='401'></font>
<font color=#447700>! The bdy_mask argument is a four-dimensional logical array, each element<a name='402'></font>
<font color=#447700>! of which is set to true for any boundaries that this process's patch<a name='403'></font>
<font color=#447700>! contains (all four are true in the non-DM_PARALLEL case) and false<a name='404'></font>
<font color=#447700>! otherwise. The indices into the bdy_mask are defined in<a name='405'></font>
<font color=#447700>! frame/module_state_description.F. P_XSB corresponds boundary that<a name='406'></font>
<font color=#447700>! exists at the beginning of the X-dimension; ie. the western boundary;<a name='407'></font>
<font color=#447700>! P_XEB to the boundary that corresponds to the end of the X-dimension<a name='408'></font>
<font color=#447700>! (east). Likewise for Y (south and north respectively).<a name='409'></font>
<font color=#447700>! <a name='410'></font>
<font color=#447700>! The correspondence of the first, second, and third dimension of each<a name='411'></font>
<font color=#447700>! set (domain, memory, and patch) with the coordinate axes of the model<a name='412'></font>
<font color=#447700>! domain is based on the setting of the variable model_data_order, which<a name='413'></font>
<font color=#447700>! comes into this routine through USE association of<a name='414'></font>
<font color=#447700>! module_driver_constants in the enclosing module of this routine,<a name='415'></font>
<font color=#447700>! module_domain.  Model_data_order is defined by the Registry, based on<a name='416'></font>
<font color=#447700>! the dimspec entries which associate dimension specifiers (e.g. 'k') in<a name='417'></font>
<font color=#447700>! the Registry with a coordinate axis and specify which dimension of the<a name='418'></font>
<font color=#447700>! arrays they represent. For WRF, the sd1 , ed1 , sp1 , ep1 , sm1 , and<a name='419'></font>
<font color=#447700>! em1 correspond to the starts and ends of the global, patch, and memory<a name='420'></font>
<font color=#447700>! dimensions in X; those with 2 specify Z (vertical); and those with 3<a name='421'></font>
<font color=#447700>! specify Y.  Note that the WRF convention is to overdimension to allow<a name='422'></font>
<font color=#447700>! for staggered fields so that sd&lt;em&gt;n&lt;/em&gt;:ed&lt;em&gt;n&lt;/em&gt; are the starts<a name='423'></font>
<font color=#447700>! and ends of the staggered domains in X.  The non-staggered grid runs<a name='424'></font>
<font color=#447700>! sd&lt;em&gt;n&lt;/em&gt;:ed&lt;em&gt;n&lt;/em&gt;-1. The extra row or column on the north or<a name='425'></font>
<font color=#447700>! east boundaries is not used for non-staggered fields.<a name='426'></font>
<font color=#447700>! <a name='427'></font>
<font color=#447700>! The domdesc and parent_domdesc arguments are for external communication<a name='428'></font>
<font color=#447700>! packages (e.g. RSL) that establish and return to WRF integer handles<a name='429'></font>
<font color=#447700>! for referring to operations on domains.  These descriptors are not set<a name='430'></font>
<font color=#447700>! or used otherwise and they are opaque, which means they are never<a name='431'></font>
<font color=#447700>! accessed or modified in WRF; they are only only passed between calls to<a name='432'></font>
<font color=#447700>! the external package.<a name='433'></font>
<font color=#447700>!&lt;/DESCRIPTION&gt;<a name='434'></font>
<a name='435'>
   USE <A href='../../html_code/frame/module_machine.F.html#MODULE_MACHINE'>module_machine</A><A href='../../html_code/frame/module_domain.F.html#WRF_PATCH_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_MACHINE_10"><a name='436'>
   IMPLICIT NONE<a name='437'>
   LOGICAL, DIMENSION(4), INTENT(OUT)  :: bdy_mask<a name='438'>
   INTEGER, INTENT(IN)   :: sd1 , ed1 , sd2 , ed2 , sd3 , ed3 , bdx , bdy<a name='439'>
   INTEGER, INTENT(OUT)  :: sp1  , ep1  , sp2  , ep2  , sp3  , ep3  , &amp;  <font color=#447700>! z-xpose (std)<a name='440'></font>
                            sm1  , em1  , sm2  , em2  , sm3  , em3<a name='441'>
   INTEGER, INTENT(OUT)  :: sp1x , ep1x , sp2x , ep2x , sp3x , ep3x , &amp;  <font color=#447700>! x-xpose<a name='442'></font>
                            sm1x , em1x , sm2x , em2x , sm3x , em3x<a name='443'>
   INTEGER, INTENT(OUT)  :: sp1y , ep1y , sp2y , ep2y , sp3y , ep3y , &amp;  <font color=#447700>! y-xpose<a name='444'></font>
                            sm1y , em1y , sm2y , em2y , sm3y , em3y<a name='445'>
   INTEGER, INTENT(IN)   :: id , parent_id , parent_domdesc<a name='446'>
   INTEGER, INTENT(INOUT)  :: domdesc<a name='447'>
   TYPE(domain), POINTER :: parent<a name='448'>
<a name='449'>
<font color=#447700>!local data<a name='450'></font>
<a name='451'>
   INTEGER spec_bdy_width<a name='452'>
<a name='453'>
   CALL nl_get_spec_bdy_width( 1, spec_bdy_width )<a name='454'>
<a name='455'>
#ifndef DM_PARALLEL<a name='456'>
<a name='457'>
   bdy_mask = .true.     <font color=#447700>! only one processor so all 4 boundaries are there<a name='458'></font>
<a name='459'>
<font color=#447700>! this is a trivial version -- 1 patch per processor; <a name='460'></font>
<font color=#447700>! use version in module_dm to compute for DM<a name='461'></font>
   sp1 = sd1 ; sp2 = sd2 ; sp3 = sd3<a name='462'>
   ep1 = ed1 ; ep2 = ed2 ; ep3 = ed3<a name='463'>
   SELECT CASE ( model_data_order )<a name='464'>
      CASE ( DATA_ORDER_XYZ )<a name='465'>
         sm1  = sp1 - bdx ; em1 = ep1 + bdx<a name='466'>
         sm2  = sp2 - bdy ; em2 = ep2 + bdy<a name='467'>
         sm3  = sp3       ; em3 = ep3<a name='468'>
      CASE ( DATA_ORDER_YXZ )<a name='469'>
         sm1 = sp1 - bdy ; em1 = ep1 + bdy<a name='470'>
         sm2 = sp2 - bdx ; em2 = ep2 + bdx<a name='471'>
         sm3 = sp3       ; em3 = ep3<a name='472'>
      CASE ( DATA_ORDER_ZXY )<a name='473'>
         sm1 = sp1       ; em1 = ep1<a name='474'>
         sm2 = sp2 - bdx ; em2 = ep2 + bdx<a name='475'>
         sm3 = sp3 - bdy ; em3 = ep3 + bdy<a name='476'>
      CASE ( DATA_ORDER_ZYX )<a name='477'>
         sm1 = sp1       ; em1 = ep1<a name='478'>
         sm2 = sp2 - bdy ; em2 = ep2 + bdy<a name='479'>
         sm3 = sp3 - bdx ; em3 = ep3 + bdx<a name='480'>
      CASE ( DATA_ORDER_XZY )<a name='481'>
         sm1 = sp1 - bdx ; em1 = ep1 + bdx<a name='482'>
         sm2 = sp2       ; em2 = ep2<a name='483'>
         sm3 = sp3 - bdy ; em3 = ep3 + bdy<a name='484'>
      CASE ( DATA_ORDER_YZX )<a name='485'>
         sm1 = sp1 - bdy ; em1 = ep1 + bdy<a name='486'>
         sm2 = sp2       ; em2 = ep2<a name='487'>
         sm3 = sp3 - bdx ; em3 = ep3 + bdx<a name='488'>
   END SELECT<a name='489'>
   sm1x = sm1       ; em1x = em1    <font color=#447700>! just copy<a name='490'></font>
   sm2x = sm2       ; em2x = em2<a name='491'>
   sm3x = sm3       ; em3x = em3<a name='492'>
   sm1y = sm1       ; em1y = em1    <font color=#447700>! just copy<a name='493'></font>
   sm2y = sm2       ; em2y = em2<a name='494'>
   sm3y = sm3       ; em3y = em3<a name='495'>
<font color=#447700>! assigns mostly just to suppress warning messages that INTENT OUT vars not assigned<a name='496'></font>
   sp1x = sp1 ; ep1x = ep1 ; sp2x = sp2 ; ep2x = ep2 ; sp3x = sp3 ; ep3x = ep3<a name='497'>
   sp1y = sp1 ; ep1y = ep1 ; sp2y = sp2 ; ep2y = ep2 ; sp3y = sp3 ; ep3y = ep3<a name='498'>
<a name='499'>
#else<a name='500'>
<font color=#447700>! This is supplied by the package specific version of module_dm, which<a name='501'></font>
<font color=#447700>! is supplied by the external package and copied into the src directory<a name='502'></font>
<font color=#447700>! when the code is compiled. The cp command will be found in the externals<a name='503'></font>
<font color=#447700>! target of the configure.wrf file for this architecture.  Eg: for RSL<a name='504'></font>
<font color=#447700>! routine is defined in external/RSL/module_dm.F .<a name='505'></font>
<font color=#447700>! Note, it would be very nice to be able to pass parent to this routine;<a name='506'></font>
<font color=#447700>! however, there doesn't seem to be a way to do that in F90. That is because<a name='507'></font>
<font color=#447700>! to pass a pointer to a domain structure, this call requires an interface<a name='508'></font>
<font color=#447700>! definition for wrf_dm_patch_domain (otherwise it will try to convert the<a name='509'></font>
<font color=#447700>! pointer to something). In order to provide an interface definition, we<a name='510'></font>
<font color=#447700>! would need to either USE module_dm or use an interface block. In either<a name='511'></font>
<font color=#447700>! case it generates a circular USE reference, since module_dm uses<a name='512'></font>
<font color=#447700>! module_domain.  JM 20020416<a name='513'></font>
<a name='514'>
   CALL wrf_dm_patch_domain( id , domdesc , parent_id , parent_domdesc , &amp;<a name='515'>
                             sd1 , ed1 , sp1 , ep1 , sm1 , em1 , &amp;<a name='516'>
                             sd2 , ed2 , sp2 , ep2 , sm2 , em2 , &amp;<a name='517'>
                             sd3 , ed3 , sp3 , ep3 , sm3 , em3 , &amp;<a name='518'>
                                         sp1x , ep1x , sm1x , em1x , &amp;<a name='519'>
                                         sp2x , ep2x , sm2x , em2x , &amp;<a name='520'>
                                         sp3x , ep3x , sm3x , em3x , &amp;<a name='521'>
                                         sp1y , ep1y , sm1y , em1y , &amp;<a name='522'>
                                         sp2y , ep2y , sm2y , em2y , &amp;<a name='523'>
                                         sp3y , ep3y , sm3y , em3y , &amp;<a name='524'>
                             bdx , bdy )<a name='525'>
<a name='526'>
   SELECT CASE ( model_data_order )<a name='527'>
      CASE ( DATA_ORDER_XYZ )<a name='528'>
   bdy_mask( P_XSB ) = ( sp1 &lt;= sd1 .AND. sd1 &lt;= ep1 .AND. sp1 &lt;= sd1+spec_bdy_width-1 .AND. sd1+spec_bdy_width-1 &lt;= ep1 )<a name='529'>
   bdy_mask( P_YSB ) = ( sp2 &lt;= sd2 .AND. sd2 &lt;= ep2 .AND. sp2 &lt;= sd2+spec_bdy_width-1 .AND. sd2+spec_bdy_width-1 &lt;= ep2 )<a name='530'>
   bdy_mask( P_XEB ) = ( sp1 &lt;= ed1 .AND. ed1 &lt;= ep1 .AND. sp1 &lt;= ed1-spec_bdy_width-1 .AND. ed1-spec_bdy_width-1 &lt;= ep1 )<a name='531'>
   bdy_mask( P_YEB ) = ( sp2 &lt;= ed2 .AND. ed2 &lt;= ep2 .AND. sp2 &lt;= ed2-spec_bdy_width-1 .AND. ed2-spec_bdy_width-1 &lt;= ep2 )<a name='532'>
      CASE ( DATA_ORDER_YXZ )<a name='533'>
   bdy_mask( P_XSB ) = ( sp2 &lt;= sd2 .AND. sd2 &lt;= ep2 .AND. sp2 &lt;= sd2+spec_bdy_width-1 .AND. sd2+spec_bdy_width-1 &lt;= ep2 )<a name='534'>
   bdy_mask( P_YSB ) = ( sp1 &lt;= sd1 .AND. sd1 &lt;= ep1 .AND. sp1 &lt;= sd1+spec_bdy_width-1 .AND. sd1+spec_bdy_width-1 &lt;= ep1 )<a name='535'>
   bdy_mask( P_XEB ) = ( sp2 &lt;= ed2 .AND. ed2 &lt;= ep2 .AND. sp2 &lt;= ed2-spec_bdy_width-1 .AND. ed2-spec_bdy_width-1 &lt;= ep2 )<a name='536'>
   bdy_mask( P_YEB ) = ( sp1 &lt;= ed1 .AND. ed1 &lt;= ep1 .AND. sp1 &lt;= ed1-spec_bdy_width-1 .AND. ed1-spec_bdy_width-1 &lt;= ep1 )<a name='537'>
      CASE ( DATA_ORDER_ZXY )<a name='538'>
   bdy_mask( P_XSB ) = ( sp2 &lt;= sd2 .AND. sd2 &lt;= ep2 .AND. sp2 &lt;= sd2+spec_bdy_width-1 .AND. sd2+spec_bdy_width-1 &lt;= ep2 )<a name='539'>
   bdy_mask( P_YSB ) = ( sp3 &lt;= sd3 .AND. sd3 &lt;= ep3 .AND. sp3 &lt;= sd3+spec_bdy_width-1 .AND. sd3+spec_bdy_width-1 &lt;= ep3 )<a name='540'>
   bdy_mask( P_XEB ) = ( sp2 &lt;= ed2 .AND. ed2 &lt;= ep2 .AND. sp2 &lt;= ed2-spec_bdy_width-1 .AND. ed2-spec_bdy_width-1 &lt;= ep2 )<a name='541'>
   bdy_mask( P_YEB ) = ( sp3 &lt;= ed3 .AND. ed3 &lt;= ep3 .AND. sp3 &lt;= ed3-spec_bdy_width-1 .AND. ed3-spec_bdy_width-1 &lt;= ep3 )<a name='542'>
      CASE ( DATA_ORDER_ZYX )<a name='543'>
   bdy_mask( P_XSB ) = ( sp3 &lt;= sd3 .AND. sd3 &lt;= ep3 .AND. sp3 &lt;= sd3+spec_bdy_width-1 .AND. sd3+spec_bdy_width-1 &lt;= ep3 )<a name='544'>
   bdy_mask( P_YSB ) = ( sp2 &lt;= sd2 .AND. sd2 &lt;= ep2 .AND. sp2 &lt;= sd2+spec_bdy_width-1 .AND. sd2+spec_bdy_width-1 &lt;= ep2 )<a name='545'>
   bdy_mask( P_XEB ) = ( sp3 &lt;= ed3 .AND. ed3 &lt;= ep3 .AND. sp3 &lt;= ed3-spec_bdy_width-1 .AND. ed3-spec_bdy_width-1 &lt;= ep3 )<a name='546'>
   bdy_mask( P_YEB ) = ( sp2 &lt;= ed2 .AND. ed2 &lt;= ep2 .AND. sp2 &lt;= ed2-spec_bdy_width-1 .AND. ed2-spec_bdy_width-1 &lt;= ep2 )<a name='547'>
      CASE ( DATA_ORDER_XZY )<a name='548'>
   bdy_mask( P_XSB ) = ( sp1 &lt;= sd1 .AND. sd1 &lt;= ep1 .AND. sp1 &lt;= sd1+spec_bdy_width-1 .AND. sd1+spec_bdy_width-1 &lt;= ep1 )<a name='549'>
   bdy_mask( P_YSB ) = ( sp3 &lt;= sd3 .AND. sd3 &lt;= ep3 .AND. sp3 &lt;= sd3+spec_bdy_width-1 .AND. sd3+spec_bdy_width-1 &lt;= ep3 )<a name='550'>
   bdy_mask( P_XEB ) = ( sp1 &lt;= ed1 .AND. ed1 &lt;= ep1 .AND. sp1 &lt;= ed1-spec_bdy_width-1 .AND. ed1-spec_bdy_width-1 &lt;= ep1 )<a name='551'>
   bdy_mask( P_YEB ) = ( sp3 &lt;= ed3 .AND. ed3 &lt;= ep3 .AND. sp3 &lt;= ed3-spec_bdy_width-1 .AND. ed3-spec_bdy_width-1 &lt;= ep3 )<a name='552'>
      CASE ( DATA_ORDER_YZX )<a name='553'>
   bdy_mask( P_XSB ) = ( sp3 &lt;= sd3 .AND. sd3 &lt;= ep3 .AND. sp3 &lt;= sd3+spec_bdy_width-1 .AND. sd3+spec_bdy_width-1 &lt;= ep3 )<a name='554'>
   bdy_mask( P_YSB ) = ( sp1 &lt;= sd1 .AND. sd1 &lt;= ep1 .AND. sp1 &lt;= sd1+spec_bdy_width-1 .AND. sd1+spec_bdy_width-1 &lt;= ep1 )<a name='555'>
   bdy_mask( P_XEB ) = ( sp3 &lt;= ed3 .AND. ed3 &lt;= ep3 .AND. sp3 &lt;= ed3-spec_bdy_width-1 .AND. ed3-spec_bdy_width-1 &lt;= ep3 )<a name='556'>
   bdy_mask( P_YEB ) = ( sp1 &lt;= ed1 .AND. ed1 &lt;= ep1 .AND. sp1 &lt;= ed1-spec_bdy_width-1 .AND. ed1-spec_bdy_width-1 &lt;= ep1 )<a name='557'>
   END SELECT<a name='558'>
<a name='559'>
#endif<a name='560'>
<a name='561'>
   RETURN<a name='562'>
   END SUBROUTINE wrf_patch_domain<a name='563'>
<font color=#447700>!<a name='564'></font>
<A NAME='ALLOC_AND_CONFIGURE_DOMAIN'><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='565'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>alloc_and_configure_domain</font> ( domain_id , grid , parent, kid ) <A href='../../call_to/ALLOC_AND_CONFIGURE_DOMAIN.html' TARGET='index'>14</A>,<A href='../../call_from/ALLOC_AND_CONFIGURE_DOMAIN.html' TARGET='index'>9</A><a name='566'>
<a name='567'>
<font color=#447700>!&lt;DESCRIPTION&gt;<a name='568'></font>
<font color=#447700>! This subroutine is used to allocate a domain data structure of<a name='569'></font>
<font color=#447700>! TYPE(DOMAIN) pointed to by the argument &lt;em&gt;grid&lt;/em&gt;, link it into the<a name='570'></font>
<font color=#447700>! nested domain hierarchy, and set it's configuration information from<a name='571'></font>
<font color=#447700>! the appropriate settings in the WRF namelist file. Specifically, if the<a name='572'></font>
<font color=#447700>! domain being allocated and configured is nest, the &lt;em&gt;parent&lt;/em&gt;<a name='573'></font>
<font color=#447700>! argument will point to the already existing domain data structure for<a name='574'></font>
<font color=#447700>! the parent domain and the &lt;em&gt;kid&lt;/em&gt; argument will be set to an<a name='575'></font>
<font color=#447700>! integer indicating which child of the parent this grid will be (child<a name='576'></font>
<font color=#447700>! indices start at 1).  If this is the top-level domain, the parent and<a name='577'></font>
<font color=#447700>! kid arguments are ignored.  &lt;b&gt;WRF domains may have multiple children<a name='578'></font>
<font color=#447700>! but only ever have one parent.&lt;/b&gt;<a name='579'></font>
<font color=#447700>!<a name='580'></font>
<font color=#447700>! The &lt;em&gt;domain_id&lt;/em&gt; argument is the<a name='581'></font>
<font color=#447700>! integer handle by which this new domain will be referred; it comes from<a name='582'></font>
<font color=#447700>! the grid_id setting in the namelist, and these grid ids correspond to<a name='583'></font>
<font color=#447700>! the ordering of settings in the namelist, starting with 1 for the<a name='584'></font>
<font color=#447700>! top-level domain. The id of 1 always corresponds to the top-level<a name='585'></font>
<font color=#447700>! domain.  and these grid ids correspond to the ordering of settings in<a name='586'></font>
<font color=#447700>! the namelist, starting with 1 for the top-level domain.<a name='587'></font>
<font color=#447700>! <a name='588'></font>
<font color=#447700>! Model_data_order is provide by USE association of<a name='589'></font>
<font color=#447700>! module_driver_constants and is set from dimspec entries in the<a name='590'></font>
<font color=#447700>! Registry.<a name='591'></font>
<font color=#447700>! <a name='592'></font>
<font color=#447700>! The allocation of the TYPE(DOMAIN) itself occurs in this routine.<a name='593'></font>
<font color=#447700>! However, the numerous multi-dimensional arrays that make up the members<a name='594'></font>
<font color=#447700>! of the domain are allocated in the call to alloc_space_field, after<a name='595'></font>
<font color=#447700>! wrf_patch_domain has been called to determine the dimensions in memory<a name='596'></font>
<font color=#447700>! that should be allocated.  It bears noting here that arrays and code<a name='597'></font>
<font color=#447700>! that indexes these arrays are always global, regardless of how the<a name='598'></font>
<font color=#447700>! model is decomposed over patches. Thus, when arrays are allocated on a<a name='599'></font>
<font color=#447700>! given process, the start and end of an array dimension are the global<a name='600'></font>
<font color=#447700>! indices of the start and end of that process's subdomain.<a name='601'></font>
<font color=#447700>! <a name='602'></font>
<font color=#447700>! Configuration information for the domain (that is, information from the<a name='603'></font>
<font color=#447700>! namelist) is added by the call to &lt;a href=med_add_config_info_to_grid.html&gt;med_add_config_info_to_grid&lt;/a&gt;, defined<a name='604'></font>
<font color=#447700>! in share/mediation_wrfmain.F. <a name='605'></font>
<font color=#447700>!&lt;/DESCRIPTION&gt;<a name='606'></font>
<a name='607'>
      <a name='608'>
      IMPLICIT NONE<a name='609'>
<a name='610'>
      <font color=#447700>!  Input data.<a name='611'></font>
<a name='612'>
      INTEGER , INTENT(IN)                           :: domain_id<a name='613'>
      TYPE( domain ) , POINTER                       :: grid<a name='614'>
      TYPE( domain ) , POINTER                       :: parent<a name='615'>
      INTEGER , INTENT(IN)                           :: kid    <font color=#447700>! which kid of parent am I?<a name='616'></font>
<a name='617'>
      <font color=#447700>!  Local data.<a name='618'></font>
      INTEGER                     :: sd1 , ed1 , sp1 , ep1 , sm1 , em1<a name='619'>
      INTEGER                     :: sd2 , ed2 , sp2 , ep2 , sm2 , em2<a name='620'>
      INTEGER                     :: sd3 , ed3 , sp3 , ep3 , sm3 , em3<a name='621'>
<a name='622'>
      INTEGER                     :: sd1x , ed1x , sp1x , ep1x , sm1x , em1x<a name='623'>
      INTEGER                     :: sd2x , ed2x , sp2x , ep2x , sm2x , em2x<a name='624'>
      INTEGER                     :: sd3x , ed3x , sp3x , ep3x , sm3x , em3x<a name='625'>
<a name='626'>
      INTEGER                     :: sd1y , ed1y , sp1y , ep1y , sm1y , em1y<a name='627'>
      INTEGER                     :: sd2y , ed2y , sp2y , ep2y , sm2y , em2y<a name='628'>
      INTEGER                     :: sd3y , ed3y , sp3y , ep3y , sm3y , em3y<a name='629'>
<a name='630'>
      TYPE(domain) , POINTER      :: new_grid<a name='631'>
      INTEGER                     :: i<a name='632'>
      INTEGER                     :: parent_id , parent_domdesc , new_domdesc<a name='633'>
      INTEGER                     :: bdyzone_x , bdyzone_y<a name='634'>
      INTEGER                     :: nx, ny<a name='635'>
<a name='636'>
<a name='637'>
<font color=#447700>! This next step uses information that is listed in the registry as namelist_derived<a name='638'></font>
<font color=#447700>! to properly size the domain and the patches; this in turn is stored in the new_grid<a name='639'></font>
<font color=#447700>! data structure<a name='640'></font>
<a name='641'>
<a name='642'>
      data_ordering : SELECT CASE ( model_data_order )<a name='643'>
        CASE  ( DATA_ORDER_XYZ )<a name='644'>
<a name='645'>
          CALL nl_get_s_we( domain_id , sd1 )<a name='646'>
          CALL nl_get_e_we( domain_id , ed1 )<a name='647'>
          CALL nl_get_s_sn( domain_id , sd2 )<a name='648'>
          CALL nl_get_e_sn( domain_id , ed2 )<a name='649'>
          CALL nl_get_s_vert( domain_id , sd3 )<a name='650'>
          CALL nl_get_e_vert( domain_id , ed3 )<a name='651'>
          nx = ed1-sd1+1<a name='652'>
          ny = ed2-sd2+1<a name='653'>
<a name='654'>
        CASE  ( DATA_ORDER_YXZ )<a name='655'>
<a name='656'>
          CALL nl_get_s_sn( domain_id , sd1 )<a name='657'>
          CALL nl_get_e_sn( domain_id , ed1 )<a name='658'>
          CALL nl_get_s_we( domain_id , sd2 )<a name='659'>
          CALL nl_get_e_we( domain_id , ed2 )<a name='660'>
          CALL nl_get_s_vert( domain_id , sd3 )<a name='661'>
          CALL nl_get_e_vert( domain_id , ed3 )<a name='662'>
          nx = ed2-sd2+1<a name='663'>
          ny = ed1-sd1+1<a name='664'>
<a name='665'>
        CASE  ( DATA_ORDER_ZXY )<a name='666'>
<a name='667'>
          CALL nl_get_s_vert( domain_id , sd1 )<a name='668'>
          CALL nl_get_e_vert( domain_id , ed1 )<a name='669'>
          CALL nl_get_s_we( domain_id , sd2 )<a name='670'>
          CALL nl_get_e_we( domain_id , ed2 )<a name='671'>
          CALL nl_get_s_sn( domain_id , sd3 )<a name='672'>
          CALL nl_get_e_sn( domain_id , ed3 )<a name='673'>
          nx = ed2-sd2+1<a name='674'>
          ny = ed3-sd3+1<a name='675'>
<a name='676'>
        CASE  ( DATA_ORDER_ZYX )<a name='677'>
<a name='678'>
          CALL nl_get_s_vert( domain_id , sd1 )<a name='679'>
          CALL nl_get_e_vert( domain_id , ed1 )<a name='680'>
          CALL nl_get_s_sn( domain_id , sd2 )<a name='681'>
          CALL nl_get_e_sn( domain_id , ed2 )<a name='682'>
          CALL nl_get_s_we( domain_id , sd3 )<a name='683'>
          CALL nl_get_e_we( domain_id , ed3 )<a name='684'>
          nx = ed3-sd3+1<a name='685'>
          ny = ed2-sd2+1<a name='686'>
<a name='687'>
        CASE  ( DATA_ORDER_XZY )<a name='688'>
<a name='689'>
          CALL nl_get_s_we( domain_id , sd1 )<a name='690'>
          CALL nl_get_e_we( domain_id , ed1 )<a name='691'>
          CALL nl_get_s_vert( domain_id , sd2 )<a name='692'>
          CALL nl_get_e_vert( domain_id , ed2 )<a name='693'>
          CALL nl_get_s_sn( domain_id , sd3 )<a name='694'>
          CALL nl_get_e_sn( domain_id , ed3 )<a name='695'>
          nx = ed1-sd1+1<a name='696'>
          ny = ed3-sd3+1<a name='697'>
<a name='698'>
        CASE  ( DATA_ORDER_YZX )<a name='699'>
<a name='700'>
          CALL nl_get_s_sn( domain_id , sd1 )<a name='701'>
          CALL nl_get_e_sn( domain_id , ed1 )<a name='702'>
          CALL nl_get_s_vert( domain_id , sd2 )<a name='703'>
          CALL nl_get_e_vert( domain_id , ed2 )<a name='704'>
          CALL nl_get_s_we( domain_id , sd3 )<a name='705'>
          CALL nl_get_e_we( domain_id , ed3 )<a name='706'>
          nx = ed3-sd3+1<a name='707'>
          ny = ed1-sd1+1<a name='708'>
<a name='709'>
      END SELECT data_ordering<a name='710'>
<a name='711'>
#ifdef RSL<a name='712'>
<font color=#447700>! Check domain size to be sure it is within RSLs limit<a name='713'></font>
      IF ( nx .GE. 1024 .OR. ny .GE. 1024 ) THEN<a name='714'>
        WRITE ( wrf_err_message , * ) 'domain too large for RSL. Use RSL_LITE or other comm package.'<a name='715'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_85"> ( TRIM ( wrf_err_message ) )<a name='716'>
      ENDIF<a name='717'>
<a name='718'>
#endif<a name='719'>
<a name='720'>
      IF ( num_time_levels &gt; 3 ) THEN<a name='721'>
        WRITE ( wrf_err_message , * ) 'alloc_and_configure_domain: Incorrect value for num_time_levels ', &amp;<a name='722'>
                                       num_time_levels<a name='723'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_86"> ( TRIM ( wrf_err_message ) )<a name='724'>
      ENDIF<a name='725'>
<a name='726'>
      IF (ASSOCIATED(parent)) THEN<a name='727'>
        parent_id = parent%id<a name='728'>
        parent_domdesc = parent%domdesc<a name='729'>
      ELSE<a name='730'>
        parent_id = -1<a name='731'>
        parent_domdesc = -1<a name='732'>
      ENDIF<a name='733'>
<a name='734'>
<font color=#447700>! provided by application, WRF defines in share/module_bc.F<a name='735'></font>
      CALL <A href='../../html_code/share/module_bdyzone.F.html#GET_BDYZONE_X'>get_bdyzone_x</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="GET_BDYZONE_X_1">( bdyzone_x )<a name='736'>
      CALL <A href='../../html_code/share/module_bdyzone.F.html#GET_BDYZONE_Y'>get_bdyzone_y</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="GET_BDYZONE_Y_1">( bdyzone_y )<a name='737'>
<a name='738'>
      ALLOCATE ( new_grid )<a name='739'>
      ALLOCATE ( new_grid%parents( max_parents ) )<a name='740'>
      ALLOCATE ( new_grid%nests( max_nests ) )<a name='741'>
      NULLIFY( new_grid%sibling )<a name='742'>
      DO i = 1, max_nests<a name='743'>
         NULLIFY( new_grid%nests(i)%ptr )<a name='744'>
      ENDDO<a name='745'>
      NULLIFY  (new_grid%next)<a name='746'>
      NULLIFY  (new_grid%same_level)<a name='747'>
      NULLIFY  (new_grid%i_start)<a name='748'>
      NULLIFY  (new_grid%j_start)<a name='749'>
      NULLIFY  (new_grid%i_end)<a name='750'>
      NULLIFY  (new_grid%j_end)<a name='751'>
      ALLOCATE( new_grid%alarms( MAX_WRF_ALARMS ) )    <font color=#447700>! initialize in setup_timekeeping<a name='752'></font>
<a name='753'>
      <font color=#447700>! set up the pointers that represent the nest hierarchy<a name='754'></font>
      <font color=#447700>! set this up *prior* to calling the patching or allocation<a name='755'></font>
      <font color=#447700>! routines so that implementations of these routines can<a name='756'></font>
      <font color=#447700>! traverse the nest hierarchy (through the root head_grid)<a name='757'></font>
      <font color=#447700>! if they need to <a name='758'></font>
<a name='759'>
 <a name='760'>
      IF ( domain_id .NE. 1 ) THEN<a name='761'>
         new_grid%parents(1)%ptr =&gt; parent<a name='762'>
         new_grid%num_parents = 1<a name='763'>
         parent%nests(kid)%ptr =&gt; new_grid<a name='764'>
         new_grid%child_of_parent(1) = kid    <font color=#447700>! note assumption that nest can have only 1 parent<a name='765'></font>
         parent%num_nests = parent%num_nests + 1<a name='766'>
      END IF<a name='767'>
      new_grid%id = domain_id                 <font color=#447700>! this needs to be assigned prior to calling wrf_patch_domain<a name='768'></font>
<a name='769'>
      CALL <A href='../../html_code/frame/module_domain.F.html#WRF_PATCH_DOMAIN'>wrf_patch_domain</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_PATCH_DOMAIN_1">( domain_id  , new_domdesc , parent, parent_id, parent_domdesc , &amp;<a name='770'>
<a name='771'>
                             sd1 , ed1 , sp1 , ep1 , sm1 , em1 , &amp;     <font color=#447700>! z-xpose dims<a name='772'></font>
                             sd2 , ed2 , sp2 , ep2 , sm2 , em2 , &amp;     <font color=#447700>! (standard)<a name='773'></font>
                             sd3 , ed3 , sp3 , ep3 , sm3 , em3 , &amp;<a name='774'>
<a name='775'>
                                     sp1x , ep1x , sm1x , em1x , &amp;     <font color=#447700>! x-xpose dims<a name='776'></font>
                                     sp2x , ep2x , sm2x , em2x , &amp;<a name='777'>
                                     sp3x , ep3x , sm3x , em3x , &amp;<a name='778'>
<a name='779'>
                                     sp1y , ep1y , sm1y , em1y , &amp;     <font color=#447700>! y-xpose dims<a name='780'></font>
                                     sp2y , ep2y , sm2y , em2y , &amp;<a name='781'>
                                     sp3y , ep3y , sm3y , em3y , &amp;<a name='782'>
<a name='783'>
                         bdyzone_x  , bdyzone_y , new_grid%bdy_mask &amp;<a name='784'>
      ) <a name='785'>
<a name='786'>
      new_grid%domdesc = new_domdesc<a name='787'>
      new_grid%num_nests = 0<a name='788'>
      new_grid%num_siblings = 0<a name='789'>
      new_grid%num_parents = 0<a name='790'>
      new_grid%max_tiles   = 0<a name='791'>
      new_grid%num_tiles_spec   = 0<a name='792'>
      new_grid%nframes   = 0         <font color=#447700>! initialize the number of frames per file (array assignment)<a name='793'></font>
<a name='794'>
      CALL <A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD'>alloc_space_field</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ALLOC_SPACE_FIELD_2"> ( new_grid, domain_id , 3 ,           &amp;<a name='795'>
                               sd1, ed1, sd2, ed2, sd3, ed3,       &amp;<a name='796'>
                               sm1,  em1,  sm2,  em2,  sm3,  em3,  &amp;<a name='797'>
                               sm1x, em1x, sm2x, em2x, sm3x, em3x, &amp;   <font color=#447700>! x-xpose<a name='798'></font>
                               sm1y, em1y, sm2y, em2y, sm3y, em3y  &amp;   <font color=#447700>! y-xpose<a name='799'></font>
      )<a name='800'>
<a name='801'>
      new_grid%sd31                            = sd1 <a name='802'>
      new_grid%ed31                            = ed1<a name='803'>
      new_grid%sp31                            = sp1 <a name='804'>
      new_grid%ep31                            = ep1 <a name='805'>
      new_grid%sm31                            = sm1 <a name='806'>
      new_grid%em31                            = em1<a name='807'>
      new_grid%sd32                            = sd2 <a name='808'>
      new_grid%ed32                            = ed2<a name='809'>
      new_grid%sp32                            = sp2 <a name='810'>
      new_grid%ep32                            = ep2 <a name='811'>
      new_grid%sm32                            = sm2 <a name='812'>
      new_grid%em32                            = em2<a name='813'>
      new_grid%sd33                            = sd3 <a name='814'>
      new_grid%ed33                            = ed3<a name='815'>
      new_grid%sp33                            = sp3 <a name='816'>
      new_grid%ep33                            = ep3 <a name='817'>
      new_grid%sm33                            = sm3 <a name='818'>
      new_grid%em33                            = em3<a name='819'>
<a name='820'>
      new_grid%sp31x                           = sp1x<a name='821'>
      new_grid%ep31x                           = ep1x<a name='822'>
      new_grid%sm31x                           = sm1x<a name='823'>
      new_grid%em31x                           = em1x<a name='824'>
      new_grid%sp32x                           = sp2x<a name='825'>
      new_grid%ep32x                           = ep2x<a name='826'>
      new_grid%sm32x                           = sm2x<a name='827'>
      new_grid%em32x                           = em2x<a name='828'>
      new_grid%sp33x                           = sp3x<a name='829'>
      new_grid%ep33x                           = ep3x<a name='830'>
      new_grid%sm33x                           = sm3x<a name='831'>
      new_grid%em33x                           = em3x<a name='832'>
<a name='833'>
      new_grid%sp31y                           = sp1y<a name='834'>
      new_grid%ep31y                           = ep1y<a name='835'>
      new_grid%sm31y                           = sm1y<a name='836'>
      new_grid%em31y                           = em1y<a name='837'>
      new_grid%sp32y                           = sp2y<a name='838'>
      new_grid%ep32y                           = ep2y<a name='839'>
      new_grid%sm32y                           = sm2y<a name='840'>
      new_grid%em32y                           = em2y<a name='841'>
      new_grid%sp33y                           = sp3y<a name='842'>
      new_grid%ep33y                           = ep3y<a name='843'>
      new_grid%sm33y                           = sm3y<a name='844'>
      new_grid%em33y                           = em3y<a name='845'>
<a name='846'>
      SELECT CASE ( model_data_order )<a name='847'>
         CASE  ( DATA_ORDER_XYZ )<a name='848'>
            new_grid%sd21 = sd1 ; new_grid%sd22 = sd2 ;<a name='849'>
            new_grid%ed21 = ed1 ; new_grid%ed22 = ed2 ;<a name='850'>
            new_grid%sp21 = sp1 ; new_grid%sp22 = sp2 ;<a name='851'>
            new_grid%ep21 = ep1 ; new_grid%ep22 = ep2 ;<a name='852'>
            new_grid%sm21 = sm1 ; new_grid%sm22 = sm2 ;<a name='853'>
            new_grid%em21 = em1 ; new_grid%em22 = em2 ;<a name='854'>
            new_grid%sd11 = sd1<a name='855'>
            new_grid%ed11 = ed1<a name='856'>
            new_grid%sp11 = sp1<a name='857'>
            new_grid%ep11 = ep1<a name='858'>
            new_grid%sm11 = sm1<a name='859'>
            new_grid%em11 = em1<a name='860'>
         CASE  ( DATA_ORDER_YXZ )<a name='861'>
            new_grid%sd21 = sd1 ; new_grid%sd22 = sd2 ;<a name='862'>
            new_grid%ed21 = ed1 ; new_grid%ed22 = ed2 ;<a name='863'>
            new_grid%sp21 = sp1 ; new_grid%sp22 = sp2 ;<a name='864'>
            new_grid%ep21 = ep1 ; new_grid%ep22 = ep2 ;<a name='865'>
            new_grid%sm21 = sm1 ; new_grid%sm22 = sm2 ;<a name='866'>
            new_grid%em21 = em1 ; new_grid%em22 = em2 ;<a name='867'>
            new_grid%sd11 = sd1<a name='868'>
            new_grid%ed11 = ed1<a name='869'>
            new_grid%sp11 = sp1<a name='870'>
            new_grid%ep11 = ep1<a name='871'>
            new_grid%sm11 = sm1<a name='872'>
            new_grid%em11 = em1<a name='873'>
         CASE  ( DATA_ORDER_ZXY )<a name='874'>
            new_grid%sd21 = sd2 ; new_grid%sd22 = sd3 ;<a name='875'>
            new_grid%ed21 = ed2 ; new_grid%ed22 = ed3 ;<a name='876'>
            new_grid%sp21 = sp2 ; new_grid%sp22 = sp3 ;<a name='877'>
            new_grid%ep21 = ep2 ; new_grid%ep22 = ep3 ;<a name='878'>
            new_grid%sm21 = sm2 ; new_grid%sm22 = sm3 ;<a name='879'>
            new_grid%em21 = em2 ; new_grid%em22 = em3 ;<a name='880'>
            new_grid%sd11 = sd2<a name='881'>
            new_grid%ed11 = ed2<a name='882'>
            new_grid%sp11 = sp2<a name='883'>
            new_grid%ep11 = ep2<a name='884'>
            new_grid%sm11 = sm2<a name='885'>
            new_grid%em11 = em2<a name='886'>
         CASE  ( DATA_ORDER_ZYX )<a name='887'>
            new_grid%sd21 = sd2 ; new_grid%sd22 = sd3 ;<a name='888'>
            new_grid%ed21 = ed2 ; new_grid%ed22 = ed3 ;<a name='889'>
            new_grid%sp21 = sp2 ; new_grid%sp22 = sp3 ;<a name='890'>
            new_grid%ep21 = ep2 ; new_grid%ep22 = ep3 ;<a name='891'>
            new_grid%sm21 = sm2 ; new_grid%sm22 = sm3 ;<a name='892'>
            new_grid%em21 = em2 ; new_grid%em22 = em3 ;<a name='893'>
            new_grid%sd11 = sd2<a name='894'>
            new_grid%ed11 = ed2<a name='895'>
            new_grid%sp11 = sp2<a name='896'>
            new_grid%ep11 = ep2<a name='897'>
            new_grid%sm11 = sm2<a name='898'>
            new_grid%em11 = em2<a name='899'>
         CASE  ( DATA_ORDER_XZY )<a name='900'>
            new_grid%sd21 = sd1 ; new_grid%sd22 = sd3 ;<a name='901'>
            new_grid%ed21 = ed1 ; new_grid%ed22 = ed3 ;<a name='902'>
            new_grid%sp21 = sp1 ; new_grid%sp22 = sp3 ;<a name='903'>
            new_grid%ep21 = ep1 ; new_grid%ep22 = ep3 ;<a name='904'>
            new_grid%sm21 = sm1 ; new_grid%sm22 = sm3 ;<a name='905'>
            new_grid%em21 = em1 ; new_grid%em22 = em3 ;<a name='906'>
            new_grid%sd11 = sd1<a name='907'>
            new_grid%ed11 = ed1<a name='908'>
            new_grid%sp11 = sp1<a name='909'>
            new_grid%ep11 = ep1<a name='910'>
            new_grid%sm11 = sm1<a name='911'>
            new_grid%em11 = em1<a name='912'>
         CASE  ( DATA_ORDER_YZX )<a name='913'>
            new_grid%sd21 = sd1 ; new_grid%sd22 = sd3 ;<a name='914'>
            new_grid%ed21 = ed1 ; new_grid%ed22 = ed3 ;<a name='915'>
            new_grid%sp21 = sp1 ; new_grid%sp22 = sp3 ;<a name='916'>
            new_grid%ep21 = ep1 ; new_grid%ep22 = ep3 ;<a name='917'>
            new_grid%sm21 = sm1 ; new_grid%sm22 = sm3 ;<a name='918'>
            new_grid%em21 = em1 ; new_grid%em22 = em3 ;<a name='919'>
            new_grid%sd11 = sd1<a name='920'>
            new_grid%ed11 = ed1<a name='921'>
            new_grid%sp11 = sp1<a name='922'>
            new_grid%ep11 = ep1<a name='923'>
            new_grid%sm11 = sm1<a name='924'>
            new_grid%em11 = em1<a name='925'>
      END SELECT<a name='926'>
<a name='927'>
      CALL <A href='../../html_code/share/mediation_wrfmain.F.html#MED_ADD_CONFIG_INFO_TO_GRID'>med_add_config_info_to_grid</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MED_ADD_CONFIG_INFO_TO_GRID_1"> ( new_grid )           <font color=#447700>! this is a mediation layer routine<a name='928'></font>
<a name='929'>
<font color=#447700>! Some miscellaneous state that is in the Registry but not namelist data<a name='930'></font>
<a name='931'>
      new_grid%tiled                           = .false.<a name='932'>
      new_grid%patched                         = .false.<a name='933'>
      NULLIFY(new_grid%mapping)<a name='934'>
<a name='935'>
<font color=#447700>! This next set of includes causes all but the namelist_derived variables to be<a name='936'></font>
<font color=#447700>! properly assigned to the new_grid record<a name='937'></font>
<a name='938'>
      grid =&gt; new_grid<a name='939'>
<a name='940'>
#ifdef DM_PARALLEL<a name='941'>
      CALL <A href='../../html_code/frame/module_dm_stubs.F.html#WRF_GET_DM_COMMUNICATOR'>wrf_get_dm_communicator</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_GET_DM_COMMUNICATOR_4"> ( grid%communicator )<a name='942'>
      CALL <A href='../../html_code/frame/module_dm_stubs.F.html#WRF_DM_DEFINE_COMMS'>wrf_dm_define_comms</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_AND_CONFIGURE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DM_DEFINE_COMMS_1">( grid )<a name='943'>
#endif<a name='944'>
<a name='945'>
   END SUBROUTINE alloc_and_configure_domain<a name='946'>
<a name='947'>
<font color=#447700>!<a name='948'></font>
<a name='949'>
<font color=#447700>!  This routine ALLOCATEs the required space for the meteorological fields<a name='950'></font>
<font color=#447700>!  for a specific domain.  The fields are simply ALLOCATEd as an -1.  They<a name='951'></font>
<font color=#447700>!  are referenced as wind, temperature, moisture, etc. in routines that are<a name='952'></font>
<font color=#447700>!  below this top-level of data allocation and management (in the solve routine<a name='953'></font>
<font color=#447700>!  and below).<a name='954'></font>
<a name='955'>
<A NAME='ALLOC_SPACE_FIELD'><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='956'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>alloc_space_field</font> ( grid,   id, setinitval ,            &amp; <A href='../../call_to/ALLOC_SPACE_FIELD.html' TARGET='index'>2</A>,<A href='../../call_from/ALLOC_SPACE_FIELD.html' TARGET='index'>9</A><a name='957'>
                                  sd31, ed31, sd32, ed32, sd33, ed33, &amp;<a name='958'>
                                  sm31 , em31 , sm32 , em32 , sm33 , em33 , &amp;<a name='959'>
                                  sm31x, em31x, sm32x, em32x, sm33x, em33x, &amp;<a name='960'>
                                  sm31y, em31y, sm32y, em32y, sm33y, em33y )<a name='961'>
<a name='962'>
      <a name='963'>
      USE <A href='../../html_code/frame/module_configure.F.html#MODULE_CONFIGURE'>module_configure</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CONFIGURE_41"><a name='964'>
      IMPLICIT NONE<a name='965'>
 <a name='966'>
<a name='967'>
      <font color=#447700>!  Input data.<a name='968'></font>
<a name='969'>
      TYPE(domain)               , POINTER          :: grid<a name='970'>
      INTEGER , INTENT(IN)            :: id<a name='971'>
      INTEGER , INTENT(IN)            :: setinitval   <font color=#447700>! 3 = everything, 1 = arrays only, 0 = none<a name='972'></font>
      INTEGER , INTENT(IN)            :: sd31, ed31, sd32, ed32, sd33, ed33<a name='973'>
      INTEGER , INTENT(IN)            :: sm31, em31, sm32, em32, sm33, em33<a name='974'>
      INTEGER , INTENT(IN)            :: sm31x, em31x, sm32x, em32x, sm33x, em33x<a name='975'>
      INTEGER , INTENT(IN)            :: sm31y, em31y, sm32y, em32y, sm33y, em33y<a name='976'>
<a name='977'>
      <font color=#447700>!  Local data.<a name='978'></font>
      INTEGER dyn_opt, idum1, idum2, spec_bdy_width<a name='979'>
      INTEGER num_bytes_allocated<a name='980'>
      REAL    initial_data_value<a name='981'>
      CHARACTER (LEN=256) message<a name='982'>
<a name='983'>
      <font color=#447700>!declare ierr variable for error checking ALLOCATE calls<a name='984'></font>
      INTEGER ierr<a name='985'>
<a name='986'>
      INTEGER                              :: loop<a name='987'>
<a name='988'>
#if ( RWORDSIZE == 8 )<a name='989'>
      initial_data_value = 0.<a name='990'>
#else<a name='991'>
      CALL get_initial_data_value ( initial_data_value )<a name='992'>
#endif<a name='993'>
<a name='994'>
      CALL nl_get_dyn_opt( 1, dyn_opt )<a name='995'>
      CALL nl_get_spec_bdy_width( 1, spec_bdy_width )<a name='996'>
<a name='997'>
      CALL <A href='../../html_code/frame/module_configure.F.html#SET_SCALAR_INDICES_FROM_CONFIG'>set_scalar_indices_from_config</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SET_SCALAR_INDICES_FROM_CONFIG_10">( id , idum1 , idum2 )<a name='998'>
<a name='999'>
      num_bytes_allocated = 0 <a name='1000'>
<a name='1001'>
<a name='1002'>
      IF ( dyn_opt == DYN_NODYN ) THEN<a name='1003'>
<a name='1004'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_4"> ( 'DYNAMICS OPTION: dynamics disabled ' )<a name='1005'>
# include &lt;<A href='../../html_code/include/nodyn_allocs.inc.html'>nodyn_allocs.inc</A>&gt; ( 'DYNAMICS OPTION: dynamics disabled ' )<A NAME="nodyn_allocs.inc_3"><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1006'>
<a name='1007'>
#if (EM_CORE == 1)<a name='1008'>
      ELSE IF ( mod(dyn_opt, 100) == DYN_EM ) THEN<a name='1009'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_5"> ( 'DYNAMICS OPTION: Eulerian Mass Coordinate ')<a name='1010'>
# include &lt;<A href='../../html_code/include/em_allocs.inc.html'>em_allocs.inc</A>&gt; ( 'DYNAMICS OPTION: Eulerian Mass Coordinate ')<A NAME="em_allocs.inc_4"><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1011'>
#endif<a name='1012'>
#if (NMM_CORE == 1)<a name='1013'>
      ELSE IF ( dyn_opt == DYN_NMM ) THEN<a name='1014'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_6"> ( 'DYNAMICS OPTION: nmm dyncore' )<a name='1015'>
# include &lt;<A href='../../html_code/include/nmm_allocs.inc.html'>nmm_allocs.inc</A>&gt; ( 'DYNAMICS OPTION: nmm dyncore' )<A NAME="nmm_allocs.inc_5"><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1016'>
#endif<a name='1017'>
#if (COAMPS_CORE == 1)<a name='1018'>
      ELSE IF ( dyn_opt == DYN_COAMPS ) THEN<a name='1019'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_7"> ( 'DYNAMICS OPTION: coamps dyncore' )<a name='1020'>
# include &lt;<A href='../../html_code/include/coamps_allocs.inc.html'>coamps_allocs.inc</A>&gt; ( 'DYNAMICS OPTION: coamps dyncore' )<A NAME="coamps_allocs.inc_6"><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1021'>
#endif<a name='1022'>
#if (EXP_CORE==1)<a name='1023'>
      ELSE IF ( dyn_opt == DYN_EXP ) THEN<a name='1024'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_8"> ( 'DYNAMICS OPTION: experimental dyncore' )<a name='1025'>
# include &lt;<A href='../../html_code/include/exp_allocs.inc.html'>exp_allocs.inc</A>&gt; ( 'DYNAMICS OPTION: experimental dyncore' )<A NAME="exp_allocs.inc_7"><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1026'>
#endif<a name='1027'>
<a name='1028'>
      ELSE<a name='1029'>
<a name='1030'>
        WRITE( wrf_err_message , * )'Invalid specification of dynamics: dyn_opt = ',dyn_opt<a name='1031'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_87"> ( TRIM ( wrf_err_message ) )<a name='1032'>
      ENDIF<a name='1033'>
<a name='1034'>
      WRITE(message,*)'alloc_space_field: domain ',id,' ',num_bytes_allocated<a name='1035'>
      CALL  <A href='../../html_code/frame/module_wrf_error.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/frame/module_domain.F.html#ALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_61">( 1, message )<a name='1036'>
<a name='1037'>
   END SUBROUTINE alloc_space_field<a name='1038'>
<a name='1039'>
<font color=#447700>!<a name='1040'></font>
<a name='1041'>
<font color=#447700>!  This routine is used to DEALLOCATE space for a single domain.  First<a name='1042'></font>
<font color=#447700>!  the pointers in the linked list are fixed (so the one in the middle can<a name='1043'></font>
<font color=#447700>!  be removed).  Second, the field data are all removed through a CALL to <a name='1044'></font>
<font color=#447700>!  the dealloc_space_domain routine.  Finally, the pointer to the domain<a name='1045'></font>
<font color=#447700>!  itself is DEALLOCATEd.<a name='1046'></font>
<a name='1047'>
<A NAME='DEALLOC_SPACE_DOMAIN'><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_DOMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1048'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>dealloc_space_domain</font> ( id ),<A href='../../call_from/DEALLOC_SPACE_DOMAIN.html' TARGET='index'>2</A><a name='1049'>
      <a name='1050'>
      IMPLICIT NONE<a name='1051'>
<a name='1052'>
      <font color=#447700>!  Input data.<a name='1053'></font>
<a name='1054'>
      INTEGER , INTENT(IN)            :: id<a name='1055'>
<a name='1056'>
      <font color=#447700>!  Local data.<a name='1057'></font>
<a name='1058'>
      TYPE(domain) , POINTER          :: grid<a name='1059'>
      LOGICAL                         :: found<a name='1060'>
<a name='1061'>
      <font color=#447700>!  Initializations required to start the routine.<a name='1062'></font>
<a name='1063'>
      grid =&gt; head_grid<a name='1064'>
      old_grid =&gt; head_grid<a name='1065'>
      found = .FALSE.<a name='1066'>
<a name='1067'>
      <font color=#447700>!  The identity of the domain to delete is based upon the "id".<a name='1068'></font>
      <font color=#447700>!  We search all of the possible grids.  It is required to find a domain<a name='1069'></font>
      <font color=#447700>!  otherwise it is a fatal error.  <a name='1070'></font>
<a name='1071'>
      find_grid : DO WHILE ( ASSOCIATED(grid) ) <a name='1072'>
         IF ( grid%id == id ) THEN<a name='1073'>
            found = .TRUE.<a name='1074'>
            old_grid%next =&gt; grid%next<a name='1075'>
            CALL <A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD'>dealloc_space_field</A><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DEALLOC_SPACE_FIELD_2"> ( grid )<a name='1076'>
            DEALLOCATE(grid)<a name='1077'>
            EXIT find_grid<a name='1078'>
         END IF<a name='1079'>
         old_grid =&gt; grid<a name='1080'>
         grid     =&gt; grid%next<a name='1081'>
      END DO find_grid<a name='1082'>
<a name='1083'>
      IF ( .NOT. found ) THEN<a name='1084'>
         WRITE ( wrf_err_message , * ) 'module_domain: dealloc_space_domain: Could not de-allocate grid id ',id<a name='1085'>
         CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_DOMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_88"> ( TRIM( wrf_err_message ) ) <a name='1086'>
      END IF<a name='1087'>
<a name='1088'>
   END SUBROUTINE dealloc_space_domain<a name='1089'>
<a name='1090'>
<font color=#447700>!<a name='1091'></font>
<a name='1092'>
<font color=#447700>!  This routine DEALLOCATEs each gridded field for this domain.  For each type of<a name='1093'></font>
<font color=#447700>!  different array (1d, 2d, 3d, etc.), the space for each pointer is DEALLOCATEd<a name='1094'></font>
<font color=#447700>!  for every -1 (i.e., each different meteorological field).<a name='1095'></font>
<a name='1096'>
<A NAME='DEALLOC_SPACE_FIELD'><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1097'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>dealloc_space_field</font> ( grid ) <A href='../../call_to/DEALLOC_SPACE_FIELD.html' TARGET='index'>3</A>,<A href='../../call_from/DEALLOC_SPACE_FIELD.html' TARGET='index'>1</A><a name='1098'>
      <a name='1099'>
      IMPLICIT NONE<a name='1100'>
<a name='1101'>
      <font color=#447700>!  Input data.<a name='1102'></font>
<a name='1103'>
      TYPE(domain)              , POINTER :: grid<a name='1104'>
<a name='1105'>
      <font color=#447700>!  Local data.<a name='1106'></font>
<a name='1107'>
      INTEGER                             :: dyn_opt, ierr<a name='1108'>
<a name='1109'>
      CALL nl_get_dyn_opt( 1, dyn_opt )<a name='1110'>
<a name='1111'>
      IF      ( .FALSE. )           THEN<a name='1112'>
<a name='1113'>
#if (EM_CORE == 1)<a name='1114'>
      ELSE IF ( mod(dyn_opt, 100) == DYN_EM ) THEN<a name='1115'>
# include &lt;<A href='../../html_code/include/em_deallocs.inc.html'>em_deallocs.inc</A>&gt;<A NAME="em_deallocs.inc_8"><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1116'>
#endif<a name='1117'>
#if (NMM_CORE == 1)<a name='1118'>
      ELSE IF ( dyn_opt == DYN_NMM ) THEN<a name='1119'>
# include &lt;<A href='../../html_code/include/nmm_deallocs.inc.html'>nmm_deallocs.inc</A>&gt;<A NAME="nmm_deallocs.inc_9"><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1120'>
#endif<a name='1121'>
#if (COAMPS_CORE == 1)<a name='1122'>
      ELSE IF ( dyn_opt == DYN_COAMPS ) THEN<a name='1123'>
# include &lt;<A href='../../html_code/include/coamps_deallocs.inc.html'>coamps_deallocs.inc</A>&gt;<A NAME="coamps_deallocs.inc_10"><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1124'>
#endif<a name='1125'>
#if (EXP_CORE==1)<a name='1126'>
      ELSE IF ( dyn_opt == DYN_EXP ) THEN<a name='1127'>
# include &lt;<A href='../../html_code/include/exp_deallocs.inc.html'>exp_deallocs.inc</A>&gt;<A NAME="exp_deallocs.inc_11"><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><a name='1128'>
#endif<a name='1129'>
      ELSE<a name='1130'>
        WRITE( wrf_err_message , * )'dealloc_space_field: Invalid specification of dynamics: dyn_opt = ',dyn_opt<a name='1131'>
        CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/frame/module_domain.F.html#DEALLOC_SPACE_FIELD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_89"> ( TRIM ( wrf_err_message ) )<a name='1132'>
      ENDIF<a name='1133'>
<a name='1134'>
   END SUBROUTINE dealloc_space_field<a name='1135'>
<a name='1136'>
<font color=#447700>!<a name='1137'></font>
<font color=#447700>!<a name='1138'></font>
<A NAME='FIND_GRID_BY_ID'><A href='../../html_code/frame/module_domain.F.html#FIND_GRID_BY_ID' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1139'>
   RECURSIVE <font color=#993300>SUBROUTINE </font><font color=#cc0000>find_grid_by_id</font> ( id, in_grid, result_grid ) <A href='../../call_to/FIND_GRID_BY_ID.html' TARGET='index'>1</A>,<A href='../../call_from/FIND_GRID_BY_ID.html' TARGET='index'>1</A><a name='1140'>
      IMPLICIT NONE<a name='1141'>
      INTEGER, INTENT(IN) :: id<a name='1142'>
      TYPE(domain), POINTER     :: in_grid <a name='1143'>
      TYPE(domain), POINTER     :: result_grid<a name='1144'>
<font color=#447700>! &lt;DESCRIPTION&gt;<a name='1145'></font>
<font color=#447700>! This is a recursive subroutine that traverses the domain hierarchy rooted<a name='1146'></font>
<font color=#447700>! at the input argument &lt;em&gt;in_grid&lt;/em&gt;, a pointer to TYPE(domain), and returns<a name='1147'></font>
<font color=#447700>! a pointer to the domain matching the integer argument &lt;em&gt;id&lt;/em&gt; if it exists.<a name='1148'></font>
<font color=#447700>!<a name='1149'></font>
<font color=#447700>! &lt;/DESCRIPTION&gt;<a name='1150'></font>
      TYPE(domain), POINTER     :: grid_ptr<a name='1151'>
      INTEGER                   :: kid<a name='1152'>
      LOGICAL                   :: found<a name='1153'>
      found = .FALSE.<a name='1154'>
      IF ( ASSOCIATED( in_grid ) ) THEN<a name='1155'>
      IF ( in_grid%id .EQ. id ) THEN<a name='1156'>
         result_grid =&gt; in_grid<a name='1157'>
      ELSE<a name='1158'>
         grid_ptr =&gt; in_grid<a name='1159'>
         DO WHILE ( ASSOCIATED( grid_ptr ) .AND. .NOT. found )<a name='1160'>
            DO kid = 1, max_nests<a name='1161'>
               IF ( ASSOCIATED( grid_ptr%nests(kid)%ptr ) .AND. .NOT. found ) THEN<a name='1162'>
                  CALL <A href='../../html_code/frame/module_domain.F.html#FIND_GRID_BY_ID'>find_grid_by_id</A><A href='../../html_code/frame/module_domain.F.html#FIND_GRID_BY_ID' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="FIND_GRID_BY_ID_1"> ( id, grid_ptr%nests(kid)%ptr, result_grid )<a name='1163'>
                  IF ( ASSOCIATED( result_grid ) ) THEN<a name='1164'>
                    IF ( result_grid%id .EQ. id ) found = .TRUE.<a name='1165'>
                  ENDIF<a name='1166'>
               ENDIF<a name='1167'>
            ENDDO<a name='1168'>
            IF ( .NOT. found ) grid_ptr =&gt; grid_ptr%sibling<a name='1169'>
         ENDDO<a name='1170'>
      ENDIF<a name='1171'>
      ENDIF<a name='1172'>
      RETURN<a name='1173'>
   END SUBROUTINE find_grid_by_id<a name='1174'>
<a name='1175'>
<a name='1176'>
<A NAME='FIRST_LOC_INTEGER'><A href='../../html_code/frame/module_domain.F.html#FIRST_LOC_INTEGER' TARGET='top_target'><IMG SRC="../../gif/bar_green.gif" border=0></A><a name='1177'>
   <font color=#993300>FUNCTION </font><font color=#cc0000>first_loc_integer</font> ( array , search ) RESULT ( loc ) <a name='1178'>
 <a name='1179'>
      IMPLICIT NONE<a name='1180'>
<a name='1181'>
      <font color=#447700>!  Input data.<a name='1182'></font>
<a name='1183'>
      INTEGER , INTENT(IN) , DIMENSION(:) :: array<a name='1184'>
      INTEGER , INTENT(IN)                :: search<a name='1185'>
<a name='1186'>
      <font color=#447700>!  Output data.<a name='1187'></font>
<a name='1188'>
      INTEGER                             :: loc<a name='1189'>
<a name='1190'>
<font color=#447700>!&lt;DESCRIPTION&gt;<a name='1191'></font>
<font color=#447700>!  This routine is used to find a specific domain identifier in an array<a name='1192'></font>
<font color=#447700>!  of domain identifiers.<a name='1193'></font>
<font color=#447700>!<a name='1194'></font>
<font color=#447700>!&lt;/DESCRIPTION&gt;<a name='1195'></font>
      <a name='1196'>
      <font color=#447700>!  Local data.<a name='1197'></font>
<a name='1198'>
      INTEGER :: loop<a name='1199'>
<a name='1200'>
      loc = -1<a name='1201'>
      find : DO loop = 1 , SIZE(array)<a name='1202'>
         IF ( search == array(loop) ) THEN         <a name='1203'>
            loc = loop<a name='1204'>
            EXIT find<a name='1205'>
         END IF<a name='1206'>
      END DO find<a name='1207'>
<a name='1208'>
   END FUNCTION first_loc_integer<a name='1209'>
<font color=#447700>!<a name='1210'></font>
<A NAME='INIT_MODULE_DOMAIN'><A href='../../html_code/frame/module_domain.F.html#INIT_MODULE_DOMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1211'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>init_module_domain</font> <A href='../../call_to/INIT_MODULE_DOMAIN.html' TARGET='index'>2</A><a name='1212'>
   END SUBROUTINE init_module_domain<a name='1213'>
<a name='1214'>
END MODULE module_domain<a name='1215'>
</pre></body></html>