subroutine a_vertical_diffusion( name, field, a_field, a_tendency, alt, a_alt, mut, a_mut, rdn, rdnw, kvdif, ide, jde, kde, ims, &
&ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_tendency(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: kvdif
real, intent(in) :: mut(ims:ime,jms:jme)
character*(1), intent(in) :: name
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)

!==============================================
! declare local variables
!==============================================
real a_vflux(its:ite,0:kte+1)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer ktf
real vflux(its:ite,0:kte+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_vflux(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
ktf = min(kte,kde-1)
! recompute : ktf
if (name .eq. 'w') then
  i_start = its
! recompute : i_start
  i_end = min(ite,ide-1)
! recompute : i_end
  j_start = jts
! recompute : j_start
  j_end = min(jte,jde-1)
! recompute : j_end
  do j = j_start, j_end
    do k = kts, ktf-1
      do i = i_start, i_end
        vflux(i,k) = kvdif/alt(i,k,j)*rdnw(k)*(field(i,k+1,j)-field(i,k,j))
      end do
    end do
    do i = i_start, i_end
      vflux(i,ktf) = 0.
    end do
! recompute : vflux
    do k = kts+1, ktf
      do i = i_start, i_end
        a_alt(i,k-1,j) = a_alt(i,k-1,j)-a_tendency(i,k,j)*0.5*(rdn(k)*g*g/mut(i,j))/(0.5*0.5*(alt(i,k,j)+alt(i,k-1,j))*(alt(i,k,j)+&
&alt(i,k-1,j)))*(vflux(i,k)-vflux(i,k-1))
        a_alt(i,k,j) = a_alt(i,k,j)-a_tendency(i,k,j)*0.5*(rdn(k)*g*g/mut(i,j))/(0.5*0.5*(alt(i,k,j)+alt(i,k-1,j))*(alt(i,k,j)+&
&alt(i,k-1,j)))*(vflux(i,k)-vflux(i,k-1))
        a_mut(i,j) = a_mut(i,j)-a_tendency(i,k,j)*rdn(k)*g*g/(mut(i,j)*mut(i,j))/(0.5*(alt(i,k,j)+alt(i,k-1,j)))*(vflux(i,k)-&
&vflux(i,k-1))
        a_vflux(i,k-1) = a_vflux(i,k-1)-a_tendency(i,k,j)*(rdn(k)*g*g/mut(i,j)/(0.5*(alt(i,k,j)+alt(i,k-1,j))))
        a_vflux(i,k) = a_vflux(i,k)+a_tendency(i,k,j)*(rdn(k)*g*g/mut(i,j)/(0.5*(alt(i,k,j)+alt(i,k-1,j))))
      end do
    end do
    do i = i_start, i_end
      a_vflux(i,ktf) = 0.
    end do
    do k = kts, ktf-1
      do i = i_start, i_end
        a_alt(i,k,j) = a_alt(i,k,j)-a_vflux(i,k)*kvdif/(alt(i,k,j)*alt(i,k,j))*rdnw(k)*(field(i,k+1,j)-field(i,k,j))
        a_field(i,k+1,j) = a_field(i,k+1,j)+a_vflux(i,k)*kvdif/alt(i,k,j)*rdnw(k)
        a_field(i,k,j) = a_field(i,k,j)-a_vflux(i,k)*kvdif/alt(i,k,j)*rdnw(k)
        a_vflux(i,k) = 0.
      end do
    end do
  end do
else if (name .eq. 'm') then
  i_start = its
! recompute : i_start
  i_end = min(ite,ide-1)
! recompute : i_end
  j_start = jts
! recompute : j_start
  j_end = min(jte,jde-1)
! recompute : j_end
  do j = j_start, j_end
    do k = kts, ktf-1
      do i = i_start, i_end
        vflux(i,k) = kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j)))*(field(i,k+1,j)-field(i,k,j))
      end do
    end do
! recompute : vflux
    do i = i_start, i_end
      vflux(i,0) = vflux(i,1)
    end do
    do i = i_start, i_end
      vflux(i,ktf) = 0.
    end do
! recompute : vflux
    do k = kts, ktf
      do i = i_start, i_end
        a_alt(i,k,j) = a_alt(i,k,j)-a_tendency(i,k,j)*g*g/mut(i,j)/(alt(i,k,j)*alt(i,k,j))*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
        a_mut(i,j) = a_mut(i,j)-a_tendency(i,k,j)*g*g/(mut(i,j)*mut(i,j))/alt(i,k,j)*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
        a_vflux(i,k-1) = a_vflux(i,k-1)-a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
        a_vflux(i,k) = a_vflux(i,k)+a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
      end do
    end do
    do i = i_start, i_end
      a_vflux(i,ktf) = 0.
    end do
    do i = i_start, i_end
      a_vflux(i,1) = a_vflux(i,1)+a_vflux(i,0)
      a_vflux(i,0) = 0.
    end do
    do k = kts, ktf-1
      do i = i_start, i_end
        a_alt(i,k+1,j) = a_alt(i,k+1,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)&
&))*(field(i,k+1,j)-field(i,k,j))
        a_alt(i,k,j) = a_alt(i,k,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)))*&
&(field(i,k+1,j)-field(i,k,j))
        a_field(i,k+1,j) = a_field(i,k+1,j)+a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
        a_field(i,k,j) = a_field(i,k,j)-a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
        a_vflux(i,k) = 0.
      end do
    end do
  end do
endif

end subroutine a_vertical_diffusion


subroutine a_vertical_diffusion_3dmp( field, a_field, a_tendency, base_3d, alt, a_alt, mut, a_mut, rdn, rdnw, kvdif, ide, jde, kde,&
& ims, ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_tendency(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: base_3d(ims:ime,kms:kme,jms:jme)
real, intent(in) :: field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: kvdif
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)

!==============================================
! declare local variables
!==============================================
real a_vflux(its:ite,0:kte+1)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer ktf
real vflux(its:ite,0:kte+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_vflux(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
ktf = min(kte,kde-1)
! recompute : ktf
i_start = its
! recompute : i_start
i_end = min(ite,ide-1)
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = min(jte,jde-1)
! recompute : j_end
do j = j_start, j_end
  do k = kts, ktf-1
    do i = i_start, i_end
      vflux(i,k) = kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j)))*(field(i,k+1,j)-field(i,k,j)-base_3d(i,k+1,j)+base_3d(i,k,j))
    end do
  end do
! recompute : vflux
  do i = i_start, i_end
    vflux(i,0) = vflux(i,1)
  end do
  do i = i_start, i_end
    vflux(i,ktf) = 0.
  end do
! recompute : vflux
  do k = kts, ktf
    do i = i_start, i_end
      a_alt(i,k,j) = a_alt(i,k,j)-a_tendency(i,k,j)*g*g/mut(i,j)/(alt(i,k,j)*alt(i,k,j))*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
      a_mut(i,j) = a_mut(i,j)-a_tendency(i,k,j)*g*g/(mut(i,j)*mut(i,j))/alt(i,k,j)*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
      a_vflux(i,k-1) = a_vflux(i,k-1)-a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
      a_vflux(i,k) = a_vflux(i,k)+a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
    end do
  end do
  do i = i_start, i_end
    a_vflux(i,ktf) = 0.
  end do
  do i = i_start, i_end
    a_vflux(i,1) = a_vflux(i,1)+a_vflux(i,0)
    a_vflux(i,0) = 0.
  end do
  do k = kts, ktf-1
    do i = i_start, i_end
      a_alt(i,k+1,j) = a_alt(i,k+1,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)))&
&*(field(i,k+1,j)-field(i,k,j)-base_3d(i,k+1,j)+base_3d(i,k,j))
      a_alt(i,k,j) = a_alt(i,k,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)))*&
&(field(i,k+1,j)-field(i,k,j)-base_3d(i,k+1,j)+base_3d(i,k,j))
      a_field(i,k+1,j) = a_field(i,k+1,j)+a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
      a_field(i,k,j) = a_field(i,k,j)-a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
      a_vflux(i,k) = 0.
    end do
  end do
end do

end subroutine a_vertical_diffusion_3dmp


subroutine a_vertical_diffusion_mp( field, a_field, a_tendency, base, alt, a_alt, mut, a_mut, rdn, rdnw, kvdif, ide, jde, kde, ims,&
& ime, jms, jme, kms, kme, its, ite, jts, jte, kts, kte )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.7.18  **
!******************************************************************
!******************************************************************
!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare arguments
!==============================================
integer, intent(in) :: ime
integer, intent(in) :: ims
integer, intent(in) :: jme
integer, intent(in) :: jms
integer, intent(in) :: kme
integer, intent(in) :: kms
real, intent(inout) :: a_alt(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_field(ims:ime,kms:kme,jms:jme)
real, intent(inout) :: a_mut(ims:ime,jms:jme)
real, intent(inout) :: a_tendency(ims:ime,kms:kme,jms:jme)
real, intent(in) :: alt(ims:ime,kms:kme,jms:jme)
real, intent(in) :: base(kms:kme)
real, intent(in) :: field(ims:ime,kms:kme,jms:jme)
integer, intent(in) :: ide
integer, intent(in) :: ite
integer, intent(in) :: its
integer, intent(in) :: jde
integer, intent(in) :: jte
integer, intent(in) :: jts
integer, intent(in) :: kde
integer, intent(in) :: kte
integer, intent(in) :: kts
real, intent(in) :: kvdif
real, intent(in) :: mut(ims:ime,jms:jme)
real, intent(in) :: rdn(kms:kme)
real, intent(in) :: rdnw(kms:kme)

!==============================================
! declare local variables
!==============================================
real a_vflux(its:ite,0:kte+1)
integer i
integer i_end
integer i_start
integer j
integer j_end
integer j_start
integer k
integer ktf
real vflux(its:ite,0:kte+1)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
a_vflux(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
ktf = min(kte,kde-1)
! recompute : ktf
i_start = its
! recompute : i_start
i_end = min(ite,ide-1)
! recompute : i_end
j_start = jts
! recompute : j_start
j_end = min(jte,jde-1)
! recompute : j_end
do j = j_start, j_end
  do k = kts, ktf-1
    do i = i_start, i_end
      vflux(i,k) = kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j)))*(field(i,k+1,j)-field(i,k,j)-base(k+1)+base(k))
    end do
  end do
! recompute : vflux
  do i = i_start, i_end
    vflux(i,0) = vflux(i,1)
  end do
  do i = i_start, i_end
    vflux(i,ktf) = 0.
  end do
! recompute : vflux
  do k = kts, ktf
    do i = i_start, i_end
      a_alt(i,k,j) = a_alt(i,k,j)-a_tendency(i,k,j)*g*g/mut(i,j)/(alt(i,k,j)*alt(i,k,j))*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
      a_mut(i,j) = a_mut(i,j)-a_tendency(i,k,j)*g*g/(mut(i,j)*mut(i,j))/alt(i,k,j)*rdnw(k)*(vflux(i,k)-vflux(i,k-1))
      a_vflux(i,k-1) = a_vflux(i,k-1)-a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
      a_vflux(i,k) = a_vflux(i,k)+a_tendency(i,k,j)*g*g/mut(i,j)/alt(i,k,j)*rdnw(k)
    end do
  end do
  do i = i_start, i_end
    a_vflux(i,ktf) = 0.
  end do
  do i = i_start, i_end
    a_vflux(i,1) = a_vflux(i,1)+a_vflux(i,0)
    a_vflux(i,0) = 0.
  end do
  do k = kts, ktf-1
    do i = i_start, i_end
      a_alt(i,k+1,j) = a_alt(i,k+1,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)))&
&*(field(i,k+1,j)-field(i,k,j)-base(k+1)+base(k))
      a_alt(i,k,j) = a_alt(i,k,j)-a_vflux(i,k)*0.5*kvdif*rdn(k+1)/(0.5*0.5*(alt(i,k,j)+alt(i,k+1,j))*(alt(i,k,j)+alt(i,k+1,j)))*&
&(field(i,k+1,j)-field(i,k,j)-base(k+1)+base(k))
      a_field(i,k+1,j) = a_field(i,k+1,j)+a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
      a_field(i,k,j) = a_field(i,k,j)-a_vflux(i,k)*(kvdif*rdn(k+1)/(0.5*(alt(i,k,j)+alt(i,k+1,j))))
      a_vflux(i,k) = 0.
    end do
  end do
end do

end subroutine a_vertical_diffusion_mp

